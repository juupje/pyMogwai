{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyMogwai API Documentation","text":""},{"location":"#mogwai.core","title":"<code>core</code>","text":""},{"location":"#mogwai.core.hd_index","title":"<code>hd_index</code>","text":"<p>Created on 2024-11-07</p> <p>@author: wf</p> <p>base on A. Harth and S. Decker, \"Optimized index structures for querying RDF from the Web,\" Third Latin American Web Congress (LA-WEB'2005), Buenos Aires, Argentina, 2005, pp. 10 pp.-, doi: 10.1109/LAWEB.2005.25. keywords: {Resource description framework;Data models;Semantic Web;Indexes;Java;Vocabulary;Database systems;Memory;Indexing;Information retrieval},</p>"},{"location":"#mogwai.core.hd_index.Index","title":"<code>Index</code>","text":"<p>A Single index in the SPOG matrix as explained in identified by from/to positions</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>class Index:\n    \"\"\"A Single index in the SPOG matrix as explained in\n    identified by from/to positions\"\"\"\n\n    def __init__(self, from_pos: str, to_pos: str):\n        \"\"\"\n        Args:\n            from_pos: First position (S,P,O,G)\n            to_pos: Second position (S,P,O,G)\n        \"\"\"\n        self.from_pos = from_pos\n        self.to_pos = to_pos\n        self.lookup = {}\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Full quad index name based on Harth/Decker SPOG ordering\"\"\"\n        index_name = f\"{self.from_pos}{self.to_pos}\"\n        return index_name\n\n    def add_quad(self, quad: Quad) -&gt; None:\n        \"\"\"Add a quad to this index's lookup using quad positions\"\"\"\n        from_val = getattr(quad, self.from_pos.lower())\n        to_val = getattr(quad, self.to_pos.lower())\n\n        if from_val not in self.lookup:\n            self.lookup[from_val] = set()\n        self.lookup[from_val].add(to_val)\n</code></pre>"},{"location":"#mogwai.core.hd_index.Index.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Full quad index name based on Harth/Decker SPOG ordering</p>"},{"location":"#mogwai.core.hd_index.Index.__init__","title":"<code>__init__(from_pos, to_pos)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>str</code> <p>First position (S,P,O,G)</p> required <code>to_pos</code> <code>str</code> <p>Second position (S,P,O,G)</p> required Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def __init__(self, from_pos: str, to_pos: str):\n    \"\"\"\n    Args:\n        from_pos: First position (S,P,O,G)\n        to_pos: Second position (S,P,O,G)\n    \"\"\"\n    self.from_pos = from_pos\n    self.to_pos = to_pos\n    self.lookup = {}\n</code></pre>"},{"location":"#mogwai.core.hd_index.Index.add_quad","title":"<code>add_quad(quad)</code>","text":"<p>Add a quad to this index's lookup using quad positions</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def add_quad(self, quad: Quad) -&gt; None:\n    \"\"\"Add a quad to this index's lookup using quad positions\"\"\"\n    from_val = getattr(quad, self.from_pos.lower())\n    to_val = getattr(quad, self.to_pos.lower())\n\n    if from_val not in self.lookup:\n        self.lookup[from_val] = set()\n    self.lookup[from_val].add(to_val)\n</code></pre>"},{"location":"#mogwai.core.hd_index.IndexConfig","title":"<code>IndexConfig</code>  <code>dataclass</code>","text":"<p>Configuration of which SPOG indices to use</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>@dataclass\nclass IndexConfig:\n    \"\"\"Configuration of which SPOG indices to use\"\"\"\n\n    active_indices: Set[str]\n</code></pre>"},{"location":"#mogwai.core.hd_index.IndexConfigs","title":"<code>IndexConfigs</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Standard index configurations</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>class IndexConfigs(Enum):\n    \"\"\"Standard index configurations\"\"\"\n\n    OFF = \"off\"  # Use no indices\n    ALL = \"all\"  # Use all 16 indices\n    MINIMAL = \"minimal\"  # Use minimal required set\n\n    def get_config(self) -&gt; IndexConfig:\n        \"\"\"Get the index configuration for this enum value\"\"\"\n        if self == IndexConfigs.OFF:\n            return IndexConfig(set())\n\n        if self == IndexConfigs.ALL:\n            positions = [\"S\", \"P\", \"O\", \"G\"]\n            indices = {\n                f\"{from_pos}{to_pos}\"\n                for from_pos in positions\n                for to_pos in positions\n                if from_pos != to_pos\n            }\n            return IndexConfig(indices)\n\n        if self == IndexConfigs.MINIMAL:\n            return IndexConfig(\n                {\n                    # Core indices for basic node relationships\n                    \"PS\",  # Predicate -&gt; Subject: links predicates to subjects (e.g., labels or properties to nodes)\n                    \"PO\",  # Predicate -&gt; Object: maps predicates to values (e.g., property values)\n                    \"SO\",  # Subject -&gt; Object: links source nodes to target nodes in relationships\n                    \"OS\",  # Object -&gt; Subject: reverse lookup for values back to nodes\n                    # Graph-based indices for context-specific associations\n                    \"PG\",  # Predicate -&gt; Graph: associates predicates with graph contexts\n                    \"SG\",  # Subject -&gt; Graph: associates subjects with graph contexts\n                    \"GO\",  # Graph -&gt; Object: maps graph contexts to objects for grouped retrieval\n                    \"GP\",  # Graph -&gt; Predicate: links graph contexts to predicates\n                }\n            )\n\n        raise ValueError(f\"Unknown index configuration: {self}\")\n</code></pre>"},{"location":"#mogwai.core.hd_index.IndexConfigs.get_config","title":"<code>get_config()</code>","text":"<p>Get the index configuration for this enum value</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def get_config(self) -&gt; IndexConfig:\n    \"\"\"Get the index configuration for this enum value\"\"\"\n    if self == IndexConfigs.OFF:\n        return IndexConfig(set())\n\n    if self == IndexConfigs.ALL:\n        positions = [\"S\", \"P\", \"O\", \"G\"]\n        indices = {\n            f\"{from_pos}{to_pos}\"\n            for from_pos in positions\n            for to_pos in positions\n            if from_pos != to_pos\n        }\n        return IndexConfig(indices)\n\n    if self == IndexConfigs.MINIMAL:\n        return IndexConfig(\n            {\n                # Core indices for basic node relationships\n                \"PS\",  # Predicate -&gt; Subject: links predicates to subjects (e.g., labels or properties to nodes)\n                \"PO\",  # Predicate -&gt; Object: maps predicates to values (e.g., property values)\n                \"SO\",  # Subject -&gt; Object: links source nodes to target nodes in relationships\n                \"OS\",  # Object -&gt; Subject: reverse lookup for values back to nodes\n                # Graph-based indices for context-specific associations\n                \"PG\",  # Predicate -&gt; Graph: associates predicates with graph contexts\n                \"SG\",  # Subject -&gt; Graph: associates subjects with graph contexts\n                \"GO\",  # Graph -&gt; Object: maps graph contexts to objects for grouped retrieval\n                \"GP\",  # Graph -&gt; Predicate: links graph contexts to predicates\n            }\n        )\n\n    raise ValueError(f\"Unknown index configuration: {self}\")\n</code></pre>"},{"location":"#mogwai.core.hd_index.Quad","title":"<code>Quad</code>  <code>dataclass</code>","text":"<p>A quad of hashable values (Subject-Predicate-Object-Graph)</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>@dataclass(frozen=True)\nclass Quad:\n    \"\"\"A quad of hashable values (Subject-Predicate-Object-Graph)\"\"\"\n\n    s: Hashable  # Subject\n    p: Hashable  # Predicate\n    o: Hashable  # Object\n    g: Hashable | None = None  # Graph context\n</code></pre>"},{"location":"#mogwai.core.hd_index.SPOGIndex","title":"<code>SPOGIndex</code>","text":"<p>all 16 possible indices based on SPOG matrix</p> <p>see http://harth.org/andreas/ YARS and the paper</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>class SPOGIndex:\n    \"\"\"\n    all 16 possible indices based on SPOG matrix\n\n    see http://harth.org/andreas/ YARS and the paper\n    \"\"\"\n\n    def __init__(self, config: IndexConfig):\n        self.config = config\n        positions = [\"S\", \"P\", \"O\", \"G\"]\n        self.indices = {}\n        self.indices = {}\n        for from_pos in positions:\n            for to_pos in positions:\n                if from_pos != to_pos:\n                    index = Index(from_pos, to_pos)\n                    self.indices[index.name] = index\n\n    def get_lookup(self, from_pos: str, to_pos: str) -&gt; dict | None:\n        \"\"\"\n        Get lookup dict for from-&gt;to positions if active\n\n        Args:\n            from_pos: From position (S,P,O,G)\n            to_pos: To position (S,P,O,G)\n        Returns:\n            Lookup dict if index active in current config, None otherwise\n        \"\"\"\n        index_name = f\"{from_pos}{to_pos}\"\n        if index_name in self.config.active_indices:\n            return self.indices[index_name].lookup\n        return None\n\n    def add_quad(self, quad: Quad) -&gt; None:\n        \"\"\"Add quad only to configured active indices\"\"\"\n        for index_name in self.config.active_indices:\n            self.indices[index_name].add_quad(quad)\n</code></pre>"},{"location":"#mogwai.core.hd_index.SPOGIndex.add_quad","title":"<code>add_quad(quad)</code>","text":"<p>Add quad only to configured active indices</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def add_quad(self, quad: Quad) -&gt; None:\n    \"\"\"Add quad only to configured active indices\"\"\"\n    for index_name in self.config.active_indices:\n        self.indices[index_name].add_quad(quad)\n</code></pre>"},{"location":"#mogwai.core.hd_index.SPOGIndex.get_lookup","title":"<code>get_lookup(from_pos, to_pos)</code>","text":"<p>Get lookup dict for from-&gt;to positions if active</p> <p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>str</code> <p>From position (S,P,O,G)</p> required <code>to_pos</code> <code>str</code> <p>To position (S,P,O,G)</p> required <p>Returns:     Lookup dict if index active in current config, None otherwise</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def get_lookup(self, from_pos: str, to_pos: str) -&gt; dict | None:\n    \"\"\"\n    Get lookup dict for from-&gt;to positions if active\n\n    Args:\n        from_pos: From position (S,P,O,G)\n        to_pos: To position (S,P,O,G)\n    Returns:\n        Lookup dict if index active in current config, None otherwise\n    \"\"\"\n    index_name = f\"{from_pos}{to_pos}\"\n    if index_name in self.config.active_indices:\n        return self.indices[index_name].lookup\n    return None\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph","title":"<code>mogwaigraph</code>","text":""},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph","title":"<code>MogwaiGraph</code>","text":"<p>               Bases: <code>DiGraph</code></p> <p>networkx based directed graph see https://networkx.org/documentation/stable/reference/classes/digraph.html</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>class MogwaiGraph(networkx.DiGraph):\n    \"\"\"\n    networkx based directed graph\n    see https://networkx.org/documentation/stable/reference/classes/digraph.html\n    \"\"\"\n\n    def __init__(\n        self, incoming_graph_data=None, config: MogwaiGraphConfig = None, **attr\n    ):\n        \"\"\"Initialize a MogwaiGraph with optional data and configuration.\n\n        Args:\n            incoming_graph_data: Graph data in NetworkX compatible format\n            config (MogwaiGraphConfig): Configuration for field names and defaults\n            **attr: Graph attributes as key=value pairs\n        \"\"\"\n        super().__init__(incoming_graph_data, **attr)\n        self.counter = 0\n        self.config = config or MogwaiGraphConfig()\n        # Initialize SPOG index based on config\n        index_config = IndexConfigs[self.config.index_config.upper()].get_config()\n        self.spog_index = SPOGIndex(index_config)\n\n    def get_next_node_id(self):\n        \"\"\"\n        get the next node_id\n        \"\"\"\n        node_id = self.counter\n        self.counter += 1\n        return node_id\n\n    def add_to_index(\n        self,\n        element_type: str,\n        subject_id: Hashable,\n        label: set,\n        name: str,\n        properties: dict,\n    ):\n        \"\"\"\n        Add labels, name, and properties to the SPOG index for a\n        given subject and element_type\n\n        Args:\n            element_type: (str): node or edge\n            subject_id (Hashable): The ID of the subject (node or edge).\n            label (set): Set of labels for the subject.\n            name (str): Name of the subject.\n            properties (dict): Dictionary of additional properties to index.\n        \"\"\"\n        # only index if the config calls for it\n        if self.config.index_config == \"off\":\n            return\n        # Add quads for each label with g=\"label\"\n        for lbl in label:\n            label_quad = Quad(s=subject_id, p=\"label\", o=lbl, g=f\"{element_type}-label\")\n            self.spog_index.add_quad(label_quad)\n\n        # Add quad for name with g=\"name\"\n        name_quad = Quad(s=subject_id, p=\"name\", o=name, g=f\"{element_type}-name\")\n        self.spog_index.add_quad(name_quad)\n\n        # Add quads for each property with g=\"property\"\n        for prop_name, prop_value in properties.items():\n            if not isinstance(prop_value, Hashable):\n                prop_value = str(prop_value)  # Ensure property value is hashable\n            property_quad = Quad(\n                s=subject_id, p=prop_name, o=prop_value, g=f\"{element_type}-property\"\n            )\n            self.spog_index.add_quad(property_quad)\n\n    def add_labeled_node(\n        self,\n        label: set | str,\n        name: str,\n        properties: dict = None,\n        node_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; Any:\n        \"\"\"\n        Add a labeled node to the graph.\n\n        we can only insert a node by hashable value and as names and ids\n        might occur multiple times we use incremented node ids if no node_id is provided\n\n        Args:\n            label (Union[set, str]): The label or set of labels for the node.\n            name (str): The name of the node.\n            properties (dict, optional): Additional properties for the node. Defaults to None.\n            node_id (Optional[int], optional): The ID for the node. If not provided, a new ID will be generated. Defaults to None.\n            kwargs (): further property values\n        Returns:\n            Any: The ID of the newly added node - will be an integer if node_id was kept as default None\n\n        Raises:\n            MogwaiGraphError: If a node with the provided ID already exists in the graph.\n        \"\"\"\n        label = (\n            label\n            if isinstance(label, set)\n            else (set(label) if isinstance(label, (list, tuple)) else {label})\n        )\n        if node_id is None:\n            node_id = self.get_next_node_id()\n        properties = properties or {}\n        properties.update(kwargs)\n        if self.config.name_field in properties:\n            raise MogwaiGraphError(\n                f\"The '{self.config.name_field}' property is reserved for the node name.\"\n            )\n        elif self.config.label_field in properties:\n            raise MogwaiGraphError(\n                f\"The '{self.config.label_field}' property is reserved for the node labels.\"\n            )\n        node_props = {\n            self.config.name_field: name,\n            self.config.label_field: label,\n            **properties,\n        }\n        super().add_node(node_id, **node_props)\n        # Use add_to_index to add label, name, and properties as quads\n        self.add_to_index(\"node\", node_id, label, name, properties)\n        return node_id\n\n    def add_labeled_edge(\n        self, srcId: int, destId: int, edgeLabel: str, properties: dict = None, **kwargs\n    ):\n        \"\"\"\n        add a labeled edge\n        \"\"\"\n        if self.has_node(srcId) and self.has_node(destId):\n            properties = properties or {}\n            properties.update(kwargs)\n            if self.config.edge_label_field in properties:\n                raise MogwaiGraphError(\n                    f\"The '{self.config.edge_label_field}' property is reserved for the edge label.\"\n                )\n            elif self.config.label_field in properties:\n                raise MogwaiGraphError(\n                    f\"The '{self.config.label_field}' property is reserved for the node labels.\"\n                )\n            edge_props = {self.config.edge_label_field: edgeLabel, **properties}\n            super().add_edge(srcId, destId, **edge_props)\n            # Add a quad specifically for the edge connection\n            edge_quad = Quad(s=srcId, p=edgeLabel, o=destId, g=\"edge-link\")\n            self.spog_index.add_quad(edge_quad)\n\n            # Use add_to_index to add label, name, and properties as quads\n            self.add_to_index(\"edge\", srcId, {edgeLabel}, edgeLabel, properties)\n        else:\n            raise MogwaiGraphError(\n                f\"Node with id {srcId if srcId&lt;0 else destId} is not in the graph.\"\n            )\n\n    def add_node(self, *args, **kwargs):\n        \"\"\"Add a node with default or explicit labels\"\"\"\n        if len(args) &gt; 0:\n            node_id = args[0]\n        else:\n            node_id = self.get_next_node_id()\n\n        label = kwargs.pop(\"labels\", {self.config.default_node_label})\n        name = kwargs.pop(\"name\", str(node_id))\n        return self.add_labeled_node(label, name, properties=kwargs, node_id=node_id)\n\n    def add_edge(self, *args, **kwargs):\n        \"\"\"Add an edge with default or explicit label\"\"\"\n        if len(args) &lt; 2:\n            raise MogwaiGraphError(\"add_edge() requires source and target node ids\")\n        src, dst = args[0:2]\n        label = kwargs.pop(self.config.edge_label_field, self.config.default_edge_label)\n        return self.add_labeled_edge(src, dst, label, properties=kwargs)\n\n    def _get_nodes_set(self, label: set, name: str):\n        n_none = name is None\n        if n_none:\n            return [n for n in self.nodes(date=True) if label.issubset(n[1][\"labels\"])]\n        if not n_none:\n            return [\n                n\n                for n in self.nodes(data=True)\n                if label.issubset(n[1][\"labels\"]) and n[1][\"name\"] == name\n            ]\n        return self.nodes\n\n    def get_nodes(self, label: str | set, name: str):\n        if type(label) is set:  # check if we are looking for multiple labels\n            if len(label) == 0:\n                label = None\n            else:\n                return self._get_nodes_set(label, name)\n\n        l_none, n_none = label is None, name is None\n        if not l_none and not n_none:\n            return [\n                n\n                for n in self.nodes(data=True)\n                if label in n[1][\"labels\"] and n[1][\"name\"] == name\n            ]\n        if l_none and not n_none:\n            return [n for n in self.nodes(data=True) if n[1][\"name\"] == name]\n        if not l_none and n_none:\n            return [n for n in self.nodes(date=True) if label in n[1][\"labels\"]]\n        return self.nodes\n\n    def merge_subgraph(\n        self, other: \"MogwaiGraph\", srcId: int, targetId: int, edgeLabel: str\n    ):\n        mapping = {k: self.get_next_node_id() for k in other.nodes}\n        relabeled = networkx.relabel_nodes(other, mapping, copy=True)\n        self.add_nodes_from(relabeled.nodes(data=True))\n        self.add_edges_from(relabeled.edges(data=True))\n        self.add_labeled_edge(\n            srcId=srcId, destId=mapping[targetId], edgeLabel=edgeLabel\n        )\n\n    def draw(self, outputfile, title: str = \"MogwaiGraph\", **kwargs):\n        \"\"\"\n        Draw the graph using graphviz\n        Parameters\n        ----------\n        outputfile : str\n            the file to save the graph to\n        title : str, default 'MogwaiGraph'\n            the title of the graph\n        kwargs : dict\n            additional parameters used to configure the drawing style.\n            For more details see `MogwaiGraphDrawer`\n        \"\"\"\n        MogwaiGraphDrawer(self, title=title, **kwargs).draw(outputfile)\n\n    @classmethod\n    def modern(cls, index_config=\"off\") -&gt; \"MogwaiGraph\":\n        \"\"\"\n        create the modern graph\n        see https://tinkerpop.apache.org/docs/current/tutorials/getting-started/\n        \"\"\"\n        config = MogwaiGraphConfig\n        config.index_config = index_config\n        g = MogwaiGraph(config=config)\n        marko = g.add_labeled_node(\"Person\", name=\"marko\", age=29)\n        vadas = g.add_labeled_node(\"Person\", name=\"vadas\", age=27)\n        lop = g.add_labeled_node(\"Software\", name=\"lop\", lang=\"java\")\n        josh = g.add_labeled_node(\"Person\", name=\"josh\", age=32)\n        ripple = g.add_labeled_node(\"Software\", name=\"ripple\", lang=\"java\")\n        peter = g.add_labeled_node(\"Person\", name=\"peter\", age=35)\n\n        g.add_labeled_edge(marko, vadas, \"knows\", weight=0.5)\n        g.add_labeled_edge(marko, josh, \"knows\", weight=1.0)\n        g.add_labeled_edge(marko, lop, \"created\", weight=0.4)\n        g.add_labeled_edge(josh, ripple, \"created\", weight=1.0)\n        g.add_labeled_edge(josh, lop, \"created\", weight=0.4)\n        g.add_labeled_edge(peter, lop, \"created\", weight=0.2)\n        return g\n\n    @classmethod\n    def crew(cls) -&gt; \"MogwaiGraph\":\n        \"\"\"\n        create the TheCrew example graph\n        see TinkerFactory.createTheCrew() in https://tinkerpop.apache.org/docs/current/reference/\n        \"\"\"\n        g = MogwaiGraph()\n\n        def t(startTime: int, endTime: int = None):\n            d = dict()\n            d[\"startTime\"] = startTime\n            if endTime is not None:\n                d[\"endTime\"] = endTime\n            return d\n\n        marko = g.add_labeled_node(\n            \"Person\",\n            name=\"marko\",\n            location={\n                \"san diego\": t(1997, 2001),\n                \"santa cruz\": t(2001, 2004),\n                \"brussels\": t(2004, 2005),\n                \"santa fe\": t(2005),\n            },\n        )\n        stephen = g.add_labeled_node(\n            \"Person\",\n            name=\"stephen\",\n            location={\n                \"centreville\": t(1990, 2000),\n                \"dulles\": t(2000, 2006),\n                \"purcellvilee\": t(2006),\n            },\n        )\n        matthias = g.add_labeled_node(\n            \"Person\",\n            name=\"matthias\",\n            location={\n                \"bremen\": t(2004, 2007),\n                \"baltimore\": t(2007, 2011),\n                \"oakland\": t(2011, 2014),\n                \"seattle\": t(2014),\n            },\n        )\n        daniel = g.add_labeled_node(\n            \"Person\",\n            name=\"daniel\",\n            location={\n                \"spremberg\": t(1982, 2005),\n                \"kaiserslautern\": t(2005, 2009),\n                \"aachen\": t(2009),\n            },\n        )\n        gremlin = g.add_labeled_node(\"Software\", name=\"gremlin\")\n        tinkergraph = g.add_labeled_node(\"Software\", name=\"tinkergraph\")\n\n        g.add_labeled_edge(marko, gremlin, \"uses\", skill=4)\n        g.add_labeled_edge(stephen, gremlin, \"uses\", skill=5)\n        g.add_labeled_edge(matthias, gremlin, \"uses\", skill=3)\n        g.add_labeled_edge(daniel, gremlin, \"uses\", skill=5)\n        g.add_labeled_edge(marko, tinkergraph, \"uses\", skill=5)\n        g.add_labeled_edge(stephen, tinkergraph, \"uses\", skill=4)\n        g.add_labeled_edge(matthias, tinkergraph, \"uses\", skill=3)\n        g.add_labeled_edge(daniel, tinkergraph, \"uses\", skill=3)\n        g.add_labeled_edge(gremlin, tinkergraph, \"traverses\")\n        g.add_labeled_edge(marko, tinkergraph, \"develops\", since=2010)\n        g.add_labeled_edge(stephen, tinkergraph, \"develops\", since=2011)\n        g.add_labeled_edge(marko, gremlin, \"develops\", since=2009)\n        g.add_labeled_edge(stephen, gremlin, \"develops\", since=2010)\n        g.add_labeled_edge(matthias, gremlin, \"develops\", since=2012)\n        return g\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.__init__","title":"<code>__init__(incoming_graph_data=None, config=None, **attr)</code>","text":"<p>Initialize a MogwaiGraph with optional data and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_graph_data</code> <p>Graph data in NetworkX compatible format</p> <code>None</code> <code>config</code> <code>MogwaiGraphConfig</code> <p>Configuration for field names and defaults</p> <code>None</code> <code>**attr</code> <p>Graph attributes as key=value pairs</p> <code>{}</code> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def __init__(\n    self, incoming_graph_data=None, config: MogwaiGraphConfig = None, **attr\n):\n    \"\"\"Initialize a MogwaiGraph with optional data and configuration.\n\n    Args:\n        incoming_graph_data: Graph data in NetworkX compatible format\n        config (MogwaiGraphConfig): Configuration for field names and defaults\n        **attr: Graph attributes as key=value pairs\n    \"\"\"\n    super().__init__(incoming_graph_data, **attr)\n    self.counter = 0\n    self.config = config or MogwaiGraphConfig()\n    # Initialize SPOG index based on config\n    index_config = IndexConfigs[self.config.index_config.upper()].get_config()\n    self.spog_index = SPOGIndex(index_config)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_edge","title":"<code>add_edge(*args, **kwargs)</code>","text":"<p>Add an edge with default or explicit label</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_edge(self, *args, **kwargs):\n    \"\"\"Add an edge with default or explicit label\"\"\"\n    if len(args) &lt; 2:\n        raise MogwaiGraphError(\"add_edge() requires source and target node ids\")\n    src, dst = args[0:2]\n    label = kwargs.pop(self.config.edge_label_field, self.config.default_edge_label)\n    return self.add_labeled_edge(src, dst, label, properties=kwargs)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_labeled_edge","title":"<code>add_labeled_edge(srcId, destId, edgeLabel, properties=None, **kwargs)</code>","text":"<p>add a labeled edge</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_labeled_edge(\n    self, srcId: int, destId: int, edgeLabel: str, properties: dict = None, **kwargs\n):\n    \"\"\"\n    add a labeled edge\n    \"\"\"\n    if self.has_node(srcId) and self.has_node(destId):\n        properties = properties or {}\n        properties.update(kwargs)\n        if self.config.edge_label_field in properties:\n            raise MogwaiGraphError(\n                f\"The '{self.config.edge_label_field}' property is reserved for the edge label.\"\n            )\n        elif self.config.label_field in properties:\n            raise MogwaiGraphError(\n                f\"The '{self.config.label_field}' property is reserved for the node labels.\"\n            )\n        edge_props = {self.config.edge_label_field: edgeLabel, **properties}\n        super().add_edge(srcId, destId, **edge_props)\n        # Add a quad specifically for the edge connection\n        edge_quad = Quad(s=srcId, p=edgeLabel, o=destId, g=\"edge-link\")\n        self.spog_index.add_quad(edge_quad)\n\n        # Use add_to_index to add label, name, and properties as quads\n        self.add_to_index(\"edge\", srcId, {edgeLabel}, edgeLabel, properties)\n    else:\n        raise MogwaiGraphError(\n            f\"Node with id {srcId if srcId&lt;0 else destId} is not in the graph.\"\n        )\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_labeled_node","title":"<code>add_labeled_node(label, name, properties=None, node_id=None, **kwargs)</code>","text":"<p>Add a labeled node to the graph.</p> <p>we can only insert a node by hashable value and as names and ids might occur multiple times we use incremented node ids if no node_id is provided</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Union[set, str]</code> <p>The label or set of labels for the node.</p> required <code>name</code> <code>str</code> <p>The name of the node.</p> required <code>properties</code> <code>dict</code> <p>Additional properties for the node. Defaults to None.</p> <code>None</code> <code>node_id</code> <code>Optional[int]</code> <p>The ID for the node. If not provided, a new ID will be generated. Defaults to None.</p> <code>None</code> <code>kwargs</code> <p>further property values</p> <code>{}</code> <p>Returns:     Any: The ID of the newly added node - will be an integer if node_id was kept as default None</p> <p>Raises:</p> Type Description <code>MogwaiGraphError</code> <p>If a node with the provided ID already exists in the graph.</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_labeled_node(\n    self,\n    label: set | str,\n    name: str,\n    properties: dict = None,\n    node_id: Optional[str] = None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"\n    Add a labeled node to the graph.\n\n    we can only insert a node by hashable value and as names and ids\n    might occur multiple times we use incremented node ids if no node_id is provided\n\n    Args:\n        label (Union[set, str]): The label or set of labels for the node.\n        name (str): The name of the node.\n        properties (dict, optional): Additional properties for the node. Defaults to None.\n        node_id (Optional[int], optional): The ID for the node. If not provided, a new ID will be generated. Defaults to None.\n        kwargs (): further property values\n    Returns:\n        Any: The ID of the newly added node - will be an integer if node_id was kept as default None\n\n    Raises:\n        MogwaiGraphError: If a node with the provided ID already exists in the graph.\n    \"\"\"\n    label = (\n        label\n        if isinstance(label, set)\n        else (set(label) if isinstance(label, (list, tuple)) else {label})\n    )\n    if node_id is None:\n        node_id = self.get_next_node_id()\n    properties = properties or {}\n    properties.update(kwargs)\n    if self.config.name_field in properties:\n        raise MogwaiGraphError(\n            f\"The '{self.config.name_field}' property is reserved for the node name.\"\n        )\n    elif self.config.label_field in properties:\n        raise MogwaiGraphError(\n            f\"The '{self.config.label_field}' property is reserved for the node labels.\"\n        )\n    node_props = {\n        self.config.name_field: name,\n        self.config.label_field: label,\n        **properties,\n    }\n    super().add_node(node_id, **node_props)\n    # Use add_to_index to add label, name, and properties as quads\n    self.add_to_index(\"node\", node_id, label, name, properties)\n    return node_id\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_node","title":"<code>add_node(*args, **kwargs)</code>","text":"<p>Add a node with default or explicit labels</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_node(self, *args, **kwargs):\n    \"\"\"Add a node with default or explicit labels\"\"\"\n    if len(args) &gt; 0:\n        node_id = args[0]\n    else:\n        node_id = self.get_next_node_id()\n\n    label = kwargs.pop(\"labels\", {self.config.default_node_label})\n    name = kwargs.pop(\"name\", str(node_id))\n    return self.add_labeled_node(label, name, properties=kwargs, node_id=node_id)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_to_index","title":"<code>add_to_index(element_type, subject_id, label, name, properties)</code>","text":"<p>Add labels, name, and properties to the SPOG index for a given subject and element_type</p> <p>Parameters:</p> Name Type Description Default <code>element_type</code> <code>str</code> <p>(str): node or edge</p> required <code>subject_id</code> <code>Hashable</code> <p>The ID of the subject (node or edge).</p> required <code>label</code> <code>set</code> <p>Set of labels for the subject.</p> required <code>name</code> <code>str</code> <p>Name of the subject.</p> required <code>properties</code> <code>dict</code> <p>Dictionary of additional properties to index.</p> required Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_to_index(\n    self,\n    element_type: str,\n    subject_id: Hashable,\n    label: set,\n    name: str,\n    properties: dict,\n):\n    \"\"\"\n    Add labels, name, and properties to the SPOG index for a\n    given subject and element_type\n\n    Args:\n        element_type: (str): node or edge\n        subject_id (Hashable): The ID of the subject (node or edge).\n        label (set): Set of labels for the subject.\n        name (str): Name of the subject.\n        properties (dict): Dictionary of additional properties to index.\n    \"\"\"\n    # only index if the config calls for it\n    if self.config.index_config == \"off\":\n        return\n    # Add quads for each label with g=\"label\"\n    for lbl in label:\n        label_quad = Quad(s=subject_id, p=\"label\", o=lbl, g=f\"{element_type}-label\")\n        self.spog_index.add_quad(label_quad)\n\n    # Add quad for name with g=\"name\"\n    name_quad = Quad(s=subject_id, p=\"name\", o=name, g=f\"{element_type}-name\")\n    self.spog_index.add_quad(name_quad)\n\n    # Add quads for each property with g=\"property\"\n    for prop_name, prop_value in properties.items():\n        if not isinstance(prop_value, Hashable):\n            prop_value = str(prop_value)  # Ensure property value is hashable\n        property_quad = Quad(\n            s=subject_id, p=prop_name, o=prop_value, g=f\"{element_type}-property\"\n        )\n        self.spog_index.add_quad(property_quad)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.crew","title":"<code>crew()</code>  <code>classmethod</code>","text":"<p>create the TheCrew example graph see TinkerFactory.createTheCrew() in https://tinkerpop.apache.org/docs/current/reference/</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>@classmethod\ndef crew(cls) -&gt; \"MogwaiGraph\":\n    \"\"\"\n    create the TheCrew example graph\n    see TinkerFactory.createTheCrew() in https://tinkerpop.apache.org/docs/current/reference/\n    \"\"\"\n    g = MogwaiGraph()\n\n    def t(startTime: int, endTime: int = None):\n        d = dict()\n        d[\"startTime\"] = startTime\n        if endTime is not None:\n            d[\"endTime\"] = endTime\n        return d\n\n    marko = g.add_labeled_node(\n        \"Person\",\n        name=\"marko\",\n        location={\n            \"san diego\": t(1997, 2001),\n            \"santa cruz\": t(2001, 2004),\n            \"brussels\": t(2004, 2005),\n            \"santa fe\": t(2005),\n        },\n    )\n    stephen = g.add_labeled_node(\n        \"Person\",\n        name=\"stephen\",\n        location={\n            \"centreville\": t(1990, 2000),\n            \"dulles\": t(2000, 2006),\n            \"purcellvilee\": t(2006),\n        },\n    )\n    matthias = g.add_labeled_node(\n        \"Person\",\n        name=\"matthias\",\n        location={\n            \"bremen\": t(2004, 2007),\n            \"baltimore\": t(2007, 2011),\n            \"oakland\": t(2011, 2014),\n            \"seattle\": t(2014),\n        },\n    )\n    daniel = g.add_labeled_node(\n        \"Person\",\n        name=\"daniel\",\n        location={\n            \"spremberg\": t(1982, 2005),\n            \"kaiserslautern\": t(2005, 2009),\n            \"aachen\": t(2009),\n        },\n    )\n    gremlin = g.add_labeled_node(\"Software\", name=\"gremlin\")\n    tinkergraph = g.add_labeled_node(\"Software\", name=\"tinkergraph\")\n\n    g.add_labeled_edge(marko, gremlin, \"uses\", skill=4)\n    g.add_labeled_edge(stephen, gremlin, \"uses\", skill=5)\n    g.add_labeled_edge(matthias, gremlin, \"uses\", skill=3)\n    g.add_labeled_edge(daniel, gremlin, \"uses\", skill=5)\n    g.add_labeled_edge(marko, tinkergraph, \"uses\", skill=5)\n    g.add_labeled_edge(stephen, tinkergraph, \"uses\", skill=4)\n    g.add_labeled_edge(matthias, tinkergraph, \"uses\", skill=3)\n    g.add_labeled_edge(daniel, tinkergraph, \"uses\", skill=3)\n    g.add_labeled_edge(gremlin, tinkergraph, \"traverses\")\n    g.add_labeled_edge(marko, tinkergraph, \"develops\", since=2010)\n    g.add_labeled_edge(stephen, tinkergraph, \"develops\", since=2011)\n    g.add_labeled_edge(marko, gremlin, \"develops\", since=2009)\n    g.add_labeled_edge(stephen, gremlin, \"develops\", since=2010)\n    g.add_labeled_edge(matthias, gremlin, \"develops\", since=2012)\n    return g\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.draw","title":"<code>draw(outputfile, title='MogwaiGraph', **kwargs)</code>","text":"<p>Draw the graph using graphviz Parameters</p> <p>outputfile : str     the file to save the graph to title : str, default 'MogwaiGraph'     the title of the graph kwargs : dict     additional parameters used to configure the drawing style.     For more details see <code>MogwaiGraphDrawer</code></p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def draw(self, outputfile, title: str = \"MogwaiGraph\", **kwargs):\n    \"\"\"\n    Draw the graph using graphviz\n    Parameters\n    ----------\n    outputfile : str\n        the file to save the graph to\n    title : str, default 'MogwaiGraph'\n        the title of the graph\n    kwargs : dict\n        additional parameters used to configure the drawing style.\n        For more details see `MogwaiGraphDrawer`\n    \"\"\"\n    MogwaiGraphDrawer(self, title=title, **kwargs).draw(outputfile)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.get_next_node_id","title":"<code>get_next_node_id()</code>","text":"<p>get the next node_id</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def get_next_node_id(self):\n    \"\"\"\n    get the next node_id\n    \"\"\"\n    node_id = self.counter\n    self.counter += 1\n    return node_id\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.modern","title":"<code>modern(index_config='off')</code>  <code>classmethod</code>","text":"<p>create the modern graph see https://tinkerpop.apache.org/docs/current/tutorials/getting-started/</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>@classmethod\ndef modern(cls, index_config=\"off\") -&gt; \"MogwaiGraph\":\n    \"\"\"\n    create the modern graph\n    see https://tinkerpop.apache.org/docs/current/tutorials/getting-started/\n    \"\"\"\n    config = MogwaiGraphConfig\n    config.index_config = index_config\n    g = MogwaiGraph(config=config)\n    marko = g.add_labeled_node(\"Person\", name=\"marko\", age=29)\n    vadas = g.add_labeled_node(\"Person\", name=\"vadas\", age=27)\n    lop = g.add_labeled_node(\"Software\", name=\"lop\", lang=\"java\")\n    josh = g.add_labeled_node(\"Person\", name=\"josh\", age=32)\n    ripple = g.add_labeled_node(\"Software\", name=\"ripple\", lang=\"java\")\n    peter = g.add_labeled_node(\"Person\", name=\"peter\", age=35)\n\n    g.add_labeled_edge(marko, vadas, \"knows\", weight=0.5)\n    g.add_labeled_edge(marko, josh, \"knows\", weight=1.0)\n    g.add_labeled_edge(marko, lop, \"created\", weight=0.4)\n    g.add_labeled_edge(josh, ripple, \"created\", weight=1.0)\n    g.add_labeled_edge(josh, lop, \"created\", weight=0.4)\n    g.add_labeled_edge(peter, lop, \"created\", weight=0.2)\n    return g\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphConfig","title":"<code>MogwaiGraphConfig</code>  <code>dataclass</code>","text":"<p>configuration of a MogwaiGraph</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>@dataclass\nclass MogwaiGraphConfig:\n    \"\"\"\n    configuration of a MogwaiGraph\n    \"\"\"\n\n    name_field: str = \"name\"\n    label_field: str = \"labels\"\n    edge_label_field: str = \"labels\"\n    default_node_label: str = \"Node\"\n    default_edge_label: str = \"Edge\"\n    index_config: str = \"off\"\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphDrawer","title":"<code>MogwaiGraphDrawer</code>","text":"<p>helper class to draw MogwaiGraphs</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>class MogwaiGraphDrawer:\n    \"\"\"\n    helper class to draw MogwaiGraphs\n    \"\"\"\n\n    def __init__(self, g: MogwaiGraph, title: str, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        g : MogwaiGraph\n            the graph to draw\n        title : str\n            the title of the graph\n        kwargs : dict\n            additional parameters used to configure the drawing style\n            * *fontname* : str, default 'arial'\n                the font to use\n            * *fillcolor* : str, default '#ADE1FE'\n                the fill color of the vertices\n            * *edge_line_width* : int, default 3\n                the width of the edges\n            * *dash_width* : int, default 5\n                number of dashess in the head/properties delimiter\n            * *v_limit* : int, default 10\n                the maximum number of vertices to show\n            * *e_limit* : int, default 10\n                the maximum number of edges to show\n            * *vertex_properties* : list, default None\n                the properties to display for vertices, if `None` all properties are shown\n            * *edge_properties* : list, default None\n                the properties to display for edges, if `None` all properties are shown\n            * *prog* : str, default 'dot'\n                the layout program to use\n        \"\"\"\n        self.g = g\n        self.title = title\n        self.config = kwargs or {}\n        self.vertex_keys = self.config.get(\"vertex_properties\", None)\n        self.edge_keys = self.config.get(\"edge_properties\", None)\n\n        self.v_drawn = set()\n        self.e_drawn = set()\n\n    def _draw_vertex(self, n):\n        if len(self.v_drawn) &gt;= self.config.get(\"v_limit\", 10):\n            return False\n        if n[0] in self.v_drawn:\n            return None\n        id, properties = n\n        head = (\n            f\"{id:d}, {properties.pop('name')}\\n{', '.join(properties.pop('labels'))}\"\n        )\n        if self.vertex_keys:\n            properties = {k: v for k, v in properties.items() if k in self.vertex_keys}\n        body = \"\\n\".join([f\"{k}: {v}\" for k, v in properties.items()])\n        label = f\"{head}\\n\" + (\"-\" * self.config.get(\"dash_width\", 5)) + f\"\\n{body}\"\n\n        self.gviz.add_node(\n            id,\n            label=label,\n            fillcolor=self.config.get(\"fillcolor\", \"#ADE1FE\"),\n            style=\"filled\",\n            fontname=self.config.get(\"fontname\", \"arial\"),\n        )\n        self.v_drawn.add(id)\n        return True\n\n    def _draw_edge(self, e, with_vertices: bool = True):\n        if len(self.e_drawn) &gt; self.config.get(\"e_limit\", 10):\n            return False\n        if e[:-1] in self.e_drawn:\n            return None\n        if with_vertices:\n            self._draw_vertex((e[0], self.g.nodes[e[0]]))\n            self._draw_vertex((e[1], self.g.nodes[e[1]]))\n        head = f\"{e[2].pop('labels')}\"\n        body = \"\\n\".join([f\"{k}: {v}\" for k, v in e[2].items()])\n        label = f\"{head}\\n\" + (\"-\" * self.config.get(\"dash_width\", 5)) + f\"\\n{body}\"\n\n        self.gviz.add_edge(\n            e[0],\n            e[1],\n            label=label,\n            style=f\"setlinewidth({self.config.get('edge_line_width', 3)})\",\n            fontname=self.config.get(\"fontname\", \"arial\"),\n        )\n        self.e_drawn.add(e[:-1])\n\n    def draw(self, outputfile: str):\n        try:\n            import pygraphviz\n        except ImportError:\n            raise ImportError(\"Please install pygraphviz to draw graphs.\")\n\n        self.gviz: pygraphviz.AGraph = networkx.nx_agraph.to_agraph(self.g)\n        for n in self.g.nodes(data=True):\n            if self._draw_vertex(n) == False:\n                break\n        for e in self.g.edges(data=True):\n            if self._draw_edge(e) == False:\n                break\n        self.gviz.layout(prog=self.config.get(\"prog\", \"dot\"))\n        self.gviz.draw(outputfile)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphDrawer.__init__","title":"<code>__init__(g, title, **kwargs)</code>","text":""},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphDrawer.__init__--parameters","title":"Parameters","text":"<p>g : MogwaiGraph     the graph to draw title : str     the title of the graph kwargs : dict     additional parameters used to configure the drawing style     * fontname : str, default 'arial'         the font to use     * fillcolor : str, default '#ADE1FE'         the fill color of the vertices     * edge_line_width : int, default 3         the width of the edges     * dash_width : int, default 5         number of dashess in the head/properties delimiter     * v_limit : int, default 10         the maximum number of vertices to show     * e_limit : int, default 10         the maximum number of edges to show     * vertex_properties : list, default None         the properties to display for vertices, if <code>None</code> all properties are shown     * edge_properties : list, default None         the properties to display for edges, if <code>None</code> all properties are shown     * prog : str, default 'dot'         the layout program to use</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def __init__(self, g: MogwaiGraph, title: str, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    g : MogwaiGraph\n        the graph to draw\n    title : str\n        the title of the graph\n    kwargs : dict\n        additional parameters used to configure the drawing style\n        * *fontname* : str, default 'arial'\n            the font to use\n        * *fillcolor* : str, default '#ADE1FE'\n            the fill color of the vertices\n        * *edge_line_width* : int, default 3\n            the width of the edges\n        * *dash_width* : int, default 5\n            number of dashess in the head/properties delimiter\n        * *v_limit* : int, default 10\n            the maximum number of vertices to show\n        * *e_limit* : int, default 10\n            the maximum number of edges to show\n        * *vertex_properties* : list, default None\n            the properties to display for vertices, if `None` all properties are shown\n        * *edge_properties* : list, default None\n            the properties to display for edges, if `None` all properties are shown\n        * *prog* : str, default 'dot'\n            the layout program to use\n    \"\"\"\n    self.g = g\n    self.title = title\n    self.config = kwargs or {}\n    self.vertex_keys = self.config.get(\"vertex_properties\", None)\n    self.edge_keys = self.config.get(\"edge_properties\", None)\n\n    self.v_drawn = set()\n    self.e_drawn = set()\n</code></pre>"},{"location":"#mogwai.core.steps","title":"<code>steps</code>","text":""},{"location":"#mogwai.core.steps.base_steps","title":"<code>base_steps</code>","text":""},{"location":"#mogwai.core.steps.branch_steps","title":"<code>branch_steps</code>","text":""},{"location":"#mogwai.core.steps.filter_steps","title":"<code>filter_steps</code>","text":""},{"location":"#mogwai.core.steps.filter_steps.HasWithin","title":"<code>HasWithin</code>","text":"<p>               Bases: <code>FilterStep</code></p> <p>Similar to <code>Has</code>, but with multiple options for the value</p> Source code in <code>mogwai/core/steps/filter_steps.py</code> <pre><code>class HasWithin(FilterStep):\n    \"\"\"\n    Similar to `Has`, but with multiple options for the value\n    \"\"\"\n    def __init__(self, traversal:Traversal, key:str|List[str], valueOptions:List|Tuple):\n        super().__init__(traversal)\n        self.key = key\n        self.valueOptions = valueOptions\n        indexer = (lambda t: t.get) if key==\"id\" else get_dict_indexer(key, _NA)\n        self._filter = lambda t: indexer(self.traversal._get_element(t)) in self.valueOptions\n</code></pre>"},{"location":"#mogwai.core.steps.flatmap_steps","title":"<code>flatmap_steps</code>","text":""},{"location":"#mogwai.core.steps.map_steps","title":"<code>map_steps</code>","text":""},{"location":"#mogwai.core.steps.modulation_steps","title":"<code>modulation_steps</code>","text":""},{"location":"#mogwai.core.steps.start_steps","title":"<code>start_steps</code>","text":""},{"location":"#mogwai.core.steps.statics","title":"<code>statics</code>","text":""},{"location":"#mogwai.core.steps.statics.add_camel_case_aliases","title":"<code>add_camel_case_aliases(module_globals)</code>","text":"<p>Add camelCase aliases for all snake_case callables in the module's globals.</p> Source code in <code>mogwai/core/steps/statics.py</code> <pre><code>def add_camel_case_aliases(module_globals):\n    \"\"\"Add camelCase aliases for all snake_case callables in the module's globals.\"\"\"\n    camel_case_aliases = {}\n    for name, obj in module_globals.items():\n        if callable(obj) and '_' in name:  # Only convert callable objects with underscores\n            components = name.split('_')\n            camel_case_name = components[0] + ''.join(x.capitalize() for x in components[1:])\n            if name.endswith('_'):\n                camel_case_name += '_'\n            if camel_case_name != name:\n                camel_case_aliases[camel_case_name] = obj\n    module_globals.update(camel_case_aliases)\n</code></pre>"},{"location":"#mogwai.core.steps.terminal_steps","title":"<code>terminal_steps</code>","text":""},{"location":"#mogwai.core.traversal","title":"<code>traversal</code>","text":""},{"location":"#mogwai.core.traversal.AnonymousTraversal","title":"<code>AnonymousTraversal</code>","text":"<p>               Bases: <code>Traversal</code></p> <p>specialized Traversal</p> Source code in <code>mogwai/core/traversal.py</code> <pre><code>class AnonymousTraversal(Traversal):\n    \"\"\"\n    specialized Traversal\n    \"\"\"\n\n    def __init__(self, start: \"Step\" = None):\n        self.query_steps = [start] if start else []\n        self.graph = None\n        self.terminated = False\n        self._needs_path = False\n\n    # we need this since anonymous traversals need to check this before they're run.\n    @property\n    def needs_path(self):\n        return self._needs_path or any((s.needs_path for s in self.query_steps))\n\n    @needs_path.setter\n    def needs_path(self, value):\n        self._needs_path = value\n\n    def run(self):\n        raise ValueError(\"Cannot run anonymous traversals\")\n\n    def _build(self, traversal: Traversal):\n        # first, set the necessary fields\n        self.graph = traversal.graph\n        self.eager = traversal.eager\n        self.use_mp = traversal.use_mp\n        self.verify_query = traversal.verify_query\n        self.needs_path = any([s.needs_path for s in self.query_steps])\n        self.optimize = traversal.optimize\n        if traversal.optimize:\n            self._optimize_query()\n        if self.verify_query:\n            self._verify_query()\n        if self.query_steps[0].isstart:\n            self.query_steps[0].set_traversal(self)\n        super()._build()\n\n    def __call__(self, traversers: Iterable[\"Traverser\"]) -&gt; Iterable[\"Traverser\"]:\n        # if this traversal is empty, just reflect back the incoming traversers\n        if len(self.query_steps) == 0:\n            return traversers\n        self.traversers = traversers\n        if self.eager:\n            try:\n                for step in self.query_steps:\n                    logger.debug(\"Running step:\" + str(step))\n                    self.traversers = step(self.traversers)\n                    if not type(self.traversers) is list:\n                        self.traversers = list(self.traversers)\n            except Exception as e:\n                raise GraphTraversalError(\n                    f\"Something went wrong in step {step.print_query()}\"\n                )\n        else:\n            for step in self.query_steps:\n                logger.debug(\"Running step:\" + str(step))\n                self.traversers = step(self.traversers)\n            # TODO: Try to do some fancy error handling\n        return self.traversers\n</code></pre>"},{"location":"#mogwai.core.traversal.Traversal","title":"<code>Traversal</code>","text":"<p>see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traversal.html A Traversal represents a directed walk over a Graph. This is the base interface for all traversal's, where each extending interface is seen as a domain specific language. For example, GraphTraversal is a domain specific language for traversing a graph using \"graph concepts\" (e.g. vertices, edges).</p> <p>A Traversal is evaluated in one of two ways: iterator-based OLTP or GraphComputer-based OLAP. OLTP traversals leverage an iterator and are executed within a single execution environment (e.g. JVM) (with data access allowed to be remote).</p> <p>OLAP traversals leverage GraphComputer and are executed between multiple execution environments (e.g.JVMs) (and/or cores).</p> Source code in <code>mogwai/core/traversal.py</code> <pre><code>@add_camel_case_methods\nclass Traversal:\n    \"\"\"\n    see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traversal.html\n    A Traversal represents a directed walk over a Graph.\n    This is the base interface for all traversal's,\n    where each extending interface is seen as a domain\n    specific language. For example, GraphTraversal\n    is a domain specific language for traversing a graph\n    using \"graph concepts\" (e.g. vertices, edges).\n\n    A Traversal is evaluated in one of two ways:\n    iterator-based OLTP or GraphComputer-based OLAP.\n    OLTP traversals leverage an iterator and are executed\n    within a single execution environment (e.g. JVM)\n    (with data access allowed to be remote).\n\n    OLAP traversals leverage GraphComputer and are executed\n    between multiple execution environments (e.g.JVMs) (and/or cores).\n    \"\"\"\n\n    def __init__(\n        self,\n        source: \"MogwaiGraphTraversalSource\",\n        start: \"Step\",\n        optimize: bool = True,\n        eager: bool = False,\n        query_verify: bool = False,\n        use_mp: bool = False,\n    ):\n        if start is None:\n            raise QueryError(\"start step cannot be None\")\n        self.query_steps = [start]\n        if not self.query_steps[0].isstart:\n            raise QueryError(\n                \"The first step should be a start-step, got \" + str(self.query_steps[0])\n            )\n        self.graph = source.connector\n        self.terminated = False\n        self.eager = eager\n        self.use_mp = use_mp\n        self.verify_query = query_verify\n        self.optimize = optimize\n        self.max_iteration_depth = DEFAULT_ITERATION_DEPTH\n\n    def _add_step(self, step: \"Step\"):\n        if self.terminated:\n            raise QueryError(\"Cannot add steps to a terminated traversal.\")\n        self.query_steps.append(step)\n        if step.isterminal:\n            self.terminated = True\n\n    ## ===== FILTER STEPS ======\n    def filter_(self, condition: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.filter_steps import Filter\n\n        self._add_step(Filter(self, condition))\n        return self\n\n    def has(self, *args) -&gt; \"Traversal\":\n        \"\"\"\n        Filter traversers based on whether they have the given properties.\n        * If one argument is given, it is assumed to be a key, and the step checks if a property with that key exists, regardless of its value.\n        * If two arguments are given, it is assumed to be a key and a value, and the step checks if a property with that key exists and has the given value.\n        * If three arguments are given, the first argument is assumed to be a label, and the step checks if a property with the given key and value exists on an element with that label.\n        \"\"\"\n        # if `key` is a list, like ['a', 'b'], the value will be compared to data['a']['b']\n        from .steps.filter_steps import Has\n\n        if len(args) == 1:\n            key, value = args[0], None\n            self._add_step(Has(self, key, value))\n        elif len(args) == 2:\n            key, value = args\n            self._add_step(Has(self, key, value))\n        elif len(args) == 3:\n            label, key, value = args\n            self._add_step(Has(self, key, value, label=label))\n        else:\n            raise QueryError(\"Invalid number of arguments for `has`\")\n        return self\n\n    def has_not(self, key: str):\n        from .steps.filter_steps import HasNot\n\n        self._add_step(HasNot(self, key))\n        return self\n\n    def has_key(self, *keys: str):\n        from .steps.filter_steps import HasKey\n\n        self._add_step(HasKey(self, *keys))\n        return self\n\n    def has_value(self, *values: Any) -&gt; \"Traversal\":\n        from .steps.filter_steps import HasValue\n\n        self._add_step(HasValue(self, *values))\n        return self\n\n    def has_id(self, *ids: int | tuple) -&gt; \"Traversal\":\n        from .steps.filter_steps import HasId\n\n        self._add_step(HasId(self, *ids))\n        return self\n\n    def has_name(self, *name: str) -&gt; \"Traversal\":\n        if len(name) == 0:\n            raise QueryError(\"No name provided for `has_name`\")\n        elif len(name) == 1:\n            return self.has(\"name\", name[0])\n        elif len(name) &gt; 1:\n            from .steps.filter_steps import HasWithin\n\n            self._add_step(HasWithin(self, \"name\", name))\n            return self\n\n    def has_label(self, label: str | Set[str]) -&gt; \"Traversal\":\n        if isinstance(label, set):\n            from .steps.filter_steps import ContainsAll\n\n            self._add_step(ContainsAll(self, \"labels\", label))\n        else:\n            from .steps.filter_steps import Contains\n\n            self._add_step(Contains(self, \"labels\", label))\n        return self\n\n    def is_(self, condition: Any) -&gt; \"Traversal\":\n        from .steps.filter_steps import Is\n\n        self._add_step(Is(self, condition))\n        return self\n\n    def contains(self, key: str | List[str], value: Any) -&gt; \"Traversal\":\n        if isinstance(value, list):\n            from .steps.filter_steps import ContainsAll\n\n            self._add_step(ContainsAll(self, key, value))\n        else:\n            from .steps.filter_steps import Contains\n\n            self._add_step(Contains(self, key, value))\n        return self\n\n    def within(self, key: str | List[str], options: List[Any]) -&gt; \"Traversal\":\n        from .steps.filter_steps import Within\n\n        self._add_step(Within(self, key, options))\n        return self\n\n    def simple_path(self, by: str | List[str] = None) -&gt; \"Traversal\":\n        from .steps.filter_steps import SimplePath\n\n        self._add_step(SimplePath(self, by=by))\n        return self\n\n    def limit(self, n: int) -&gt; \"Traversal\":\n        from .steps.filter_steps import Range\n\n        self._add_step(Range(self, 0, n))\n        return self\n\n    def range(self, start: int, end: int) -&gt; \"Traversal\":\n        from .steps.filter_steps import Range\n\n        self._add_step(Range(self, start, end))\n        return self\n\n    def skip(self, n: int) -&gt; \"Traversal\":\n        from .steps.filter_steps import Range\n\n        self._add_step(Range(self, n, -1))\n        return self\n\n    def dedup(self, by: str | List[str] = None) -&gt; \"Traversal\":\n        from .steps.filter_steps import Dedup\n\n        self._add_step(Dedup(self, by=by))\n        return self\n\n    def not_(self, condition: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.filter_steps import Not\n\n        self._add_step(Not(self, condition))\n        return self\n\n    def and_(self, A: \"AnonymousTraversal\", B: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.filter_steps import And\n\n        self._add_step(And(self, A, B))\n        return self\n\n    def or_(self, A: \"AnonymousTraversal\", B: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.filter_steps import Or\n\n        self._add_step(Or(self, A, B))\n        return self\n\n    ## ===== MAP STEPS ======\n    def identity(self) -&gt; \"Traversal\":  # required for math reasons\n        return self\n\n    # Important: `value` extract values from *Property's*\n    # `values` extracts values from *elements*!\n    # So, .properties(key).value() is the same as .values(key)\n    def value(self) -&gt; \"Traversal\":\n        from .steps.map_steps import Value\n\n        self._add_step(Value(self))\n        return self\n\n    def key(self) -&gt; \"Traversal\":\n        from .steps.map_steps import Key\n\n        self._add_step(Key(self))\n        return self\n\n    def values(self, *keys: str | List[str]) -&gt; \"Traversal\":\n        from .steps.map_steps import Values\n\n        self._add_step(Values(self, *keys))\n        return self\n\n    def name(self) -&gt; \"Traversal\":\n        return self.values(\"name\")\n\n    def label(self) -&gt; \"Traversal\":\n        return self.values(\"labels\")\n\n    def properties(self, *keys: str | List[str]) -&gt; \"Traversal\":\n        from .steps.map_steps import Properties\n\n        self._add_step(Properties(self, *keys))\n        return self\n\n    def select(self, *args: str, by: str = None) -&gt; \"Traversal\":\n        from .steps.map_steps import Select\n\n        self._add_step(\n            Select(self, keys=args[0] if len(args) == 1 else list(args), by=by)\n        )\n        return self\n\n    def order(\n        self,\n        by: str | List[str] | \"AnonymousTraversal\" = None,\n        asc: bool | None = None,\n        **kwargs,\n    ) -&gt; \"Traversal\":\n        from .steps.map_steps import Order\n\n        self._add_step(Order(self, by, asc, **kwargs))\n        return self\n\n    def count(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Count\n\n        self._add_step(Count(self, scope))\n        return self\n\n    def path(self, by: str | List[str] = None) -&gt; \"Traversal\":\n        from .steps.map_steps import Path\n\n        self._add_step(Path(self, by=by))\n        return self\n\n    def max_(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Max\n\n        self._add_step(Max(self, scope))\n        return self\n\n    def min_(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Min\n\n        self._add_step(Min(self, scope))\n        return self\n\n    def sum_(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Aggregate\n\n        self._add_step(Aggregate(self, \"sum\", scope))\n        return self\n\n    def mean(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Aggregate\n\n        self._add_step(Aggregate(self, \"mean\", scope))\n        return self\n\n    def element_map(self, *keys: str) -&gt; \"Traversal\":\n        from .steps.map_steps import ElementMap\n\n        if len(keys) == 1:\n            keys = keys[0]\n        elif len(keys) == 0:\n            keys = None\n        self._add_step(ElementMap(self, keys))\n        return self\n\n    ## ===== FLATMAP STEPS ======\n    def out(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import Out\n\n        self._add_step(Out(self, direction))\n        return self\n\n    def outE(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import OutE\n\n        self._add_step(OutE(self, direction))\n        return self\n\n    def outV(self) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import OutV\n\n        self._add_step(OutV(self))\n        return self\n\n    def in_(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import In\n\n        self._add_step(In(self, direction))\n        return self\n\n    def inE(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import InE\n\n        self._add_step(InE(self, direction))\n        return self\n\n    def inV(self) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import InV\n\n        self._add_step(InV(self))\n        return self\n\n    def both(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import Both\n\n        self._add_step(Both(self, direction))\n        return self\n\n    def bothE(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import BothE\n\n        self._add_step(BothE(self, direction))\n        return self\n\n    def bothV(self) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import BothV\n\n        self._add_step(BothV(self))\n        return self\n\n    ## ===== BRANCH STEPS =====\n    @with_call_order\n    def repeat(\n        self,\n        do: \"Traversal\",\n        times: int | None = None,\n        until: \"AnonymousTraversal|None\" = None,\n        **kwargs,\n    ) -&gt; \"Traversal\":\n        from .steps.branch_steps import Repeat\n        from .steps.modulation_steps import Temp\n\n        if until is not None:\n            until_do = (\n                len(kwargs.get(\"_order\", [])) &gt; 0 and kwargs[\"_order\"][0] == \"until\"\n            )\n        else:\n            until_do = None\n\n        step = Repeat(self, do, times=times, until=until, until_do=until_do)\n        while isinstance((prevstep := self.query_steps[-1]), Temp):\n            if prevstep.kwargs[\"type\"] == \"emit\":\n                step.emit = prevstep.kwargs[\"filter\"]\n                step.emit_before = True\n            elif prevstep.kwargs[\"type\"] == \"until\":\n                if until is not None or times is not None:\n                    raise QueryError(\n                        \"Provided `until` to repeat when `times` or `until` was already set.\"\n                    )\n                step.until = prevstep.kwargs[\"cond\"]\n                step.until_do = True\n            else:\n                break\n            self.query_steps.pop(-1)  # remove the temporary step\n        self._add_step(step)\n        return self\n\n    def local(self, localTrav: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.branch_steps import Local\n\n        self._add_step(Local(self, localTrav))\n        return self\n\n    def branch(self, branchFunc: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.branch_steps import Branch\n        from .steps.map_steps import MapStep\n\n        if len(branchFunc.query_steps) == 0 or not isinstance(\n            branchFunc.query_steps[-1], MapStep\n        ):\n            raise TypeError(\"Branch is only allowed to be given MapSteps\")\n        self._add_step(Branch(self, branchFunc))\n        return self\n\n    def union(self, *traversals: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.branch_steps import Union\n\n        self._add_step(Union(self, *traversals))\n        return self\n\n    ## ===== MODULATION STEPS ======\n    def option(self, branchKey, OptionStep: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.branch_steps import Branch\n\n        branchStep = self.query_steps[len(self.query_steps) - 1]\n        if type(branchStep) is Branch:\n            branchStep.flags |= Step.NEEDS_PATH if OptionStep.needs_path else 0\n            if branchKey is not None:\n                if branchKey not in branchStep.options:\n                    branchStep.options[branchKey] = OptionStep\n                    return self\n                else:\n                    raise QueryError(\n                        \"Duplicate key \" + str(branchKey) + \", please use distinct keys\"\n                    )\n            else:\n                if branchStep.defaultStep is None:\n                    branchStep.defaultStep = OptionStep\n                    return self\n                else:\n                    raise QueryError(\n                        \"Provided two default (None) options. This is not allowed\"\n                    )\n        else:\n            raise QueryError(\"Options can only be used after Branch()\")\n\n    def until(self, cond: \"AnonymousTraversal\"):\n        from .steps.branch_steps import Repeat\n\n        prevstep = self.query_steps[-1]\n        if isinstance(prevstep, Repeat):\n            if prevstep.until is None and prevstep.times is None:\n                prevstep.until = cond\n                prevstep.until_do = False\n                if cond.needs_path:\n                    prevstep.flags |= Repeat.NEEDS_PATH\n            else:\n                raise QueryError(\n                    \"Provided `until` to repeat when `times` or `until` was already set.\"\n                )\n        else:\n            from .steps.modulation_steps import Temp\n\n            self._add_step(Temp(self, type=\"until\", cond=cond))\n        return self\n\n    def times(self, reps: int):\n        from .steps.branch_steps import Repeat\n\n        prevstep = self.query_steps[-1]\n        if isinstance(prevstep, Repeat):\n            if prevstep.times is None and prevstep.until is None:\n                prevstep.times = reps\n            else:\n                raise QueryError(\n                    \"Provided `times` to repeat when `times` or `until` was already set.\"\n                )\n        else:\n            raise QueryError(\n                f\"`times` modulation is not supported by step {prevstep.print_query()}\"\n            )\n        return self\n\n    def emit(self, filter: \"AnonymousTraversal|None\" = None):\n        from .steps.branch_steps import Repeat\n\n        prevstep = self.query_steps[-1]\n        if isinstance(prevstep, Repeat):\n            if prevstep.emit is None:\n                prevstep.emit = filter or True\n                prevstep.emit_before = False\n                if filter and filter.needs_path:\n                    prevstep.flags |= Repeat.NEEDS_PATH\n            else:\n                raise QueryError(\n                    \"Provided `emit` to repeat when `emit` was already set.\"\n                )\n        else:\n            from .steps.modulation_steps import Temp\n\n            self._add_step(Temp(self, type=\"emit\", filter=filter or True))\n        return self\n\n    def as_(self, name: str) -&gt; \"Traversal\":\n        from .steps.modulation_steps import As\n\n        self._add_step(As(self, name))\n        return self\n\n    def by(self, key: str | List[str] | \"AnonymousTraversal\") -&gt; \"Traversal\":\n        prev_step = self.query_steps[-1]\n        if prev_step.supports_by:\n            if isinstance(key, AnonymousTraversal):\n                if not prev_step.supports_anonymous_by:\n                    raise QueryError(\n                        f\"Step `{prev_step.print_query()}` does not support anonymous traversals as by-modulations.\"\n                    )\n            elif type(key) is not str:\n                raise QueryError(\"Invalid key type for by-modulation\")\n\n            if prev_step.supports_multiple_by:\n                prev_step.by.append(key)\n            elif prev_step.by is None:\n                prev_step.by = key\n            else:\n                raise QueryError(\n                    f\"Step `{prev_step.print_query()}` does not support multiple by-modulations.\"\n                )\n        else:\n            raise QueryError(\n                f\"Step `{prev_step.print_query()}` does not support by-modulation.\"\n            )\n        return self\n\n    def from_(self, src: int) -&gt; \"Traversal\":\n        prev_step = self.query_steps[-1]\n        if prev_step.supports_fromto:\n            if type(src) is not int:\n                raise QueryError(\"Invalid source type for from-modulation\")\n            if prev_step.from_ is None:\n                prev_step.from_ = src\n            else:\n                raise QueryError(\n                    f\"Step `{prev_step.print_query()}` does not support multiple from-modulations.\"\n                )\n        else:\n            raise QueryError(\n                f\"Step `{prev_step.print_query()}` does not support from-modulation.\"\n            )\n        return self\n\n    def to_(self, dest: int) -&gt; \"Traversal\":\n        prev_step = self.query_steps[-1]\n        if prev_step.supports_fromto:\n            if type(dest) is not int:\n                raise QueryError(\"Invalid source type for to-modulation\")\n            if prev_step.to_ is None:\n                prev_step.to_ = dest\n            else:\n                raise QueryError(\n                    f\"Step `{prev_step.print_query()}` does not support multiple to-modulations.\"\n                )\n        else:\n            raise QueryError(\n                f\"Step `{prev_step.print_query()}` does not support to-modulation.\"\n            )\n        return self\n\n    ## ===== SIDE EFFECT STEPS ======\n    def side_effect(\n        self, side_effect: \"AnonymousTraversal|Callable[[Traverser], None]\"\n    ) -&gt; \"Traversal\":\n        from .steps.base_steps import SideEffectStep\n\n        self._add_step(SideEffectStep(self, side_effect))\n        return self\n\n    def property(self, key: str | List[str], value: Any) -&gt; \"Traversal\":\n        from mogwai.utils import get_dict_indexer\n\n        from .steps.base_steps import SideEffectStep\n\n        # keys = ['properties'] + (key if type(key) is list else [key])\n        if isinstance(key, (tuple, list)):\n            indexer = get_dict_indexer(key[:-1])\n            key = key[-1]\n        else:\n            indexer = lambda x: x\n\n        def effect(t: \"Traverser\"):\n            indexer(self._get_element(t))[key] = value\n\n        self._add_step(SideEffectStep(self, side_effect=effect))\n        return self\n\n    ## ===== TERMINAL STEPS ======\n    def to_list(\n        self, by: List[str] | str = None, include_data: bool = False\n    ) -&gt; \"Traversal\":\n        # terminal step\n        from .steps.terminal_steps import ToList\n\n        self._add_step(ToList(self, by=by, include_data=include_data))\n        return self\n\n    def as_path(self, by: List[str] | str = None) -&gt; \"Traversal\":\n        # terminal step\n        from .steps.terminal_steps import AsPath\n\n        self._add_step(AsPath(self, by=by))\n        return self\n\n    def has_next(self) -&gt; \"Traversal\":\n        from .steps.terminal_steps import HasNext\n\n        self._add_step(HasNext(self))\n        return self\n\n    def next(self) -&gt; \"Traversal\":\n        from .steps.terminal_steps import Next\n\n        self._add_step(Next(self))\n        return self\n\n    def iter(\n        self, by: str | List[str] = None, include_data: bool = False\n    ) -&gt; \"Traversal\":\n        from .steps.terminal_steps import AsGenerator\n\n        self._add_step(AsGenerator(self, by=by, include_data=include_data))\n        return self\n\n    def iterate(self) -&gt; \"Traversal\":\n        from .steps.terminal_steps import Iterate\n\n        self._add_step(Iterate(self))\n        return self\n\n    def _optimize_query(self):\n        pass\n\n    def _verify_query(self):\n        from .steps.modulation_steps import Temp\n\n        for step in self.query_steps:\n            if isinstance(step, Temp):\n                raise QueryError(f\"Remaining modulation step of type `{step['type']}`\")\n        return True\n\n    def _build(self):\n        for step in self.query_steps:\n            step.build()\n\n    def run(self) -&gt; Any:\n        # first, provide the start step with this traversal\n        self.traversers = []\n        self.query_steps[0].set_traversal(self)\n        self._build()\n        self.needs_path = any([s.needs_path for s in self.query_steps])\n        if self.optimize:\n            self._optimize_query()\n        self._verify_query()\n        if self.eager:\n            try:\n                for step in self.query_steps:\n                    logger.debug(\"Running step:\" + str(step))\n                    self.traversers = step(self.traversers)\n                    if not type(self.traversers) is list:\n                        self.traversers = list(self.traversers)\n            except Exception as e:\n                raise GraphTraversalError(\n                    f\"Something went wrong in step {step.print_query()}\"\n                )\n        else:\n            for step in self.query_steps:\n                logger.debug(\"Running step:\" + str(step))\n                self.traversers = step(self.traversers)\n            # TODO: Try to do some fancy error handling\n        return self.traversers\n\n    def _get_element(self, traverser: \"Traverser\", data: bool = False):\n        if type(traverser) == Traverser:\n            if data:\n                return (\n                    self.graph.edges[traverser.get]\n                    if traverser.is_edge\n                    else self.graph.nodes(data=data)[traverser.get]\n                )\n            return (\n                self.graph.edges[traverser.get]\n                if traverser.is_edge\n                else self.graph.nodes[traverser.get]\n            )\n        else:\n            raise GraphTraversalError(\n                \"Cannot get element from value or property traverser.\"\n                + \" Probably you are performing a step that can only be executed on graph elements on a value or property traverser.\"\n            )\n\n    def _get_element_from_id(self, element_id: int | tuple):\n        return (\n            self.graph.nodes[element_id]\n            if type(element_id) is int\n            else self.graph.edges[element_id]\n        )\n\n    def print_query(self) -&gt; str:\n        return \" -&gt; \".join([x.print_query() for x in self.query_steps])\n\n    def __str__(self) -&gt; str:\n        return self.print_query()\n</code></pre>"},{"location":"#mogwai.core.traversal.Traversal.has","title":"<code>has(*args)</code>","text":"<p>Filter traversers based on whether they have the given properties. * If one argument is given, it is assumed to be a key, and the step checks if a property with that key exists, regardless of its value. * If two arguments are given, it is assumed to be a key and a value, and the step checks if a property with that key exists and has the given value. * If three arguments are given, the first argument is assumed to be a label, and the step checks if a property with the given key and value exists on an element with that label.</p> Source code in <code>mogwai/core/traversal.py</code> <pre><code>def has(self, *args) -&gt; \"Traversal\":\n    \"\"\"\n    Filter traversers based on whether they have the given properties.\n    * If one argument is given, it is assumed to be a key, and the step checks if a property with that key exists, regardless of its value.\n    * If two arguments are given, it is assumed to be a key and a value, and the step checks if a property with that key exists and has the given value.\n    * If three arguments are given, the first argument is assumed to be a label, and the step checks if a property with the given key and value exists on an element with that label.\n    \"\"\"\n    # if `key` is a list, like ['a', 'b'], the value will be compared to data['a']['b']\n    from .steps.filter_steps import Has\n\n    if len(args) == 1:\n        key, value = args[0], None\n        self._add_step(Has(self, key, value))\n    elif len(args) == 2:\n        key, value = args\n        self._add_step(Has(self, key, value))\n    elif len(args) == 3:\n        label, key, value = args\n        self._add_step(Has(self, key, value, label=label))\n    else:\n        raise QueryError(\"Invalid number of arguments for `has`\")\n    return self\n</code></pre>"},{"location":"#mogwai.core.traverser","title":"<code>traverser</code>","text":""},{"location":"#mogwai.core.traverser.Traverser","title":"<code>Traverser</code>","text":"<p>see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traverser.html</p> <p>A Traverser represents the current state of an object flowing through a Traversal.</p> <p>A traverser maintains a reference to the current object, a traverser-local \"sack\", a traversal-global sideEffect, a bulk count, and a path history.</p> <p>Different types of traversers can exist depending on the semantics of the traversal and the desire for space/time optimizations of the developer.</p> Source code in <code>mogwai/core/traverser.py</code> <pre><code>class Traverser:\n    \"\"\"\n    see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traverser.html\n\n    A Traverser represents the current state of an object\n    flowing through a Traversal.\n\n    A traverser maintains a reference to the current object,\n    a traverser-local \"sack\",\n    a traversal-global sideEffect, a bulk count,\n    and a path history.\n\n    Different types of traversers can exist\n    depending on the semantics of the traversal\n    and the desire for space/time optimizations of\n    the developer.\n    \"\"\"\n\n    def __init__(\n        self, node_id: int, other_node_id: int = None, track_path: bool = True\n    ):  # TODO set `track_path` default to False\n        self.node_id = node_id\n        self.track_path = track_path\n        self.target = other_node_id\n        self.cache = {\"__store__\": {}}\n        self.path = [self.get] if track_path else None\n\n    def move_to_edge(self, source: int, target: int) -&gt; None:\n        self.node_id = source\n        self.target = target\n        if self.track_path:\n            self.path.append((source, target))\n\n    @property\n    def get(self) -&gt; int | tuple:\n        return (self.node_id, self.target) if self.is_edge else self.node_id\n\n    @property\n    def source(self) -&gt; int:\n        return self.node_id\n\n    @property\n    def is_edge(self) -&gt; bool:\n        return self.target is not None\n\n    def save(self, key):\n        if self.is_edge:\n            to_store = Traverser(*self.get, track_path=self.track_path)\n        else:\n            to_store = Traverser(self.get, track_path=self.track_path)\n\n        to_store.cache = self.cache.copy()  # no need to deep copies\n        self.cache[\"__store__\"][key] = to_store\n\n    def load(self, key):\n        # logger.debug(f\"Cache: {self.cache['__store__'].keys()}\")\n        try:\n            return self.cache[\"__store__\"][key]\n        except KeyError:\n            raise ValueError(\n                f\"No object `{key}` was saved in this traverser. Use .as('{key}') to save traversal steps.\"\n            )\n\n    def get_cache(self, key):\n        return self.cache.get(key, None)\n\n    def set(self, key: str, val: Any):\n        assert key != \"__store__\", \"`__store__` is a reserved key\"\n        self.cache[key] = val\n\n    def move_to(self, node_id: int) -&gt; \"Traverser\":\n        # logging.debug(\"Moving traverser from\", self.get, \"to\", node_id)\n        self.node_id = node_id\n        self.target = None\n        if self.track_path:\n            self.path.append(node_id)\n        return self\n\n    def copy(self):\n        t = Traverser(\n            node_id=self.node_id, other_node_id=self.target, track_path=self.track_path\n        )\n        t.cache = deepcopy(self.cache)\n        t.path = deepcopy(self.path)\n        return t\n\n    def copy_to(self, node_id: int, other_node_id: int = None) -&gt; \"Traverser\":\n        t = self.copy()\n        if other_node_id:\n            t.move_to_edge(node_id, other_node_id)\n        else:\n            t.move_to(node_id)\n        return t\n\n    def to_value(self, val, dtype=None):\n        val = Value(val, dtype=dtype)\n        val.cache = deepcopy(self.cache)\n        return val\n\n    def to_property(self, key, val, dtype=None):\n        p = Property(key, val, dtype=dtype)\n        p.cache = deepcopy(self.cache)\n        return p\n\n    def __str__(self):\n        return f\"&lt;{self.__class__.__name__}[get={self.get}, is_edge={self.is_edge}]&gt;\"\n</code></pre>"},{"location":"#mogwai.decorators","title":"<code>decorators</code>","text":""},{"location":"#mogwai.decorators.decorators","title":"<code>decorators</code>","text":""},{"location":"#mogwai.graph_config","title":"<code>graph_config</code>","text":"<p>Created on 2024-08-17</p> <p>@author: wf</p>"},{"location":"#mogwai.graph_config.GraphConfig","title":"<code>GraphConfig</code>","text":"<p>Configuration for a graph in the Examples class</p> Source code in <code>mogwai/graph_config.py</code> <pre><code>@lod_storable\nclass GraphConfig:\n    \"\"\"\n    Configuration for a graph in the Examples class\n    \"\"\"\n\n    name: str\n    file_path: Optional[str] = None\n    is_default: bool = False\n    node_label_key: str = \"labelV\"\n    edge_label_key: str = \"labelE\"\n    node_name_key: Optional[str] = None\n    custom_loader: Optional[str] = None  # Changed to str to store function name\n\n    def get_node_name_key(self) -&gt; Callable[[Dict[str, Any]], Any]:\n        if self.node_name_key is None:\n            return lambda x: x  # Return identity function if no key specified\n        elif isinstance(self.node_name_key, str):\n            return lambda x: x.pop(self.node_name_key, None)\n        else:\n            raise ValueError(f\"Invalid node_name_key for graph {self.name}\")\n</code></pre>"},{"location":"#mogwai.graph_config.GraphConfigs","title":"<code>GraphConfigs</code>","text":"<p>Manages a collection of GraphConfig instances</p> Source code in <code>mogwai/graph_config.py</code> <pre><code>@lod_storable\nclass GraphConfigs:\n    \"\"\"Manages a collection of GraphConfig instances\"\"\"\n\n    configs: Dict[str, GraphConfig] = field(default_factory=dict)\n</code></pre>"},{"location":"#mogwai.graphs","title":"<code>graphs</code>","text":"<p>Created on 2024-08-17</p> <p>@author: wf</p>"},{"location":"#mogwai.graphs.Graphs","title":"<code>Graphs</code>","text":"<p>Manage MogwaiGraphs</p> Source code in <code>mogwai/graphs.py</code> <pre><code>class Graphs:\n    \"\"\"\n    Manage MogwaiGraphs\n    \"\"\"\n\n    def __init__(\n        self, config_file: str = None, lazy: bool = False, debug: bool = False\n    ):\n        self.debug = debug\n        self.logger = self.get_logger()\n        self.examples_dir = os.path.join(\n            os.path.dirname(__file__), \"..\", \"mogwai_examples\"\n        )\n        if config_file is None:\n            config_file = os.path.join(self.examples_dir, \"example_graph_configs.yaml\")\n        self.config_file = config_file\n        self.graphs: Dict[str, MogwaiGraph] = {}\n\n        self.log(f\"Loading configurations from: {self.config_file}\")\n        self.configs = GraphConfigs.load_from_yaml_file(self.config_file)\n        self.log(f\"Loaded configurations: {self.configs.configs}\")\n\n        if not lazy:\n            self.load_examples()\n\n    def get_logger(self):\n        return logging.getLogger(self.__class__.__name__)\n\n    def log(self, msg: str):\n        if self.debug:\n            self.logger.debug(msg)\n\n    def load_examples(self):\n        \"\"\"Load all example graphs based on configurations\"\"\"\n        self.log(\"Loading default examples\")\n        for name, config in self.configs.configs.items():\n            if config.is_default:\n                self.log(f\"Loading default graph: {name}\")\n                self.get(name)  # This will load the graph using the existing get method\n\n    def _load_graph(self, file_path: str, config: GraphConfig) -&gt; MogwaiGraph:\n        \"\"\"Load a single graph from a .graphml file using the provided configuration\"\"\"\n        self.log(f\"Loading graph from file: {file_path}\")\n        return graphml_to_mogwaigraph(\n            file_path,\n            node_label_key=config.node_label_key,\n            edge_label_key=config.edge_label_key,\n            node_name_key=config.get_node_name_key(),\n        )\n\n    def get_names(self) -&gt; List[str]:\n        \"\"\"Get a list of available graph names\"\"\"\n        names = list(self.configs.configs.keys())\n        self.log(f\"Available graph names: {names}\")\n        return names\n\n    def get(self, name: str) -&gt; MogwaiGraph:\n        \"\"\"Get a graph by name, loading it if necessary\"\"\"\n        if name not in self.configs.configs:\n            error_msg = f\"Graph '{name}' not found in configurations\"\n            self.log(error_msg)\n            raise ValueError(error_msg)\n\n        if name not in self.graphs:\n            config = self.configs.configs[name]\n            if config.custom_loader:\n                self.log(f\"Using custom loader for graph '{name}'\")\n                # Assuming custom_loader is a string representing a method name in MogwaiGraph\n                loader = getattr(MogwaiGraph, config.custom_loader, None)\n                if loader and callable(loader):\n                    self.graphs[name] = loader()\n                else:\n                    error_msg = f\"Invalid custom loader {config.custom_loader} for graph '{name}'\"\n                    self.log(error_msg)\n                    raise ValueError(error_msg)\n            elif config.file_path:\n                file_path = os.path.join(self.examples_dir, config.file_path)\n                self.log(f\"Loading graph '{name}' from file: {file_path}\")\n                self.graphs[name] = self._load_graph(file_path, config)\n            else:\n                error_msg = f\"No loader or file path specified for graph '{name}'\"\n                self.log(error_msg)\n                raise ValueError(error_msg)\n\n        return self.graphs[name]\n</code></pre>"},{"location":"#mogwai.graphs.Graphs.get","title":"<code>get(name)</code>","text":"<p>Get a graph by name, loading it if necessary</p> Source code in <code>mogwai/graphs.py</code> <pre><code>def get(self, name: str) -&gt; MogwaiGraph:\n    \"\"\"Get a graph by name, loading it if necessary\"\"\"\n    if name not in self.configs.configs:\n        error_msg = f\"Graph '{name}' not found in configurations\"\n        self.log(error_msg)\n        raise ValueError(error_msg)\n\n    if name not in self.graphs:\n        config = self.configs.configs[name]\n        if config.custom_loader:\n            self.log(f\"Using custom loader for graph '{name}'\")\n            # Assuming custom_loader is a string representing a method name in MogwaiGraph\n            loader = getattr(MogwaiGraph, config.custom_loader, None)\n            if loader and callable(loader):\n                self.graphs[name] = loader()\n            else:\n                error_msg = f\"Invalid custom loader {config.custom_loader} for graph '{name}'\"\n                self.log(error_msg)\n                raise ValueError(error_msg)\n        elif config.file_path:\n            file_path = os.path.join(self.examples_dir, config.file_path)\n            self.log(f\"Loading graph '{name}' from file: {file_path}\")\n            self.graphs[name] = self._load_graph(file_path, config)\n        else:\n            error_msg = f\"No loader or file path specified for graph '{name}'\"\n            self.log(error_msg)\n            raise ValueError(error_msg)\n\n    return self.graphs[name]\n</code></pre>"},{"location":"#mogwai.graphs.Graphs.get_names","title":"<code>get_names()</code>","text":"<p>Get a list of available graph names</p> Source code in <code>mogwai/graphs.py</code> <pre><code>def get_names(self) -&gt; List[str]:\n    \"\"\"Get a list of available graph names\"\"\"\n    names = list(self.configs.configs.keys())\n    self.log(f\"Available graph names: {names}\")\n    return names\n</code></pre>"},{"location":"#mogwai.graphs.Graphs.load_examples","title":"<code>load_examples()</code>","text":"<p>Load all example graphs based on configurations</p> Source code in <code>mogwai/graphs.py</code> <pre><code>def load_examples(self):\n    \"\"\"Load all example graphs based on configurations\"\"\"\n    self.log(\"Loading default examples\")\n    for name, config in self.configs.configs.items():\n        if config.is_default:\n            self.log(f\"Loading default graph: {name}\")\n            self.get(name)  # This will load the graph using the existing get method\n</code></pre>"},{"location":"#mogwai.mogwai_cmd","title":"<code>mogwai_cmd</code>","text":"<p>Created on 2024-08-15</p> <p>@author: wf</p>"},{"location":"#mogwai.mogwai_cmd.MogwaiCmd","title":"<code>MogwaiCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>command line handling for nicesprinkler</p> Source code in <code>mogwai/mogwai_cmd.py</code> <pre><code>class MogwaiCmd(WebserverCmd):\n    \"\"\"\n    command line handling for nicesprinkler\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        config = MogwaiWebServer.get_config()\n        WebserverCmd.__init__(self, config, MogwaiWebServer, DEBUG)\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n\n        return parser\n</code></pre>"},{"location":"#mogwai.mogwai_cmd.MogwaiCmd.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>mogwai/mogwai_cmd.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    config = MogwaiWebServer.get_config()\n    WebserverCmd.__init__(self, config, MogwaiWebServer, DEBUG)\n</code></pre>"},{"location":"#mogwai.mogwai_cmd.MogwaiCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>mogwai/mogwai_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n\n    return parser\n</code></pre>"},{"location":"#mogwai.mogwai_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>mogwai/mogwai_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = MogwaiCmd()\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#mogwai.parser","title":"<code>parser</code>","text":""},{"location":"#mogwai.parser.excel_converter","title":"<code>excel_converter</code>","text":""},{"location":"#mogwai.parser.filesystem","title":"<code>filesystem</code>","text":""},{"location":"#mogwai.parser.graphml_converter","title":"<code>graphml_converter</code>","text":""},{"location":"#mogwai.parser.graphml_converter.graphml_to_mogwaigraph","title":"<code>graphml_to_mogwaigraph(file, node_label_key, node_name_key, edge_label_key=None, default_node_label='Na', default_edge_label='Na', default_node_name='Na', include_id=False, keep=True)</code>","text":"<p>Converts GraphML file to MogwaiGraph object.</p>"},{"location":"#mogwai.parser.graphml_converter.graphml_to_mogwaigraph--parameters","title":"Parameters","text":"<p>file : str     Path to the GraphML file. node_label_key : str or Callable[[dict],str]     Key to use for the node label. If a string, the value of the key is used as the label.     If a function, it should take a dictionary of node data and return a string. node_name_key : str or Callable[[dict],str]     Key to use for the node name. If a string, the value of the key is used as the name.     If a function, it should take a dictionary of node data and return a string. edge_label_key : str or Callable[[dict],str], optional     Key to use for the edge label. If a string, the value of the key is used as the label.     If a function, it should take a dictionary of edge data and return a string.     If None, the node_label_key is used. default_node_label : str, optional     Default label to use for nodes that do not have a property corresponding to <code>node_label_key</code>. default_edge_label : str, optional     Default label to use for edges that do not have a property corresponding to <code>edge_label_key</code>. default_node_name : str, optional     Default name to use for nodes that do not have a property corresponding to <code>node_name_key</code>. include_id : bool or str, optional     If True, the node id is included in the data dictionary of each node.     If a string, the node id is included in the data dictionary with the given key. keep : bool, optional     If True, the labels and names are kept as properties in the node data dictionary. If False, they are removed.</p>"},{"location":"#mogwai.parser.graphml_converter.graphml_to_mogwaigraph--returns","title":"Returns","text":"<p>MogwaiGraph     The graph object</p> Source code in <code>mogwai/parser/graphml_converter.py</code> <pre><code>def graphml_to_mogwaigraph(file:str, node_label_key:str|Callable[[dict],str], node_name_key:str|Callable[[dict],str],\n                           edge_label_key:str|Callable[[dict],str]=None,\n                           default_node_label:str='Na', default_edge_label:str='Na', default_node_name:str='Na',\n                           include_id:bool|str=False, keep:bool=True)-&gt;MogwaiGraph:\n    \"\"\"\n    Converts GraphML file to MogwaiGraph object.\n\n    Parameters\n    ----------\n    file : str\n        Path to the GraphML file.\n    node_label_key : str or Callable[[dict],str]\n        Key to use for the node label. If a string, the value of the key is used as the label.\n        If a function, it should take a dictionary of node data and return a string.\n    node_name_key : str or Callable[[dict],str]\n        Key to use for the node name. If a string, the value of the key is used as the name.\n        If a function, it should take a dictionary of node data and return a string.\n    edge_label_key : str or Callable[[dict],str], optional\n        Key to use for the edge label. If a string, the value of the key is used as the label.\n        If a function, it should take a dictionary of edge data and return a string.\n        If None, the node_label_key is used.\n    default_node_label : str, optional\n        Default label to use for nodes that do not have a property corresponding to `node_label_key`.\n    default_edge_label : str, optional\n        Default label to use for edges that do not have a property corresponding to `edge_label_key`.\n    default_node_name : str, optional\n        Default name to use for nodes that do not have a property corresponding to `node_name_key`.\n    include_id : bool or str, optional\n        If True, the node id is included in the data dictionary of each node.\n        If a string, the node id is included in the data dictionary with the given key.\n    keep : bool, optional\n        If True, the labels and names are kept as properties in the node data dictionary. If False, they are removed.\n\n    Returns\n    -------\n    MogwaiGraph\n        The graph object\n    \"\"\"\n    gml = nx.read_graphml(file)\n    if not gml.is_directed():\n        raise MogwaiGraphError(\"Can not import undirected graphml graph\")\n    g = MogwaiGraph()\n    edge_label_key = edge_label_key or node_label_key\n    if(include_id==True): include_id='id' #use 'id' as the default key\n    #Note: these function change the node data!\n    # However, this is not a problem, since `gml` is discarded anyway.\n    missing_label_count = count()\n    if type(node_label_key) is str:\n        def node_label_func(data:dict):\n            if node_label_key in data: return data[node_label_key] if keep else data.pop(node_label_key)\n            else:\n                next(missing_label_count)\n                return default_node_label\n    else:\n        node_label_func = node_label_key\n    missing_name_count = count()\n    if type(node_name_key) is str:\n        def node_name_func(data:dict):\n            if node_name_key in data: return data[node_name_key] if keep else data.pop(node_name_key)\n            else:\n                next(missing_name_count)\n                return default_node_name\n    else:\n        node_name_func = node_name_key\n\n    missing_edge_count = count()\n    if type(edge_label_key) is str:\n        def edge_label_func(data:dict):\n            if edge_label_key in data: return data[edge_label_key] if keep else data.pop(edge_label_key)\n            else:\n                next(missing_edge_count)\n                return default_edge_label\n    else:\n        edge_label_func = edge_label_key\n\n    node_to_id_map = {}\n    for node, data in gml.nodes(data=True):\n        if(include_id):\n            data[include_id] = node\n        assigned_id = g.add_labeled_node(label=node_label_func(data), name=node_name_func(data), **data)\n        node_to_id_map[node] = assigned_id\n    for node1, node2, data in gml.edges(data=True):\n        g.add_labeled_edge(srcId=node_to_id_map[node1] , destId=node_to_id_map[node2], edgeLabel=edge_label_func(data), **data)\n\n    missing_edge_count = next(missing_edge_count)\n    missing_name_count = next(missing_name_count)\n    missing_label_count = next(missing_label_count)\n    if(missing_edge_count&gt;0): logger.warning(f\"Encountered {missing_edge_count} edges without label\")\n    if(missing_name_count&gt;0): logger.warning(f\"Encountered {missing_name_count} nodes without name\")\n    if(missing_label_count&gt;0): logger.warning(f\"Encountered {missing_label_count} nodes without label\")\n    return g\n</code></pre>"},{"location":"#mogwai.parser.pdfgraph","title":"<code>pdfgraph</code>","text":""},{"location":"#mogwai.parser.powerpoint_converter","title":"<code>powerpoint_converter</code>","text":""},{"location":"#mogwai.version","title":"<code>version</code>","text":"<p>Created on 2024-08-15</p> <p>@author: wf</p>"},{"location":"#mogwai.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyMogwai</p> Source code in <code>mogwai/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for pyMogwai\n    \"\"\"\n\n    name = \"pymogwai\"\n    version = mogwai.__version__\n    date = \"2024-08-15\"\n    updated = \"2024-11-10\"\n    description = \"python native gremlin implementation\"\n\n    authors = \"Wolfgang Fahl\"\n\n    chat_url = \"https://github.com/juupje/pyMogwai/discussions\"\n    doc_url = \"https://cr.bitplan.com/index.php/pyMogwai\"\n    cm_url = \"https://github.com/juupje/pyMogwai\"\n\n    license = f\"\"\"Copyright 2024 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#mogwai.web","title":"<code>web</code>","text":""},{"location":"#mogwai.web.server","title":"<code>server</code>","text":"<p>Created on 2024-08-15</p> <p>@author: wf</p>"},{"location":"#mogwai.web.server.MogwaiSolution","title":"<code>MogwaiSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>the Mogwai solution</p> Source code in <code>mogwai/web/server.py</code> <pre><code>class MogwaiSolution(InputWebSolution):\n    \"\"\"\n    the Mogwai solution\n    \"\"\"\n\n    def __init__(self, webserver: MogwaiWebServer, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Args:\n            webserver (MogwaiWebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)\n        self.examples=webserver.examples\n        self.graph=None\n        self.graph_label=None\n        self.result_html=None\n        self.update_graph(\"modern\")\n\n    def authenticated(self) -&gt; bool:\n        \"\"\"\n        Check if the user is authenticated.\n        Returns:\n            True if the user is authenticated, False otherwise.\n        \"\"\"\n        return self.webserver.login.authenticated()\n\n    def setup_menu(self, detailed: bool = True):\n        \"\"\"\n        setup the menu\n        \"\"\"\n        super().setup_menu(detailed=detailed)\n        ui.button(icon=\"menu\", on_click=lambda: self.header.toggle())\n        with self.header:\n            if self.authenticated():\n                self.link_button(\"logout\", \"/logout\", \"logout\", new_tab=False)\n            else:\n                self.link_button(\"login\", \"/login\", \"login\", new_tab=False)\n\n    async def login_ui(self):\n        \"\"\"\n        login ui\n        \"\"\"\n        await self.webserver.login.login(self)\n\n    async def home(self):\n        \"\"\"Provide the main content page\"\"\"\n        await self.query_graph()\n\n    async def on_graph_select(self,vce_args):\n        await run.io_bound(self.update_graph,vce_args.value)\n\n    def update_graph(self,graph_name:str):\n        try:\n            self.graph_name=graph_name\n            self.graph = self.load_graph(name=graph_name)\n            self.get_graph_label()\n            if self.graph_label:\n                self.graph_label.update()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    def get_graph_label(self)-&gt;str:\n        self.graph_label_text=f\"Query Graph {self.graph.name} {len(self.graph.nodes)} nodes {len(self.graph.edges)} edges\"\n        return self.graph_label_text\n\n    async def query_graph(self):\n        \"\"\"Graph querying page\"\"\"\n        def setup_query():\n            emphasize=\"text-h5\"\n            try:\n                with ui.row() as self.header_row:\n                    graph_selection=self.examples.get_names()\n                    self.graph_selector=self.add_select(\n                        \"graph\",\n                        graph_selection,\n                        value=self.graph_name,\n                        on_change=self.on_graph_select)\n                if self.authenticated():\n                    with ui.row() as self.upload_row:\n                        ui.label(\"import File\").classes(emphasize)\n                        file_upload = ui.upload(label=\"Choose a file\", multiple=False, auto_upload=True)\n                        file_upload.on('upload', self.handle_upload)\n\n                if self.graph:\n                    self.get_graph_label()\n                    self.graph_label=ui.label().classes(emphasize)\n                    self.graph_label.bind_text_from(self, 'graph_label_text')\n                    self.query_text_area = (\n                        ui.textarea(\"Enter Gremlin Query\")\n                        .props(\"clearable\")\n                        .props(\"rows=5;cols=80\")\n                        .bind_value_to(self, \"query\")\n                    )\n                    ui.button(\"Run Query\", on_click=lambda: self.on_run_query())\n                else:\n                    ui.label(\"No graph loaded. Please select a graph first.\")\n                with ui.row() as self.result_row:\n                    self.result_html=ui.html()\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        await self.setup_content_div(setup_query)\n\n    def load_graph(self,file=None,name:str=\"modern\"):\n        if file is None:\n            if name in self.examples.get_names():\n                graph=self.examples.get(name)\n            else:\n                raise ValueError(f\"invalid graph name {name}\")\n            graph.name=name\n        else:\n            if file.name.endswith('.graphml'):\n                temp_path = os.path.join(tempfile.gettempdir(), file.name)\n                with open(temp_path, 'wb') as f:\n                    f.write(file.read())\n                graph = graphml_to_mogwaigraph(file=temp_path)\n            elif file.name.endswith('.xlsx'):\n                graph = EXCELGraph(file)\n            elif file.name.endswith('.pdf'):\n                graph = PDFGraph(file)\n            elif file.name.endswith('.pptx'):\n                graph = powerpoint_converter.PPGraph(file=file)\n            else:\n                raise ValueError(f\"invalid file {file.name}\")\n            graph.name=file.name\n        return graph\n\n    def handle_upload(self, e):\n        \"\"\"Handle file upload\"\"\"\n        file = e.content\n        try:\n            self.graph=self.load_graph(file)\n        except Exception as ex:\n            ui.notify(f\"Unsupported file: {file.name} {str(ex)}\", type=\"negative\")\n            return\n\n        if self.graph:\n            ui.notify(\"File parsed successfully\", type=\"positive\")\n\n    def on_run_query(self, query:str=None):\n        \"\"\"Run a Gremlin query on the graph\"\"\"\n        if not self.graph:\n            ui.notify(\"No graph loaded. Please select a graph first.\", type=\"warning\")\n            return\n        try:\n            if query is None:\n                query=self.query\n            query_result=self.run_query(query)\n            self.display_result(query_result)\n        except Exception as e:\n            ui.notify(f\"Error executing query: {str(e)}\", type=\"negative\")\n\n    def run_query(self,query)-&gt;QueryResult:\n        g = Trav.MogwaiGraphTraversalSource(self.graph)\n        traversal = eval(query, {'g': g})\n        if not traversal.terminated:\n            traversal=traversal.to_list()\n        result = traversal.run()\n        qr=QueryResult(traversal=traversal,result=result)\n        return qr\n\n    def display_result(self,query_result:QueryResult):\n        if self.result_html:\n            with self.result_row:\n                count=len(query_result.result)\n                plural_postfix=\"s\" if count&gt;1 else \"\"\n                markup=f\"{count} element{plural_postfix}:&lt;br&gt;\"\n                for i,traverser in enumerate(query_result.result):\n                    markup+=f\"{i+1}:{str(traverser)}&lt;br&gt;\"\n                self.result_html.content=markup\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Parameters:</p> Name Type Description Default <code>webserver</code> <code>MogwaiWebServer</code> <p>The webserver instance associated with this context.</p> required <code>client</code> <code>Client</code> <p>The client instance this context is associated with.</p> required Source code in <code>mogwai/web/server.py</code> <pre><code>def __init__(self, webserver: MogwaiWebServer, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Args:\n        webserver (MogwaiWebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)\n    self.examples=webserver.examples\n    self.graph=None\n    self.graph_label=None\n    self.result_html=None\n    self.update_graph(\"modern\")\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.authenticated","title":"<code>authenticated()</code>","text":"<p>Check if the user is authenticated. Returns:     True if the user is authenticated, False otherwise.</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def authenticated(self) -&gt; bool:\n    \"\"\"\n    Check if the user is authenticated.\n    Returns:\n        True if the user is authenticated, False otherwise.\n    \"\"\"\n    return self.webserver.login.authenticated()\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.handle_upload","title":"<code>handle_upload(e)</code>","text":"<p>Handle file upload</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def handle_upload(self, e):\n    \"\"\"Handle file upload\"\"\"\n    file = e.content\n    try:\n        self.graph=self.load_graph(file)\n    except Exception as ex:\n        ui.notify(f\"Unsupported file: {file.name} {str(ex)}\", type=\"negative\")\n        return\n\n    if self.graph:\n        ui.notify(\"File parsed successfully\", type=\"positive\")\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>Provide the main content page</p> Source code in <code>mogwai/web/server.py</code> <pre><code>async def home(self):\n    \"\"\"Provide the main content page\"\"\"\n    await self.query_graph()\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.login_ui","title":"<code>login_ui()</code>  <code>async</code>","text":"<p>login ui</p> Source code in <code>mogwai/web/server.py</code> <pre><code>async def login_ui(self):\n    \"\"\"\n    login ui\n    \"\"\"\n    await self.webserver.login.login(self)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.on_run_query","title":"<code>on_run_query(query=None)</code>","text":"<p>Run a Gremlin query on the graph</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def on_run_query(self, query:str=None):\n    \"\"\"Run a Gremlin query on the graph\"\"\"\n    if not self.graph:\n        ui.notify(\"No graph loaded. Please select a graph first.\", type=\"warning\")\n        return\n    try:\n        if query is None:\n            query=self.query\n        query_result=self.run_query(query)\n        self.display_result(query_result)\n    except Exception as e:\n        ui.notify(f\"Error executing query: {str(e)}\", type=\"negative\")\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.query_graph","title":"<code>query_graph()</code>  <code>async</code>","text":"<p>Graph querying page</p> Source code in <code>mogwai/web/server.py</code> <pre><code>async def query_graph(self):\n    \"\"\"Graph querying page\"\"\"\n    def setup_query():\n        emphasize=\"text-h5\"\n        try:\n            with ui.row() as self.header_row:\n                graph_selection=self.examples.get_names()\n                self.graph_selector=self.add_select(\n                    \"graph\",\n                    graph_selection,\n                    value=self.graph_name,\n                    on_change=self.on_graph_select)\n            if self.authenticated():\n                with ui.row() as self.upload_row:\n                    ui.label(\"import File\").classes(emphasize)\n                    file_upload = ui.upload(label=\"Choose a file\", multiple=False, auto_upload=True)\n                    file_upload.on('upload', self.handle_upload)\n\n            if self.graph:\n                self.get_graph_label()\n                self.graph_label=ui.label().classes(emphasize)\n                self.graph_label.bind_text_from(self, 'graph_label_text')\n                self.query_text_area = (\n                    ui.textarea(\"Enter Gremlin Query\")\n                    .props(\"clearable\")\n                    .props(\"rows=5;cols=80\")\n                    .bind_value_to(self, \"query\")\n                )\n                ui.button(\"Run Query\", on_click=lambda: self.on_run_query())\n            else:\n                ui.label(\"No graph loaded. Please select a graph first.\")\n            with ui.row() as self.result_row:\n                self.result_html=ui.html()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    await self.setup_content_div(setup_query)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.setup_menu","title":"<code>setup_menu(detailed=True)</code>","text":"<p>setup the menu</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def setup_menu(self, detailed: bool = True):\n    \"\"\"\n    setup the menu\n    \"\"\"\n    super().setup_menu(detailed=detailed)\n    ui.button(icon=\"menu\", on_click=lambda: self.header.toggle())\n    with self.header:\n        if self.authenticated():\n            self.link_button(\"logout\", \"/logout\", \"logout\", new_tab=False)\n        else:\n            self.link_button(\"login\", \"/login\", \"login\", new_tab=False)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiWebServer","title":"<code>MogwaiWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>Mogwai WebServer</p> Source code in <code>mogwai/web/server.py</code> <pre><code>class MogwaiWebServer(InputWebserver):\n    \"\"\"\n    Mogwai WebServer\n    \"\"\"\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        copy_right = \"(c)2024 Wolfgang Fahl\"\n        config = WebserverConfig(\n            copy_right=copy_right,\n            version=Version(),\n            default_port=9850,\n            short_name=\"mogwai\",\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = MogwaiSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        InputWebserver.__init__(self, config=MogwaiWebServer.get_config())\n        users = Users(\"~/.solutions/mogwai\")\n        self.login = Login(self, users)\n        self.examples=Graphs()\n\n        @ui.page(\"/\")\n        async def home(client: Client):\n            return await self.page(client, MogwaiSolution.home)\n\n        @ui.page(\"/query\")\n        async def query_graph(client: Client):\n            return await self.page(client, MogwaiSolution.query_graph)\n\n        @ui.page(\"/login\")\n        async def login(client: Client):\n            return await self.page(client, MogwaiSolution.login_ui)\n\n        @ui.page(\"/logout\")\n        async def logout(client: Client) -&gt; RedirectResponse:\n            if self.login.authenticated():\n                await self.login.logout()\n            return RedirectResponse(\"/\")\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiWebServer.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    InputWebserver.__init__(self, config=MogwaiWebServer.get_config())\n    users = Users(\"~/.solutions/mogwai\")\n    self.login = Login(self, users)\n    self.examples=Graphs()\n\n    @ui.page(\"/\")\n    async def home(client: Client):\n        return await self.page(client, MogwaiSolution.home)\n\n    @ui.page(\"/query\")\n    async def query_graph(client: Client):\n        return await self.page(client, MogwaiSolution.query_graph)\n\n    @ui.page(\"/login\")\n    async def login(client: Client):\n        return await self.page(client, MogwaiSolution.login_ui)\n\n    @ui.page(\"/logout\")\n    async def logout(client: Client) -&gt; RedirectResponse:\n        if self.login.authenticated():\n            await self.login.logout()\n        return RedirectResponse(\"/\")\n</code></pre>"}]}