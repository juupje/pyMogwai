{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyMogwai API Documentation","text":""},{"location":"#mogwai.core","title":"<code>core</code>","text":""},{"location":"#mogwai.core.hd_index","title":"<code>hd_index</code>","text":"<p>Created on 2024-11-07</p> <p>@author: wf</p> <p>base on A. Harth and S. Decker, \"Optimized index structures for querying RDF from the Web,\" Third Latin American Web Congress (LA-WEB'2005), Buenos Aires, Argentina, 2005, pp. 10 pp.-, doi: 10.1109/LAWEB.2005.25. keywords: {Resource description framework;Data models;Semantic Web;Indexes;Java;Vocabulary;Database systems;Memory;Indexing;Information retrieval},</p>"},{"location":"#mogwai.core.hd_index.Index","title":"<code>Index</code>","text":"<p>A Single index in the SPOG matrix as explained in identified by from/to positions</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>class Index:\n    \"\"\"A Single index in the SPOG matrix as explained in\n    identified by from/to positions\"\"\"\n\n    def __init__(self, from_pos: str, to_pos: str):\n        \"\"\"\n        Args:\n            from_pos: First position (S,P,O,G)\n            to_pos: Second position (S,P,O,G)\n        \"\"\"\n        self.from_pos = from_pos\n        self.to_pos = to_pos\n        self.lookup = {}\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Full quad index name based on Harth/Decker SPOG ordering\"\"\"\n        index_name = f\"{self.from_pos}{self.to_pos}\"\n        return index_name\n\n    def add_quad(self, quad: Quad) -&gt; None:\n        \"\"\"Add a quad to this index's lookup using quad positions\"\"\"\n        from_val = getattr(quad, self.from_pos.lower())\n        to_val = getattr(quad, self.to_pos.lower())\n        if not isinstance(from_val, Hashable):\n            pass\n\n        if from_val not in self.lookup:\n            self.lookup[from_val] = set()\n        self.lookup[from_val].add(to_val)\n</code></pre>"},{"location":"#mogwai.core.hd_index.Index.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Full quad index name based on Harth/Decker SPOG ordering</p>"},{"location":"#mogwai.core.hd_index.Index.__init__","title":"<code>__init__(from_pos, to_pos)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>str</code> <p>First position (S,P,O,G)</p> required <code>to_pos</code> <code>str</code> <p>Second position (S,P,O,G)</p> required Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def __init__(self, from_pos: str, to_pos: str):\n    \"\"\"\n    Args:\n        from_pos: First position (S,P,O,G)\n        to_pos: Second position (S,P,O,G)\n    \"\"\"\n    self.from_pos = from_pos\n    self.to_pos = to_pos\n    self.lookup = {}\n</code></pre>"},{"location":"#mogwai.core.hd_index.Index.add_quad","title":"<code>add_quad(quad)</code>","text":"<p>Add a quad to this index's lookup using quad positions</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def add_quad(self, quad: Quad) -&gt; None:\n    \"\"\"Add a quad to this index's lookup using quad positions\"\"\"\n    from_val = getattr(quad, self.from_pos.lower())\n    to_val = getattr(quad, self.to_pos.lower())\n    if not isinstance(from_val, Hashable):\n        pass\n\n    if from_val not in self.lookup:\n        self.lookup[from_val] = set()\n    self.lookup[from_val].add(to_val)\n</code></pre>"},{"location":"#mogwai.core.hd_index.IndexConfig","title":"<code>IndexConfig</code>  <code>dataclass</code>","text":"<p>Configuration of which SPOG indices to use</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>@dataclass\nclass IndexConfig:\n    \"\"\"Configuration of which SPOG indices to use\"\"\"\n\n    active_indices: Set[str]\n</code></pre>"},{"location":"#mogwai.core.hd_index.IndexConfigs","title":"<code>IndexConfigs</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Standard index configurations</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>class IndexConfigs(Enum):\n    \"\"\"Standard index configurations\"\"\"\n\n    OFF = \"off\"  # Use no indices\n    ALL = \"all\"  # Use all 16 indices\n    MINIMAL = \"minimal\"  # Use minimal required set\n\n    def get_config(self) -&gt; IndexConfig:\n        \"\"\"Get the index configuration for this enum value\"\"\"\n        if self == IndexConfigs.OFF:\n            return IndexConfig(set())\n\n        if self == IndexConfigs.ALL:\n            positions = [\"S\", \"P\", \"O\", \"G\"]\n            indices = {\n                f\"{from_pos}{to_pos}\"\n                for from_pos in positions\n                for to_pos in positions\n                if from_pos != to_pos\n            }\n            return IndexConfig(indices)\n\n        if self == IndexConfigs.MINIMAL:\n            return IndexConfig(\n                {\n                    # Core indices for basic node relationships\n                    \"PS\",  # Predicate -&gt; Subject: links predicates to subjects (e.g., labels or properties to nodes)\n                    \"PO\",  # Predicate -&gt; Object: maps predicates to values (e.g., property values)\n                    \"SO\",  # Subject -&gt; Object: links source nodes to target nodes in relationships\n                    \"OS\",  # Object -&gt; Subject: reverse lookup for values back to nodes\n                    # Graph-based indices for context-specific associations\n                    \"PG\",  # Predicate -&gt; Graph: associates predicates with graph contexts\n                    \"SG\",  # Subject -&gt; Graph: associates subjects with graph contexts\n                    \"GO\",  # Graph -&gt; Object: maps graph contexts to objects for grouped retrieval\n                    \"GP\",  # Graph -&gt; Predicate: links graph contexts to predicates\n                }\n            )\n\n        raise ValueError(f\"Unknown index configuration: {self}\")\n</code></pre>"},{"location":"#mogwai.core.hd_index.IndexConfigs.get_config","title":"<code>get_config()</code>","text":"<p>Get the index configuration for this enum value</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def get_config(self) -&gt; IndexConfig:\n    \"\"\"Get the index configuration for this enum value\"\"\"\n    if self == IndexConfigs.OFF:\n        return IndexConfig(set())\n\n    if self == IndexConfigs.ALL:\n        positions = [\"S\", \"P\", \"O\", \"G\"]\n        indices = {\n            f\"{from_pos}{to_pos}\"\n            for from_pos in positions\n            for to_pos in positions\n            if from_pos != to_pos\n        }\n        return IndexConfig(indices)\n\n    if self == IndexConfigs.MINIMAL:\n        return IndexConfig(\n            {\n                # Core indices for basic node relationships\n                \"PS\",  # Predicate -&gt; Subject: links predicates to subjects (e.g., labels or properties to nodes)\n                \"PO\",  # Predicate -&gt; Object: maps predicates to values (e.g., property values)\n                \"SO\",  # Subject -&gt; Object: links source nodes to target nodes in relationships\n                \"OS\",  # Object -&gt; Subject: reverse lookup for values back to nodes\n                # Graph-based indices for context-specific associations\n                \"PG\",  # Predicate -&gt; Graph: associates predicates with graph contexts\n                \"SG\",  # Subject -&gt; Graph: associates subjects with graph contexts\n                \"GO\",  # Graph -&gt; Object: maps graph contexts to objects for grouped retrieval\n                \"GP\",  # Graph -&gt; Predicate: links graph contexts to predicates\n            }\n        )\n\n    raise ValueError(f\"Unknown index configuration: {self}\")\n</code></pre>"},{"location":"#mogwai.core.hd_index.Quad","title":"<code>Quad</code>  <code>dataclass</code>","text":"<p>A quad of hashable values (Subject-Predicate-Object-Graph)</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>@dataclass(frozen=True)\nclass Quad:\n    \"\"\"A quad of hashable values (Subject-Predicate-Object-Graph)\"\"\"\n\n    s: Hashable  # Subject\n    p: Hashable  # Predicate\n    o: Hashable  # Object\n    g: Hashable | None = None  # Graph context\n</code></pre>"},{"location":"#mogwai.core.hd_index.SPOGIndex","title":"<code>SPOGIndex</code>","text":"<p>all 16 possible indices based on SPOG matrix</p> <p>see http://harth.org/andreas/ YARS and the paper</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>class SPOGIndex:\n    \"\"\"\n    all 16 possible indices based on SPOG matrix\n\n    see http://harth.org/andreas/ YARS and the paper\n    \"\"\"\n\n    def __init__(self, config: IndexConfig):\n        self.config = config\n        positions = [\"S\", \"P\", \"O\", \"G\"]\n        self.indices = {}\n        self.indices = {}\n        for from_pos in positions:\n            for to_pos in positions:\n                if from_pos != to_pos:\n                    index = Index(from_pos, to_pos)\n                    self.indices[index.name] = index\n\n    def get_lookup(self, from_pos: str, to_pos: str) -&gt; dict | None:\n        \"\"\"\n        Get lookup dict for from-&gt;to positions if active\n\n        Args:\n            from_pos: From position (S,P,O,G)\n            to_pos: To position (S,P,O,G)\n        Returns:\n            Lookup dict if index active in current config, None otherwise\n        \"\"\"\n        index_name = f\"{from_pos}{to_pos}\"\n        if index_name in self.config.active_indices:\n            return self.indices[index_name].lookup\n        return None\n\n    def add_quad(self, quad: Quad) -&gt; None:\n        \"\"\"Add quad only to configured active indices\"\"\"\n        for index_name in self.config.active_indices:\n            self.indices[index_name].add_quad(quad)\n</code></pre>"},{"location":"#mogwai.core.hd_index.SPOGIndex.add_quad","title":"<code>add_quad(quad)</code>","text":"<p>Add quad only to configured active indices</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def add_quad(self, quad: Quad) -&gt; None:\n    \"\"\"Add quad only to configured active indices\"\"\"\n    for index_name in self.config.active_indices:\n        self.indices[index_name].add_quad(quad)\n</code></pre>"},{"location":"#mogwai.core.hd_index.SPOGIndex.get_lookup","title":"<code>get_lookup(from_pos, to_pos)</code>","text":"<p>Get lookup dict for from-&gt;to positions if active</p> <p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>str</code> <p>From position (S,P,O,G)</p> required <code>to_pos</code> <code>str</code> <p>To position (S,P,O,G)</p> required <p>Returns:     Lookup dict if index active in current config, None otherwise</p> Source code in <code>mogwai/core/hd_index.py</code> <pre><code>def get_lookup(self, from_pos: str, to_pos: str) -&gt; dict | None:\n    \"\"\"\n    Get lookup dict for from-&gt;to positions if active\n\n    Args:\n        from_pos: From position (S,P,O,G)\n        to_pos: To position (S,P,O,G)\n    Returns:\n        Lookup dict if index active in current config, None otherwise\n    \"\"\"\n    index_name = f\"{from_pos}{to_pos}\"\n    if index_name in self.config.active_indices:\n        return self.indices[index_name].lookup\n    return None\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph","title":"<code>mogwaigraph</code>","text":""},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph","title":"<code>MogwaiGraph</code>","text":"<p>               Bases: <code>DiGraph</code></p> <p>networkx based directed graph see https://networkx.org/documentation/stable/reference/classes/digraph.html</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>class MogwaiGraph(networkx.DiGraph):\n    \"\"\"\n    networkx based directed graph\n    see https://networkx.org/documentation/stable/reference/classes/digraph.html\n    \"\"\"\n\n    def __init__(\n        self, incoming_graph_data=None, config: MogwaiGraphConfig = None, **attr\n    ):\n        \"\"\"Initialize a MogwaiGraph with optional data and configuration.\n\n        Args:\n            incoming_graph_data: Graph data in NetworkX compatible format\n            config (MogwaiGraphConfig): Configuration for field names and defaults\n            **attr: Graph attributes as key=value pairs\n        \"\"\"\n        super().__init__(incoming_graph_data, **attr)\n        self.counter = 0\n        self.config = config or MogwaiGraphConfig()\n        # Initialize SPOG index based on config\n        index_config = IndexConfigs[self.config.index_config.upper()].get_config()\n        self.spog_index = SPOGIndex(index_config)\n\n    def get_next_node_id(self) -&gt; str:\n        \"\"\"\n        get the next node_id\n        \"\"\"\n        node_id = self.counter\n        self.counter += 1\n        node_id_str = str(node_id)\n        return node_id_str\n\n    def add_to_index(\n        self,\n        element_type: str,\n        subject_id: Hashable,\n        label: str,\n        name: str,\n        properties: dict,\n    ):\n        \"\"\"\n        Add labels, name, and properties to the SPOG index for a\n        given subject and element_type\n\n        Args:\n            element_type: (str): node or edge\n            subject_id (Hashable): The ID of the subject (node or edge).\n            label (str): the label for the subject.\n            name (str): Name of the subject.\n            properties (dict): Dictionary of additional properties to index.\n        \"\"\"\n        # only index if the config calls for it\n        if self.config.index_config == \"off\":\n            return\n        # Add quads for label with g=\"label\"\n        label_quad = Quad(s=subject_id, p=\"label\", o=label, g=f\"{element_type}-label\")\n        self.spog_index.add_quad(label_quad)\n\n        # Add quad for name with g=\"name\"\n        name_quad = Quad(s=subject_id, p=\"name\", o=name, g=f\"{element_type}-name\")\n        self.spog_index.add_quad(name_quad)\n\n        # Add quads for each property with g=\"property\"\n        for prop_name, prop_value in properties.items():\n            if not isinstance(prop_value, Hashable):\n                prop_value = str(prop_value)  # Ensure property value is hashable\n            property_quad = Quad(\n                s=subject_id, p=prop_name, o=prop_value, g=f\"{element_type}-property\"\n            )\n            self.spog_index.add_quad(property_quad)\n\n    def add_labeled_node(\n        self,\n        label: str,\n        name: str,\n        properties: dict = None,\n        node_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; Any:\n        \"\"\"\n        Add a labeled node to the graph.\n\n        we can only insert a node by hashable value and as names and ids\n        might occur multiple times we use incremented node ids if no node_id is provided\n\n        Args:\n            label (str): The label for the node.\n            name (str): The name of the node.\n            properties (dict, optional): Additional properties for the node. Defaults to None.\n            node_id (Optional[int], optional): The ID for the node. If not provided, a new ID will be generated. Defaults to None.\n            kwargs (): further property values\n        Returns:\n            Any: The ID of the newly added node - will be an integer if node_id was kept as default None\n\n        Raises:\n            MogwaiGraphError: If a node with the provided ID already exists in the graph.\n        \"\"\"\n        if node_id is None:\n            node_id = self.get_next_node_id()\n        properties = properties or {}\n        properties.update(kwargs)\n        if self.config.name_field in properties:\n            raise MogwaiGraphError(\n                f\"The '{self.config.name_field}' property is reserved for the node name.\"\n            )\n        elif self.config.label_field in properties:\n            raise MogwaiGraphError(\n                f\"The '{self.config.label_field}' property is reserved for the node labels.\"\n            )\n        node_props = {\n            self.config.name_field: name,\n            self.config.label_field: label,\n            **properties,\n        }\n        super().add_node(node_id, **node_props)\n        # Use add_to_index to add label, name, and properties as quads\n        self.add_to_index(\"node\", node_id, label, name, properties)\n        return node_id\n\n    def add_labeled_edge(\n        self, srcId: int, destId: int, edgeLabel: str, properties: dict = None, **kwargs\n    ):\n        \"\"\"\n        add a labeled edge\n        \"\"\"\n        if self.has_node(srcId) and self.has_node(destId):\n            properties = properties or {}\n            properties.update(kwargs)\n            if self.config.edge_label_field in properties:\n                raise MogwaiGraphError(\n                    f\"The '{self.config.edge_label_field}' property is reserved for the edge label.\"\n                )\n            elif self.config.label_field in properties:\n                raise MogwaiGraphError(\n                    f\"The '{self.config.label_field}' property is reserved for the node labels.\"\n                )\n            edge_props = {self.config.edge_label_field: edgeLabel, **properties}\n            super().add_edge(srcId, destId, **edge_props)\n            # Add a quad specifically for the edge connection\n            edge_quad = Quad(s=srcId, p=edgeLabel, o=destId, g=\"edge-link\")\n            self.spog_index.add_quad(edge_quad)\n\n            # Use add_to_index to add label, name, and properties as quads\n            self.add_to_index(\"edge\", srcId, edgeLabel, edgeLabel, properties)\n        else:\n            raise MogwaiGraphError(\n                f\"Node with srcId {srcId} or destId {destId} is not in the graph.\"\n            )\n\n    def add_node(self, *args, **kwargs):\n        \"\"\"Add a node with default or explicit labels\"\"\"\n        if len(args) &gt; 0:\n            node_id = args[0]\n        else:\n            node_id = self.get_next_node_id()\n\n        label = kwargs.pop(\"labels\", self.config.default_node_label)\n        name = kwargs.pop(\"name\", str(node_id))\n        return self.add_labeled_node(label, name, properties=kwargs, node_id=node_id)\n\n    def add_edge(self, *args, **kwargs):\n        \"\"\"Add an edge with default or explicit label\"\"\"\n        if len(args) &lt; 2:\n            raise MogwaiGraphError(\"add_edge() requires source and target node ids\")\n        src, dst = args[0:2]\n        label = kwargs.pop(self.config.edge_label_field, self.config.default_edge_label)\n        return self.add_labeled_edge(src, dst, label, properties=kwargs)\n\n    def _get_nodes_set(self, label: set, name: str):\n        n_none = name is None\n        if n_none:\n            return [n for n in self.nodes(date=True) if label.issubset(n[1][\"labels\"])]\n        if not n_none:\n            return [\n                n\n                for n in self.nodes(data=True)\n                if label.issubset(n[1][\"labels\"]) and n[1][\"name\"] == name\n            ]\n        return self.nodes\n\n    def get_nodes(self, label: str, name: str):\n        \"\"\"\n        @FIXME - this is ugly code\n        \"\"\"\n        l_none, n_none = label is None, name is None\n        if not l_none and not n_none:\n            return [\n                n\n                for n in self.nodes(data=True)\n                if label in n[1][\"labels\"] and n[1][\"name\"] == name\n            ]\n        if l_none and not n_none:\n            return [n for n in self.nodes(data=True) if n[1][\"name\"] == name]\n        if not l_none and n_none:\n            return [n for n in self.nodes(date=True) if label in n[1][\"labels\"]]\n        return self.nodes\n\n    def merge(\n        self, other: \"MogwaiGraph\", srcId: int, targetId: int, edgeLabel: str\n    ):\n        mapping = {k: self.get_next_node_id() for k in other.nodes}\n        relabeled = networkx.relabel_nodes(other, mapping, copy=True)\n        self.add_nodes_from(relabeled.nodes(data=True))\n        self.add_edges_from(relabeled.edges(data=True))\n        self.add_labeled_edge(\n            srcId=srcId, destId=mapping[targetId], edgeLabel=edgeLabel\n        )\n\n    def join(\n        self,\n        from_label: str,\n        to_label: str,\n        join_field: str,\n        target_key: str,\n        edge_label: str,\n    ):\n        \"\"\"Joins two node types by field values and creates edges between them.\"\"\"\n        node_lookup = self.spog_index.get_lookup(\"P\", \"O\")\n        if not node_lookup:\n            raise ValueError(\"No SPOG index available\")\n\n        field_values = node_lookup.get(join_field)\n        if field_values is None:\n            raise ValueError(f\"Join field {join_field} not found in index\")\n\n        target_values = node_lookup.get(target_key)\n        if target_values is None:\n            raise ValueError(f\"Target key {target_key} not found in index\")\n\n        os_lookup = self.spog_index.get_lookup(\"O\", \"S\")\n        for source_id in os_lookup.get(from_label):\n            source_value = self.nodes[source_id][join_field]\n            target_ids = os_lookup.get(source_value)\n            for target_id in target_ids:\n                if to_label in self.nodes[target_id].get(\"labels\", []):\n                    self.add_labeled_edge(source_id, target_id, edge_label)\n\n    def draw(self, outputfile, title: str = \"MogwaiGraph\", **kwargs):\n        \"\"\"\n        Draw the graph using graphviz\n        Parameters\n        ----------\n        outputfile : str\n            the file to save the graph to\n        title : str, default 'MogwaiGraph'\n            the title of the graph\n        kwargs : dict\n            additional parameters used to configure the drawing style.\n            For more details see `MogwaiGraphDrawer`\n        \"\"\"\n        MogwaiGraphDrawer(self, title=title, **kwargs).draw(outputfile)\n\n    @classmethod\n    def modern(cls, index_config=\"off\") -&gt; \"MogwaiGraph\":\n        \"\"\"\n        create the modern graph\n        see https://tinkerpop.apache.org/docs/current/tutorials/getting-started/\n        \"\"\"\n        config = MogwaiGraphConfig\n        config.index_config = index_config\n        g = MogwaiGraph(config=config)\n        marko = g.add_labeled_node(\"Person\", name=\"marko\", age=29)\n        vadas = g.add_labeled_node(\"Person\", name=\"vadas\", age=27)\n        lop = g.add_labeled_node(\"Software\", name=\"lop\", lang=\"java\")\n        josh = g.add_labeled_node(\"Person\", name=\"josh\", age=32)\n        ripple = g.add_labeled_node(\"Software\", name=\"ripple\", lang=\"java\")\n        peter = g.add_labeled_node(\"Person\", name=\"peter\", age=35)\n\n        g.add_labeled_edge(marko, vadas, \"knows\", weight=0.5)\n        g.add_labeled_edge(marko, josh, \"knows\", weight=1.0)\n        g.add_labeled_edge(marko, lop, \"created\", weight=0.4)\n        g.add_labeled_edge(josh, ripple, \"created\", weight=1.0)\n        g.add_labeled_edge(josh, lop, \"created\", weight=0.4)\n        g.add_labeled_edge(peter, lop, \"created\", weight=0.2)\n        return g\n\n    @classmethod\n    def crew(cls) -&gt; \"MogwaiGraph\":\n        \"\"\"\n        create the TheCrew example graph\n        see TinkerFactory.createTheCrew() in https://tinkerpop.apache.org/docs/current/reference/\n        \"\"\"\n        g = MogwaiGraph()\n\n        def t(startTime: int, endTime: int = None):\n            d = dict()\n            d[\"startTime\"] = startTime\n            if endTime is not None:\n                d[\"endTime\"] = endTime\n            return d\n\n        marko = g.add_labeled_node(\n            \"Person\",\n            name=\"marko\",\n            location={\n                \"san diego\": t(1997, 2001),\n                \"santa cruz\": t(2001, 2004),\n                \"brussels\": t(2004, 2005),\n                \"santa fe\": t(2005),\n            },\n        )\n        stephen = g.add_labeled_node(\n            \"Person\",\n            name=\"stephen\",\n            location={\n                \"centreville\": t(1990, 2000),\n                \"dulles\": t(2000, 2006),\n                \"purcellvilee\": t(2006),\n            },\n        )\n        matthias = g.add_labeled_node(\n            \"Person\",\n            name=\"matthias\",\n            location={\n                \"bremen\": t(2004, 2007),\n                \"baltimore\": t(2007, 2011),\n                \"oakland\": t(2011, 2014),\n                \"seattle\": t(2014),\n            },\n        )\n        daniel = g.add_labeled_node(\n            \"Person\",\n            name=\"daniel\",\n            location={\n                \"spremberg\": t(1982, 2005),\n                \"kaiserslautern\": t(2005, 2009),\n                \"aachen\": t(2009),\n            },\n        )\n        gremlin = g.add_labeled_node(\"Software\", name=\"gremlin\")\n        tinkergraph = g.add_labeled_node(\"Software\", name=\"tinkergraph\")\n\n        g.add_labeled_edge(marko, gremlin, \"uses\", skill=4)\n        g.add_labeled_edge(stephen, gremlin, \"uses\", skill=5)\n        g.add_labeled_edge(matthias, gremlin, \"uses\", skill=3)\n        g.add_labeled_edge(daniel, gremlin, \"uses\", skill=5)\n        g.add_labeled_edge(marko, tinkergraph, \"uses\", skill=5)\n        g.add_labeled_edge(stephen, tinkergraph, \"uses\", skill=4)\n        g.add_labeled_edge(matthias, tinkergraph, \"uses\", skill=3)\n        g.add_labeled_edge(daniel, tinkergraph, \"uses\", skill=3)\n        g.add_labeled_edge(gremlin, tinkergraph, \"traverses\")\n        g.add_labeled_edge(marko, tinkergraph, \"develops\", since=2010)\n        g.add_labeled_edge(stephen, tinkergraph, \"develops\", since=2011)\n        g.add_labeled_edge(marko, gremlin, \"develops\", since=2009)\n        g.add_labeled_edge(stephen, gremlin, \"develops\", since=2010)\n        g.add_labeled_edge(matthias, gremlin, \"develops\", since=2012)\n        return g\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.__init__","title":"<code>__init__(incoming_graph_data=None, config=None, **attr)</code>","text":"<p>Initialize a MogwaiGraph with optional data and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_graph_data</code> <p>Graph data in NetworkX compatible format</p> <code>None</code> <code>config</code> <code>MogwaiGraphConfig</code> <p>Configuration for field names and defaults</p> <code>None</code> <code>**attr</code> <p>Graph attributes as key=value pairs</p> <code>{}</code> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def __init__(\n    self, incoming_graph_data=None, config: MogwaiGraphConfig = None, **attr\n):\n    \"\"\"Initialize a MogwaiGraph with optional data and configuration.\n\n    Args:\n        incoming_graph_data: Graph data in NetworkX compatible format\n        config (MogwaiGraphConfig): Configuration for field names and defaults\n        **attr: Graph attributes as key=value pairs\n    \"\"\"\n    super().__init__(incoming_graph_data, **attr)\n    self.counter = 0\n    self.config = config or MogwaiGraphConfig()\n    # Initialize SPOG index based on config\n    index_config = IndexConfigs[self.config.index_config.upper()].get_config()\n    self.spog_index = SPOGIndex(index_config)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_edge","title":"<code>add_edge(*args, **kwargs)</code>","text":"<p>Add an edge with default or explicit label</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_edge(self, *args, **kwargs):\n    \"\"\"Add an edge with default or explicit label\"\"\"\n    if len(args) &lt; 2:\n        raise MogwaiGraphError(\"add_edge() requires source and target node ids\")\n    src, dst = args[0:2]\n    label = kwargs.pop(self.config.edge_label_field, self.config.default_edge_label)\n    return self.add_labeled_edge(src, dst, label, properties=kwargs)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_labeled_edge","title":"<code>add_labeled_edge(srcId, destId, edgeLabel, properties=None, **kwargs)</code>","text":"<p>add a labeled edge</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_labeled_edge(\n    self, srcId: int, destId: int, edgeLabel: str, properties: dict = None, **kwargs\n):\n    \"\"\"\n    add a labeled edge\n    \"\"\"\n    if self.has_node(srcId) and self.has_node(destId):\n        properties = properties or {}\n        properties.update(kwargs)\n        if self.config.edge_label_field in properties:\n            raise MogwaiGraphError(\n                f\"The '{self.config.edge_label_field}' property is reserved for the edge label.\"\n            )\n        elif self.config.label_field in properties:\n            raise MogwaiGraphError(\n                f\"The '{self.config.label_field}' property is reserved for the node labels.\"\n            )\n        edge_props = {self.config.edge_label_field: edgeLabel, **properties}\n        super().add_edge(srcId, destId, **edge_props)\n        # Add a quad specifically for the edge connection\n        edge_quad = Quad(s=srcId, p=edgeLabel, o=destId, g=\"edge-link\")\n        self.spog_index.add_quad(edge_quad)\n\n        # Use add_to_index to add label, name, and properties as quads\n        self.add_to_index(\"edge\", srcId, edgeLabel, edgeLabel, properties)\n    else:\n        raise MogwaiGraphError(\n            f\"Node with srcId {srcId} or destId {destId} is not in the graph.\"\n        )\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_labeled_node","title":"<code>add_labeled_node(label, name, properties=None, node_id=None, **kwargs)</code>","text":"<p>Add a labeled node to the graph.</p> <p>we can only insert a node by hashable value and as names and ids might occur multiple times we use incremented node ids if no node_id is provided</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label for the node.</p> required <code>name</code> <code>str</code> <p>The name of the node.</p> required <code>properties</code> <code>dict</code> <p>Additional properties for the node. Defaults to None.</p> <code>None</code> <code>node_id</code> <code>Optional[int]</code> <p>The ID for the node. If not provided, a new ID will be generated. Defaults to None.</p> <code>None</code> <code>kwargs</code> <p>further property values</p> <code>{}</code> <p>Returns:     Any: The ID of the newly added node - will be an integer if node_id was kept as default None</p> <p>Raises:</p> Type Description <code>MogwaiGraphError</code> <p>If a node with the provided ID already exists in the graph.</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_labeled_node(\n    self,\n    label: str,\n    name: str,\n    properties: dict = None,\n    node_id: Optional[str] = None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"\n    Add a labeled node to the graph.\n\n    we can only insert a node by hashable value and as names and ids\n    might occur multiple times we use incremented node ids if no node_id is provided\n\n    Args:\n        label (str): The label for the node.\n        name (str): The name of the node.\n        properties (dict, optional): Additional properties for the node. Defaults to None.\n        node_id (Optional[int], optional): The ID for the node. If not provided, a new ID will be generated. Defaults to None.\n        kwargs (): further property values\n    Returns:\n        Any: The ID of the newly added node - will be an integer if node_id was kept as default None\n\n    Raises:\n        MogwaiGraphError: If a node with the provided ID already exists in the graph.\n    \"\"\"\n    if node_id is None:\n        node_id = self.get_next_node_id()\n    properties = properties or {}\n    properties.update(kwargs)\n    if self.config.name_field in properties:\n        raise MogwaiGraphError(\n            f\"The '{self.config.name_field}' property is reserved for the node name.\"\n        )\n    elif self.config.label_field in properties:\n        raise MogwaiGraphError(\n            f\"The '{self.config.label_field}' property is reserved for the node labels.\"\n        )\n    node_props = {\n        self.config.name_field: name,\n        self.config.label_field: label,\n        **properties,\n    }\n    super().add_node(node_id, **node_props)\n    # Use add_to_index to add label, name, and properties as quads\n    self.add_to_index(\"node\", node_id, label, name, properties)\n    return node_id\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_node","title":"<code>add_node(*args, **kwargs)</code>","text":"<p>Add a node with default or explicit labels</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_node(self, *args, **kwargs):\n    \"\"\"Add a node with default or explicit labels\"\"\"\n    if len(args) &gt; 0:\n        node_id = args[0]\n    else:\n        node_id = self.get_next_node_id()\n\n    label = kwargs.pop(\"labels\", self.config.default_node_label)\n    name = kwargs.pop(\"name\", str(node_id))\n    return self.add_labeled_node(label, name, properties=kwargs, node_id=node_id)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.add_to_index","title":"<code>add_to_index(element_type, subject_id, label, name, properties)</code>","text":"<p>Add labels, name, and properties to the SPOG index for a given subject and element_type</p> <p>Parameters:</p> Name Type Description Default <code>element_type</code> <code>str</code> <p>(str): node or edge</p> required <code>subject_id</code> <code>Hashable</code> <p>The ID of the subject (node or edge).</p> required <code>label</code> <code>str</code> <p>the label for the subject.</p> required <code>name</code> <code>str</code> <p>Name of the subject.</p> required <code>properties</code> <code>dict</code> <p>Dictionary of additional properties to index.</p> required Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def add_to_index(\n    self,\n    element_type: str,\n    subject_id: Hashable,\n    label: str,\n    name: str,\n    properties: dict,\n):\n    \"\"\"\n    Add labels, name, and properties to the SPOG index for a\n    given subject and element_type\n\n    Args:\n        element_type: (str): node or edge\n        subject_id (Hashable): The ID of the subject (node or edge).\n        label (str): the label for the subject.\n        name (str): Name of the subject.\n        properties (dict): Dictionary of additional properties to index.\n    \"\"\"\n    # only index if the config calls for it\n    if self.config.index_config == \"off\":\n        return\n    # Add quads for label with g=\"label\"\n    label_quad = Quad(s=subject_id, p=\"label\", o=label, g=f\"{element_type}-label\")\n    self.spog_index.add_quad(label_quad)\n\n    # Add quad for name with g=\"name\"\n    name_quad = Quad(s=subject_id, p=\"name\", o=name, g=f\"{element_type}-name\")\n    self.spog_index.add_quad(name_quad)\n\n    # Add quads for each property with g=\"property\"\n    for prop_name, prop_value in properties.items():\n        if not isinstance(prop_value, Hashable):\n            prop_value = str(prop_value)  # Ensure property value is hashable\n        property_quad = Quad(\n            s=subject_id, p=prop_name, o=prop_value, g=f\"{element_type}-property\"\n        )\n        self.spog_index.add_quad(property_quad)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.crew","title":"<code>crew()</code>  <code>classmethod</code>","text":"<p>create the TheCrew example graph see TinkerFactory.createTheCrew() in https://tinkerpop.apache.org/docs/current/reference/</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>@classmethod\ndef crew(cls) -&gt; \"MogwaiGraph\":\n    \"\"\"\n    create the TheCrew example graph\n    see TinkerFactory.createTheCrew() in https://tinkerpop.apache.org/docs/current/reference/\n    \"\"\"\n    g = MogwaiGraph()\n\n    def t(startTime: int, endTime: int = None):\n        d = dict()\n        d[\"startTime\"] = startTime\n        if endTime is not None:\n            d[\"endTime\"] = endTime\n        return d\n\n    marko = g.add_labeled_node(\n        \"Person\",\n        name=\"marko\",\n        location={\n            \"san diego\": t(1997, 2001),\n            \"santa cruz\": t(2001, 2004),\n            \"brussels\": t(2004, 2005),\n            \"santa fe\": t(2005),\n        },\n    )\n    stephen = g.add_labeled_node(\n        \"Person\",\n        name=\"stephen\",\n        location={\n            \"centreville\": t(1990, 2000),\n            \"dulles\": t(2000, 2006),\n            \"purcellvilee\": t(2006),\n        },\n    )\n    matthias = g.add_labeled_node(\n        \"Person\",\n        name=\"matthias\",\n        location={\n            \"bremen\": t(2004, 2007),\n            \"baltimore\": t(2007, 2011),\n            \"oakland\": t(2011, 2014),\n            \"seattle\": t(2014),\n        },\n    )\n    daniel = g.add_labeled_node(\n        \"Person\",\n        name=\"daniel\",\n        location={\n            \"spremberg\": t(1982, 2005),\n            \"kaiserslautern\": t(2005, 2009),\n            \"aachen\": t(2009),\n        },\n    )\n    gremlin = g.add_labeled_node(\"Software\", name=\"gremlin\")\n    tinkergraph = g.add_labeled_node(\"Software\", name=\"tinkergraph\")\n\n    g.add_labeled_edge(marko, gremlin, \"uses\", skill=4)\n    g.add_labeled_edge(stephen, gremlin, \"uses\", skill=5)\n    g.add_labeled_edge(matthias, gremlin, \"uses\", skill=3)\n    g.add_labeled_edge(daniel, gremlin, \"uses\", skill=5)\n    g.add_labeled_edge(marko, tinkergraph, \"uses\", skill=5)\n    g.add_labeled_edge(stephen, tinkergraph, \"uses\", skill=4)\n    g.add_labeled_edge(matthias, tinkergraph, \"uses\", skill=3)\n    g.add_labeled_edge(daniel, tinkergraph, \"uses\", skill=3)\n    g.add_labeled_edge(gremlin, tinkergraph, \"traverses\")\n    g.add_labeled_edge(marko, tinkergraph, \"develops\", since=2010)\n    g.add_labeled_edge(stephen, tinkergraph, \"develops\", since=2011)\n    g.add_labeled_edge(marko, gremlin, \"develops\", since=2009)\n    g.add_labeled_edge(stephen, gremlin, \"develops\", since=2010)\n    g.add_labeled_edge(matthias, gremlin, \"develops\", since=2012)\n    return g\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.draw","title":"<code>draw(outputfile, title='MogwaiGraph', **kwargs)</code>","text":"<p>Draw the graph using graphviz Parameters</p> <p>outputfile : str     the file to save the graph to title : str, default 'MogwaiGraph'     the title of the graph kwargs : dict     additional parameters used to configure the drawing style.     For more details see <code>MogwaiGraphDrawer</code></p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def draw(self, outputfile, title: str = \"MogwaiGraph\", **kwargs):\n    \"\"\"\n    Draw the graph using graphviz\n    Parameters\n    ----------\n    outputfile : str\n        the file to save the graph to\n    title : str, default 'MogwaiGraph'\n        the title of the graph\n    kwargs : dict\n        additional parameters used to configure the drawing style.\n        For more details see `MogwaiGraphDrawer`\n    \"\"\"\n    MogwaiGraphDrawer(self, title=title, **kwargs).draw(outputfile)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.get_next_node_id","title":"<code>get_next_node_id()</code>","text":"<p>get the next node_id</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def get_next_node_id(self) -&gt; str:\n    \"\"\"\n    get the next node_id\n    \"\"\"\n    node_id = self.counter\n    self.counter += 1\n    node_id_str = str(node_id)\n    return node_id_str\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.get_nodes","title":"<code>get_nodes(label, name)</code>","text":"<p>@FIXME - this is ugly code</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def get_nodes(self, label: str, name: str):\n    \"\"\"\n    @FIXME - this is ugly code\n    \"\"\"\n    l_none, n_none = label is None, name is None\n    if not l_none and not n_none:\n        return [\n            n\n            for n in self.nodes(data=True)\n            if label in n[1][\"labels\"] and n[1][\"name\"] == name\n        ]\n    if l_none and not n_none:\n        return [n for n in self.nodes(data=True) if n[1][\"name\"] == name]\n    if not l_none and n_none:\n        return [n for n in self.nodes(date=True) if label in n[1][\"labels\"]]\n    return self.nodes\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.join","title":"<code>join(from_label, to_label, join_field, target_key, edge_label)</code>","text":"<p>Joins two node types by field values and creates edges between them.</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def join(\n    self,\n    from_label: str,\n    to_label: str,\n    join_field: str,\n    target_key: str,\n    edge_label: str,\n):\n    \"\"\"Joins two node types by field values and creates edges between them.\"\"\"\n    node_lookup = self.spog_index.get_lookup(\"P\", \"O\")\n    if not node_lookup:\n        raise ValueError(\"No SPOG index available\")\n\n    field_values = node_lookup.get(join_field)\n    if field_values is None:\n        raise ValueError(f\"Join field {join_field} not found in index\")\n\n    target_values = node_lookup.get(target_key)\n    if target_values is None:\n        raise ValueError(f\"Target key {target_key} not found in index\")\n\n    os_lookup = self.spog_index.get_lookup(\"O\", \"S\")\n    for source_id in os_lookup.get(from_label):\n        source_value = self.nodes[source_id][join_field]\n        target_ids = os_lookup.get(source_value)\n        for target_id in target_ids:\n            if to_label in self.nodes[target_id].get(\"labels\", []):\n                self.add_labeled_edge(source_id, target_id, edge_label)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraph.modern","title":"<code>modern(index_config='off')</code>  <code>classmethod</code>","text":"<p>create the modern graph see https://tinkerpop.apache.org/docs/current/tutorials/getting-started/</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>@classmethod\ndef modern(cls, index_config=\"off\") -&gt; \"MogwaiGraph\":\n    \"\"\"\n    create the modern graph\n    see https://tinkerpop.apache.org/docs/current/tutorials/getting-started/\n    \"\"\"\n    config = MogwaiGraphConfig\n    config.index_config = index_config\n    g = MogwaiGraph(config=config)\n    marko = g.add_labeled_node(\"Person\", name=\"marko\", age=29)\n    vadas = g.add_labeled_node(\"Person\", name=\"vadas\", age=27)\n    lop = g.add_labeled_node(\"Software\", name=\"lop\", lang=\"java\")\n    josh = g.add_labeled_node(\"Person\", name=\"josh\", age=32)\n    ripple = g.add_labeled_node(\"Software\", name=\"ripple\", lang=\"java\")\n    peter = g.add_labeled_node(\"Person\", name=\"peter\", age=35)\n\n    g.add_labeled_edge(marko, vadas, \"knows\", weight=0.5)\n    g.add_labeled_edge(marko, josh, \"knows\", weight=1.0)\n    g.add_labeled_edge(marko, lop, \"created\", weight=0.4)\n    g.add_labeled_edge(josh, ripple, \"created\", weight=1.0)\n    g.add_labeled_edge(josh, lop, \"created\", weight=0.4)\n    g.add_labeled_edge(peter, lop, \"created\", weight=0.2)\n    return g\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphConfig","title":"<code>MogwaiGraphConfig</code>  <code>dataclass</code>","text":"<p>configuration of a MogwaiGraph</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>@dataclass\nclass MogwaiGraphConfig:\n    \"\"\"\n    configuration of a MogwaiGraph\n    \"\"\"\n\n    name_field: str = \"name\"\n    label_field: str = \"labels\"\n    edge_label_field: str = \"labels\"\n    default_node_label: str = \"Node\"\n    default_edge_label: str = \"Edge\"\n    index_config: str = \"off\"\n    single_label: bool = True\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphDrawer","title":"<code>MogwaiGraphDrawer</code>","text":"<p>helper class to draw MogwaiGraphs</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>class MogwaiGraphDrawer:\n    \"\"\"\n    helper class to draw MogwaiGraphs\n    \"\"\"\n\n    def __init__(self, g: MogwaiGraph, title: str, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        g : MogwaiGraph\n            the graph to draw\n        title : str\n            the title of the graph\n        kwargs : dict\n            additional parameters used to configure the drawing style\n            * *fontname* : str, default 'arial'\n                the font to use\n            * *fillcolor* : str, default '#ADE1FE'\n                the fill color of the vertices\n            * *edge_line_width* : int, default 3\n                the width of the edges\n            * *dash_width* : int, default 5\n                number of dashess in the head/properties delimiter\n            * *v_limit* : int, default 10\n                the maximum number of vertices to show\n            * *e_limit* : int, default 10\n                the maximum number of edges to show\n            * *vertex_properties* : list, default None\n                the properties to display for vertices, if `None` all properties are shown\n            * *edge_properties* : list, default None\n                the properties to display for edges, if `None` all properties are shown\n            * *prog* : str, default 'dot'\n                the layout program to use\n        \"\"\"\n        self.g = g\n        self.title = title\n        self.config = kwargs or {}\n        self.vertex_keys = self.config.get(\"vertex_properties\", None)\n        self.edge_keys = self.config.get(\"edge_properties\", None)\n\n        self.v_drawn = set()\n        self.e_drawn = set()\n\n    def _draw_vertex(self, n):\n        if len(self.v_drawn) &gt;= self.config.get(\"v_limit\", 10):\n            return False\n        if n[0] in self.v_drawn:\n            return None\n        id, properties = n\n        head = f\"{id}, {properties.pop('name')}\\n{', '.join(properties.pop('labels'))}\"\n        if self.vertex_keys:\n            properties = {k: v for k, v in properties.items() if k in self.vertex_keys}\n        body = \"\\n\".join([f\"{k}: {v}\" for k, v in properties.items()])\n        label = f\"{head}\\n\" + (\"-\" * self.config.get(\"dash_width\", 5)) + f\"\\n{body}\"\n\n        self.gviz.add_node(\n            id,\n            label=label,\n            fillcolor=self.config.get(\"fillcolor\", \"#ADE1FE\"),\n            style=\"filled\",\n            fontname=self.config.get(\"fontname\", \"arial\"),\n        )\n        self.v_drawn.add(id)\n        return True\n\n    def _draw_edge(self, e, with_vertices: bool = True):\n        if len(self.e_drawn) &gt; self.config.get(\"e_limit\", 10):\n            return False\n        if e[:-1] in self.e_drawn:\n            return None\n        if with_vertices:\n            self._draw_vertex((e[0], self.g.nodes[e[0]]))\n            self._draw_vertex((e[1], self.g.nodes[e[1]]))\n        head = f\"{e[2].pop('labels')}\"\n        body = \"\\n\".join([f\"{k}: {v}\" for k, v in e[2].items()])\n        label = f\"{head}\\n\" + (\"-\" * self.config.get(\"dash_width\", 5)) + f\"\\n{body}\"\n\n        self.gviz.add_edge(\n            e[0],\n            e[1],\n            label=label,\n            style=f\"setlinewidth({self.config.get('edge_line_width', 3)})\",\n            fontname=self.config.get(\"fontname\", \"arial\"),\n        )\n        self.e_drawn.add(e[:-1])\n\n    def draw(self, outputfile: str):\n        \"\"\"\n        draw the given graphviz markup from the given output file using\n        the graphviz \"dot\" software\n        \"\"\"\n        try:\n            import pygraphviz\n        except ImportError:\n            raise ImportError(\"Please install pygraphviz to draw graphs.\")\n\n        self.gviz: pygraphviz.AGraph = networkx.nx_agraph.to_agraph(self.g)\n        for n in self.g.nodes(data=True):\n            if self._draw_vertex(n) == False:\n                break\n        for e in self.g.edges(data=True):\n            if self._draw_edge(e) == False:\n                break\n        self.gviz.layout(prog=self.config.get(\"prog\", \"dot\"))\n        self.gviz.draw(outputfile)\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphDrawer.__init__","title":"<code>__init__(g, title, **kwargs)</code>","text":""},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphDrawer.__init__--parameters","title":"Parameters","text":"<p>g : MogwaiGraph     the graph to draw title : str     the title of the graph kwargs : dict     additional parameters used to configure the drawing style     * fontname : str, default 'arial'         the font to use     * fillcolor : str, default '#ADE1FE'         the fill color of the vertices     * edge_line_width : int, default 3         the width of the edges     * dash_width : int, default 5         number of dashess in the head/properties delimiter     * v_limit : int, default 10         the maximum number of vertices to show     * e_limit : int, default 10         the maximum number of edges to show     * vertex_properties : list, default None         the properties to display for vertices, if <code>None</code> all properties are shown     * edge_properties : list, default None         the properties to display for edges, if <code>None</code> all properties are shown     * prog : str, default 'dot'         the layout program to use</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def __init__(self, g: MogwaiGraph, title: str, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    g : MogwaiGraph\n        the graph to draw\n    title : str\n        the title of the graph\n    kwargs : dict\n        additional parameters used to configure the drawing style\n        * *fontname* : str, default 'arial'\n            the font to use\n        * *fillcolor* : str, default '#ADE1FE'\n            the fill color of the vertices\n        * *edge_line_width* : int, default 3\n            the width of the edges\n        * *dash_width* : int, default 5\n            number of dashess in the head/properties delimiter\n        * *v_limit* : int, default 10\n            the maximum number of vertices to show\n        * *e_limit* : int, default 10\n            the maximum number of edges to show\n        * *vertex_properties* : list, default None\n            the properties to display for vertices, if `None` all properties are shown\n        * *edge_properties* : list, default None\n            the properties to display for edges, if `None` all properties are shown\n        * *prog* : str, default 'dot'\n            the layout program to use\n    \"\"\"\n    self.g = g\n    self.title = title\n    self.config = kwargs or {}\n    self.vertex_keys = self.config.get(\"vertex_properties\", None)\n    self.edge_keys = self.config.get(\"edge_properties\", None)\n\n    self.v_drawn = set()\n    self.e_drawn = set()\n</code></pre>"},{"location":"#mogwai.core.mogwaigraph.MogwaiGraphDrawer.draw","title":"<code>draw(outputfile)</code>","text":"<p>draw the given graphviz markup from the given output file using the graphviz \"dot\" software</p> Source code in <code>mogwai/core/mogwaigraph.py</code> <pre><code>def draw(self, outputfile: str):\n    \"\"\"\n    draw the given graphviz markup from the given output file using\n    the graphviz \"dot\" software\n    \"\"\"\n    try:\n        import pygraphviz\n    except ImportError:\n        raise ImportError(\"Please install pygraphviz to draw graphs.\")\n\n    self.gviz: pygraphviz.AGraph = networkx.nx_agraph.to_agraph(self.g)\n    for n in self.g.nodes(data=True):\n        if self._draw_vertex(n) == False:\n            break\n    for e in self.g.edges(data=True):\n        if self._draw_edge(e) == False:\n            break\n    self.gviz.layout(prog=self.config.get(\"prog\", \"dot\"))\n    self.gviz.draw(outputfile)\n</code></pre>"},{"location":"#mogwai.core.steps","title":"<code>steps</code>","text":""},{"location":"#mogwai.core.steps.base_steps","title":"<code>base_steps</code>","text":""},{"location":"#mogwai.core.steps.branch_steps","title":"<code>branch_steps</code>","text":""},{"location":"#mogwai.core.steps.filter_steps","title":"<code>filter_steps</code>","text":""},{"location":"#mogwai.core.steps.filter_steps.HasWithin","title":"<code>HasWithin</code>","text":"<p>               Bases: <code>FilterStep</code></p> <p>Similar to <code>Has</code>, but with multiple options for the value</p> Source code in <code>mogwai/core/steps/filter_steps.py</code> <pre><code>class HasWithin(FilterStep):\n    \"\"\"\n    Similar to `Has`, but with multiple options for the value\n    \"\"\"\n    def __init__(self, traversal:Traversal, key:str|List[str], valueOptions:List|Tuple):\n        super().__init__(traversal)\n        self.key = key\n        self.valueOptions = valueOptions\n        indexer = (lambda t: t.get) if key==\"id\" else tu.get_dict_indexer(key, _NA)\n        self._filter = lambda t: indexer(self.traversal._get_element(t)) in self.valueOptions\n</code></pre>"},{"location":"#mogwai.core.steps.flatmap_steps","title":"<code>flatmap_steps</code>","text":""},{"location":"#mogwai.core.steps.io_step","title":"<code>io_step</code>","text":""},{"location":"#mogwai.core.steps.map_steps","title":"<code>map_steps</code>","text":""},{"location":"#mogwai.core.steps.map_steps.Fold","title":"<code>Fold</code>","text":"<p>               Bases: <code>MapStep</code></p> Source code in <code>mogwai/core/steps/map_steps.py</code> <pre><code>class Fold(MapStep):\n    def __init__(self, traversal:Traversal, seed:Any=None, foldfunc:Callable[[Any,Any], Any]=None):\n        \"\"\"\n        Combine all traversers into a single Value containing a list of all traversers.\n        If `seed` and `foldfunc` are provided, the traversers will be reduced into a single value using the provided function.\n        For example, `g.V().values('age').fold(0, lambda x,y: x+y).next()` will result in the sum of all ages.\n\n        Parameters\n        -----------\n        seed: Any, optional\n            The initial value to start the fold with.\n        foldfunc: Callable[[Any,Any], Any], optional\n            The bi-function to use to reduce the traversers into a single value.\n        \"\"\"\n        super().__init__(traversal)\n        self.seed=seed\n        self.foldfunc=foldfunc\n        if((seed is None) ^ (foldfunc is None)):\n            raise QueryError(\"`seed` and `foldfunc` should be both None or both not None.\")\n\n    def __call__(self, traversers:Iterable[Traverser]) -&gt; List[Traverser]:\n        if self.seed is not None:\n            from functools import reduce\n            #if the traversers are values, we need to extract the values first\n            def _map(t:Traverser|TravValue|Property):\n                if isinstance(t, TravValue):\n                    return t.val\n                elif isinstance(t, Property):\n                    return t.to_dict()\n                else:\n                    raise GraphTraversalError(\"Cannot reduce fold of non-value/property traversers.\")\n            traversers = list(map(_map, traversers))\n            return [TravValue(reduce(self.foldfunc, traversers, self.seed))]\n        else:\n            def _map(t:Traverser|TravValue|Property):\n                if isinstance(t, TravValue):\n                    return t.val\n                elif isinstance(t, Property):\n                    return t.to_dict()\n                else:\n                    return t.get\n        return [TravValue(list(map(_map, traversers)))]\n\n    def print_query(self) -&gt; str:\n        base = super().print_query()\n        if self.seed:\n            return f\"{base}({self.seed}, {self.foldfunc})\"\n        else:\n            return base\n</code></pre>"},{"location":"#mogwai.core.steps.map_steps.Fold.__init__","title":"<code>__init__(traversal, seed=None, foldfunc=None)</code>","text":"<p>Combine all traversers into a single Value containing a list of all traversers. If <code>seed</code> and <code>foldfunc</code> are provided, the traversers will be reduced into a single value using the provided function. For example, <code>g.V().values('age').fold(0, lambda x,y: x+y).next()</code> will result in the sum of all ages.</p>"},{"location":"#mogwai.core.steps.map_steps.Fold.__init__--parameters","title":"Parameters","text":"<p>seed: Any, optional     The initial value to start the fold with. foldfunc: Callable[[Any,Any], Any], optional     The bi-function to use to reduce the traversers into a single value.</p> Source code in <code>mogwai/core/steps/map_steps.py</code> <pre><code>def __init__(self, traversal:Traversal, seed:Any=None, foldfunc:Callable[[Any,Any], Any]=None):\n    \"\"\"\n    Combine all traversers into a single Value containing a list of all traversers.\n    If `seed` and `foldfunc` are provided, the traversers will be reduced into a single value using the provided function.\n    For example, `g.V().values('age').fold(0, lambda x,y: x+y).next()` will result in the sum of all ages.\n\n    Parameters\n    -----------\n    seed: Any, optional\n        The initial value to start the fold with.\n    foldfunc: Callable[[Any,Any], Any], optional\n        The bi-function to use to reduce the traversers into a single value.\n    \"\"\"\n    super().__init__(traversal)\n    self.seed=seed\n    self.foldfunc=foldfunc\n    if((seed is None) ^ (foldfunc is None)):\n        raise QueryError(\"`seed` and `foldfunc` should be both None or both not None.\")\n</code></pre>"},{"location":"#mogwai.core.steps.modulation_steps","title":"<code>modulation_steps</code>","text":""},{"location":"#mogwai.core.steps.start_steps","title":"<code>start_steps</code>","text":""},{"location":"#mogwai.core.steps.statics","title":"<code>statics</code>","text":""},{"location":"#mogwai.core.steps.statics.add_camel_case_aliases","title":"<code>add_camel_case_aliases(module_globals)</code>","text":"<p>Add camelCase aliases for all snake_case callables in the module's globals.</p> Source code in <code>mogwai/core/steps/statics.py</code> <pre><code>def add_camel_case_aliases(module_globals):\n    \"\"\"Add camelCase aliases for all snake_case callables in the module's globals.\"\"\"\n    camel_case_aliases = {}\n    for name, obj in module_globals.items():\n        if callable(obj) and '_' in name:  # Only convert callable objects with underscores\n            components = name.split('_')\n            camel_case_name = components[0] + ''.join(x.capitalize() for x in components[1:])\n            if name.endswith('_'):\n                camel_case_name += '_'\n            if camel_case_name != name:\n                camel_case_aliases[camel_case_name] = obj\n    module_globals.update(camel_case_aliases)\n</code></pre>"},{"location":"#mogwai.core.steps.terminal_steps","title":"<code>terminal_steps</code>","text":""},{"location":"#mogwai.core.traversal","title":"<code>traversal</code>","text":""},{"location":"#mogwai.core.traversal.AnonymousTraversal","title":"<code>AnonymousTraversal</code>","text":"<p>               Bases: <code>Traversal</code></p> <p>This class implements Anonymous traversals. These are traversals that are not directly bound to a source. They are used as subqueries in other traversals, and are not meant to be run on their own. As input, they receive a set of traversers from the parent traversal, and they return a set of traversers to the parent traversal.</p> <p>Importantly, some steps require information from the source traversal (like the graph's configuration) to be able to construct themselves. Therefore, we cannot construct an anonymous traversal at the time it is created, but we need to build it when it is added to a parent traversal. This inheritance structure is a bit of a hack to allow for this behavior and will inherently cause some issues with type hinting.</p> <p>This behavior is implemented in the following way. 1. When an anonymous traversal is created, it is empty, and it has a list of step templates. 2. When a step method is retrieved from the anonymous traversal, this <code>__getattribute__</code> call to obtain the method     is intercepted. Instead of returning the actual step method, which would run immediately and construct the step,     a deferred step method is returned. This deferred step method stores the step method and its arguments in the step templates. 3. When the anonymous traversal is build by a parent traversal, the parent traversal constructs the anonymous traversal.     In the anonymous traversal's build method, it constructs all the steps from the step templates as if the step methods are only called at this point. 4. The anonymous traversal is now ready to be run.</p> Source code in <code>mogwai/core/traversal.py</code> <pre><code>class AnonymousTraversal(Traversal):\n    \"\"\"\n    This class implements Anonymous traversals. These are traversals that are not directly bound to a source.\n    They are used as subqueries in other traversals, and are not meant to be run on their own.\n    As input, they receive a set of traversers from the parent traversal, and they return a set of traversers to the parent traversal.\n\n    Importantly, some steps require information from the source traversal (like the graph's configuration) to be able to construct themselves.\n    Therefore, we cannot construct an anonymous traversal at the time it is created, but we need to build it when it is added to a parent traversal.\n    This inheritance structure is a bit of a hack to allow for this behavior and will inherently cause some issues with type hinting.\n\n    This behavior is implemented in the following way.\n    1. When an anonymous traversal is created, it is empty, and it has a list of step templates.\n    2. When a step method is retrieved from the anonymous traversal, this `__getattribute__` call to obtain the method\n        is intercepted. Instead of returning the actual step method, which would run immediately and construct the step,\n        a deferred step method is returned. This deferred step method stores the step method and its arguments in the step templates.\n    3. When the anonymous traversal is build by a parent traversal, the parent traversal constructs the anonymous traversal.\n        In the anonymous traversal's build method, it constructs all the steps from the step templates as if the step methods are only called at this point.\n    4. The anonymous traversal is now ready to be run.\n    \"\"\"\n    def __init__(self, initial_deferred_step:Tuple[Callable[..., Step], Tuple, Dict]):\n        self.query_steps:list[Step] = None #we want to make sure that an error is raised if this is accessed before the anonymous traversal is build.\n        self.graph = None\n        self.terminated = False\n        self._needs_path = False\n        self._initial_step = initial_deferred_step\n        self._step_templates = []\n\n    # we need this since anonymous traversals need to check this before they're run.\n    # this is a very tricky part, since `query_steps` is undefined until the anonymous traversal is build.\n    @property\n    def needs_path(self):\n        return self._needs_path or any((s.needs_path for s in self.query_steps))\n\n    @needs_path.setter\n    def needs_path(self, value):\n        self._needs_path = value\n\n    def number_of_steps(self, recursive = False):\n        if self.query_steps is None:\n            if recursive:\n                logger.warning(\"Anonymous traversal has not been built yet, cannot count steps.\")\n            return 1+len(self._step_templates)\n        else:\n            return super().number_of_steps(recursive)\n\n    def run(self):\n        raise ValueError(\"Cannot run anonymous traversals\")   \n\n    def _build(self, traversal: Traversal):\n        # first, set the necessary fields\n        self.graph = traversal.graph\n        self.eager = traversal.eager\n        self.use_mp = traversal.use_mp\n        self.verify_query = traversal.verify_query\n        self.optimize = traversal.optimize\n        # then, build the steps\n        self.query_steps = []\n        init_step_func, init_args, init_kwargs = self._initial_step\n        init_step = init_step_func(*init_args, **init_kwargs)\n        init_step.traversal = self\n        self.query_steps.append(init_step)\n        for step, args, kwargs in self._step_templates:\n            step(*args, **kwargs) #this is the step function\n        for step in self.query_steps:\n            step.build()\n        self.needs_path = any([s.needs_path for s in self.query_steps])\n        if traversal.optimize:\n            self._optimize_query()\n        if self.verify_query:\n            self._verify_query()\n        if self.query_steps[0].isstart:\n            self.query_steps[0].set_traversal(self)\n        super()._build()\n\n    def __call__(self, traversers: Iterable[\"Traverser\"]) -&gt; Iterable[\"Traverser\"]:\n        # if this traversal is empty, just reflect back the incoming traversers\n        if len(self.query_steps) == 0:\n            return traversers\n        self.traversers = traversers\n        if self.eager:\n            try:\n                for step in self.query_steps:\n                    logger.debug(\"Running step in anonymous traversal:\" + str(step))\n                    self.traversers = step(self.traversers)\n                    if not type(self.traversers) is list:\n                        self.traversers = list(self.traversers)\n            except Exception as e:\n                raise GraphTraversalError(\n                    f\"Something went wrong in step {step.print_query()}\"\n                )\n        else:\n            for step in self.query_steps:\n                logger.debug(\"Running step:\" + str(step))\n                self.traversers = step(self.traversers)\n            # TODO: Try to do some fancy error handling\n        return self.traversers\n\n    def __getattribute__(self, name):\n        attr = super().__getattribute__(name)\n        if callable(attr) and getattr(attr, \"_is_step_method\", False):\n            if getattr(attr, \"_anonymous\", True):\n                logger.debug(\"Returning lambda for anonymous step \" + attr.__name__)\n                def deferred_step(*args, **kwargs):\n                    self._step_templates.append((attr, args, kwargs))\n                    return self\n                return deferred_step\n            else:\n                raise QueryError(f\"Step {name} is not allowed in anonymous traversals\")\n        return attr\n\n    def print_query(self):\n        def format_args(step, args, kwargs):\n            step_str = f\"{step.__name__}\"\n            args_str, kwarg_str = None, None\n            if len(args) &gt; 0:\n                args_str = \", \".join(str(x) for x in args)\n            if len(kwargs) &gt; 0:\n                kwarg_str = \", \".join(f\"{key}={val}\" for key, val in kwargs.items())\n            if args_str and kwarg_str:\n                step_str += f\"({args_str}, {kwarg_str})\"\n            elif args_str:\n                step_str += f\"({args_str})\"\n            elif kwarg_str:\n                step_str += f\"({kwarg_str})\"\n            return step_str\n        texts = [format_args(*self._initial_step)]\n        texts += [format_args(step, args, kwargs) for step, args, kwargs in self._step_templates]\n        return \" -&gt; \".join(texts)\n</code></pre>"},{"location":"#mogwai.core.traversal.MogwaiGraphTraversalSource","title":"<code>MogwaiGraphTraversalSource</code>","text":"<p>see https://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversalSource.html</p> <p>A GraphTraversalSource is the primary DSL of the Gremlin traversal machine. It provides access to all the configurations and steps for Turing complete graph computing. Any DSL can be constructed based on the methods of both GraphTraversalSource and GraphTraversal.</p> Source code in <code>mogwai/core/traversal.py</code> <pre><code>class MogwaiGraphTraversalSource:\n    \"\"\"\n    see https://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversalSource.html\n\n    A GraphTraversalSource is the primary DSL of the Gremlin traversal machine.\n    It provides access to all the configurations and steps\n    for Turing complete graph computing.\n    Any DSL can be constructed based on the methods of both GraphTraversalSource\n    and GraphTraversal.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        connector: MogwaiGraph,\n        eager: bool = False,\n        optimize: bool = True,\n        use_mp: bool = USE_MULTIPROCESSING,\n    ):\n        self.connector = connector\n        self.traversal_args = dict(\n            optimize=optimize, eager=eager, query_verify=True, use_mp=use_mp\n        )\n\n    def E(self, *init:Tuple[str]|List[Tuple[str]]) -&gt; 'Traversal':\n        from .steps.start_steps import E\n        if len(init) == 0: init = None\n        elif len(init) == 1: init = init[0]\n        return Traversal(self, start=E(self.connector, init), **self.traversal_args)\n\n    def V(self, *init:str) -&gt; 'Traversal':\n        from .steps.start_steps import V\n        if len(init) == 0: init = None\n        elif len(init) == 1: init = init[0]\n        return Traversal(self, start=V(self.connector, init), **self.traversal_args)\n\n    def addE(\n        self, relation: str, from_: str = None, to_: str = None, **kwargs\n    ) -&gt; \"Traversal\":\n        from .steps.start_steps import AddE\n\n        return Traversal(\n            self,\n            start=AddE(self.connector, relation, from_=from_, to_=to_, **kwargs),\n            **self.traversal_args,\n        )\n\n    def addV(self, label: str | Set[str], name: str = \"\", **kwargs) -&gt; \"Traversal\":\n        from .steps.start_steps import AddV\n\n        return Traversal(\n            self,\n            start=AddV(self.connector, label, name, **kwargs),\n            **self.traversal_args,\n        )\n</code></pre>"},{"location":"#mogwai.core.traversal.Traversal","title":"<code>Traversal</code>","text":"<p>see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traversal.html</p> <p>This class represents the base class for all traversals. Each traversal is a directed walk over a graph, executed using an iterator-based traversal. You shouldn't create instances of this class directly, but instead use a Traversal Source, (e.g. the <code>MogwaiGraphTraversalSource</code>) to create a new traversal. Then, you can chain traversal steps to create a query that will be executed when you call the <code>run()</code> method.</p> Source code in <code>mogwai/core/traversal.py</code> <pre><code>@add_camel_case_methods\nclass Traversal:\n    \"\"\"\n    see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traversal.html\n\n    This class represents the base class for all traversals. Each traversal is a directed walk over a graph, executed\n    using an iterator-based traversal.\n    You shouldn't create instances of this class directly, but instead use a Traversal Source, (e.g. the `MogwaiGraphTraversalSource`)\n    to create a new traversal.\n    Then, you can chain traversal steps to create a query that will be executed when you call the `run()` method.\n    \"\"\"\n\n    #the following comment is misleading as it does not apply to this specific Traversal class\n    \"\"\"\n    see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traversal.html\n\n    A Traversal represents a directed walk over a Graph.\n    This is the base interface for all traversals,\n    where each extending interface is seen as a domain\n    specific language. For example, GraphTraversal\n    is a domain specific language for traversing a graph\n    using \"graph concepts\" (e.g. vertices, edges).\n\n    A Traversal is evaluated in one of two ways:\n    iterator-based OLTP or GraphComputer-based OLAP.\n    OLTP traversals leverage an iterator and are executed\n    within a single execution environment (e.g. JVM)\n    (with data access allowed to be remote).\n\n    OLAP traversals leverage GraphComputer and are executed\n    between multiple execution environments (e.g.JVMs) (and/or cores).\n    \"\"\"\n    __steps__ = set()\n\n    def __init__(\n        self,\n        source: \"MogwaiGraphTraversalSource\",\n        start: \"Step\",\n        optimize: bool = True,\n        eager: bool = False,\n        query_verify: bool = False,\n        use_mp: bool = False,\n    ):\n        if start is None:\n            raise QueryError(\"start step cannot be None\")\n        self.query_steps = [start]\n        if not self.query_steps[0].isstart:\n            raise QueryError(\n                \"The first step should be a start-step, got \" + str(self.query_steps[0])\n            )\n        self.graph = source.connector\n        self.terminated = False\n        self.eager = eager\n        self.use_mp = use_mp\n        self.verify_query = query_verify\n        self.optimize = optimize\n        self.max_iteration_depth = DEFAULT_ITERATION_DEPTH\n\n    def number_of_steps(self, recursive:bool=False) -&gt; int:\n        if recursive:\n            return sum([step.number_of_steps(recursive=True) for step in self.query_steps])\n        return len(self.query_steps)\n\n    def _add_step(self, step: \"Step\"):\n        if self.terminated:\n            raise QueryError(\"Cannot add steps to a terminated traversal.\")\n        self.query_steps.append(step)\n        if step.isterminal:\n            self.terminated = True\n\n    ## ===== FILTER STEPS ======\n    @step_method()\n    def filter_(self, condition: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.filter_steps import Filter\n        self._add_step(Filter(self, condition))\n        return self\n\n    @step_method()\n    def has(self, *args) -&gt; \"Traversal\":\n        \"\"\"\n        Filter traversers based on whether they have the given properties.\n        * If one argument is given, it is assumed to be a key, and the step checks if a property with that key exists, regardless of its value.\n        * If two arguments are given, it is assumed to be a key and a value, and the step checks if a property with that key exists and has the given value.\n        * If three arguments are given, the first argument is assumed to be a label, and the step checks if a property with the given key and value exists on an element with that label.\n        \"\"\"\n        # if `key` is a list, like ['a', 'b'], the value will be compared to data['a']['b']\n        from .steps.filter_steps import Has\n\n        if len(args) == 1:\n            key, value = args[0], None\n            self._add_step(Has(self, key, value))\n        elif len(args) == 2:\n            key, value = args\n            self._add_step(Has(self, key, value))\n        elif len(args) == 3:\n            label, key, value = args\n            self._add_step(Has(self, key, value, label=label))\n        else:\n            raise QueryError(\"Invalid number of arguments for `has`\")\n        return self\n\n    @step_method()\n    def has_not(self, key: str):\n        from .steps.filter_steps import HasNot\n\n        self._add_step(HasNot(self, key))\n        return self\n\n    @step_method()\n    def has_key(self, *keys: str):\n        from .steps.filter_steps import HasKey\n\n        self._add_step(HasKey(self, *keys))\n        return self\n\n    @step_method()\n    def has_value(self, *values: Any) -&gt; \"Traversal\":\n        from .steps.filter_steps import HasValue\n\n        self._add_step(HasValue(self, *values))\n        return self\n\n    @step_method()\n    def has_id(self, *ids: str | tuple) -&gt; \"Traversal\":\n        from .steps.filter_steps import HasId\n\n        self._add_step(HasId(self, *ids))\n        return self\n\n    @step_method()\n    def has_name(self, *name: str) -&gt; \"Traversal\":\n        if len(name) == 0:\n            raise QueryError(\"No name provided for `has_name`\")\n        elif len(name) == 1:\n            return self.has(\"name\", name[0])\n        elif len(name) &gt; 1:\n            from .steps.filter_steps import HasWithin\n\n            self._add_step(HasWithin(self, \"name\", name))\n            return self\n\n    @step_method()\n    def has_label(self, label: str | Set[str]) -&gt; \"Traversal\":\n        if isinstance(label, set):\n            from .steps.filter_steps import ContainsAll\n\n            self._add_step(ContainsAll(self, \"labels\", label))\n        else:\n            from .steps.filter_steps import Contains\n\n            self._add_step(Contains(self, \"labels\", label))\n        return self\n\n    @step_method()\n    def is_(self, condition: Any) -&gt; \"Traversal\":\n        from .steps.filter_steps import Is\n\n        self._add_step(Is(self, condition))\n        return self\n\n    @step_method()\n    def contains(self, key: str | List[str], value: Any) -&gt; \"Traversal\":\n        if isinstance(value, list):\n            from .steps.filter_steps import ContainsAll\n\n            self._add_step(ContainsAll(self, key, value))\n        else:\n            from .steps.filter_steps import Contains\n\n            self._add_step(Contains(self, key, value))\n        return self\n\n    @step_method()\n    def within(self, key: str | List[str], options: List[Any]) -&gt; \"Traversal\":\n        from .steps.filter_steps import Within\n\n        self._add_step(Within(self, key, options))\n        return self\n\n    @step_method()\n    def simple_path(self, by: str | List[str] = None) -&gt; \"Traversal\":\n        from .steps.filter_steps import SimplePath\n\n        self._add_step(SimplePath(self, by=by))\n        return self\n\n    @step_method()\n    def limit(self, n: int) -&gt; \"Traversal\":\n        from .steps.filter_steps import Range\n\n        self._add_step(Range(self, 0, n))\n        return self\n\n    @step_method()\n    def range(self, start: int, end: int) -&gt; \"Traversal\":\n        from .steps.filter_steps import Range\n\n        self._add_step(Range(self, start, end))\n        return self\n\n    @step_method()\n    def skip(self, n: int) -&gt; \"Traversal\":\n        from .steps.filter_steps import Range\n\n        self._add_step(Range(self, n, -1))\n        return self\n\n    @step_method()\n    def dedup(self, by: str | List[str] = None) -&gt; \"Traversal\":\n        from .steps.filter_steps import Dedup\n\n        self._add_step(Dedup(self, by=by))\n        return self\n\n    @step_method()\n    def not_(self, condition: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.filter_steps import Not\n\n        self._add_step(Not(self, condition))\n        return self\n\n    @step_method()\n    def and_(self, A: \"AnonymousTraversal\", B: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.filter_steps import And\n\n        self._add_step(And(self, A, B))\n        return self\n\n    @step_method()\n    def or_(self, A: \"AnonymousTraversal\", B: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.filter_steps import Or\n\n        self._add_step(Or(self, A, B))\n        return self\n\n    ## ===== MAP STEPS ======\n    @step_method()\n    def identity(self) -&gt; \"Traversal\":  # required for math reasons\n        return self\n\n    @step_method()\n    def id_(self) -&gt; 'Traversal':\n        from .steps.map_steps import Id\n        self._add_step(Id(self))\n        return self\n\n    # Important: `value` extract values from *Property's*\n    # `values` extracts values from *elements*!\n    # So, .properties(key).value() is the same as .values(key)\n    @step_method()\n    def value(self) -&gt; \"Traversal\":\n        from .steps.map_steps import Value\n\n        self._add_step(Value(self))\n        return self\n\n    @step_method()\n    def key(self) -&gt; \"Traversal\":\n        from .steps.map_steps import Key\n\n        self._add_step(Key(self))\n        return self\n\n    @step_method()\n    def values(self, *keys: str | List[str]) -&gt; \"Traversal\":\n        from .steps.map_steps import Values\n\n        self._add_step(Values(self, *keys))\n        return self\n\n    @step_method()\n    def name(self) -&gt; \"Traversal\":\n        return self.values(\"name\")\n\n    @step_method()\n    def label(self) -&gt; \"Traversal\":\n        return self.values(\"labels\")\n\n    @step_method()\n    def properties(self, *keys: str | List[str]) -&gt; \"Traversal\":\n        from .steps.map_steps import Properties\n\n        self._add_step(Properties(self, *keys))\n        return self\n\n    @step_method()\n    def select(self, *args: str, by: str = None) -&gt; \"Traversal\":\n        from .steps.map_steps import Select\n\n        self._add_step(\n            Select(self, keys=args[0] if len(args) == 1 else list(args), by=by)\n        )\n        return self\n\n    @step_method()\n    def order(\n        self,\n        by: str | List[str] | EnumOrder | \"AnonymousTraversal\" = None,\n        asc: bool | None = None,\n        **kwargs,\n    ) -&gt; \"Traversal\":\n        from .steps.map_steps import Order\n        if isinstance(by, EnumOrder):\n            if asc is not None:\n                raise QueryError(\"Cannot provide `asc` argument when `by` is an Order\")\n            self._add_step(Order(self, order=by, **kwargs))\n        else:\n            self._add_step(Order(self, by, asc=asc, **kwargs))\n        return self\n\n    @step_method()\n    def fold(self, seed:Any=None, foldfunc:Callable[[Any,Any],Any]=None):\n        from .steps.map_steps import Fold\n        self._add_step(Fold(self, seed, foldfunc))\n        return self\n\n    @step_method()\n    def count(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Count\n\n        self._add_step(Count(self, scope))\n        return self\n\n    @step_method()\n    def path(self, by: str | List[str] = None) -&gt; \"Traversal\":\n        from .steps.map_steps import Path\n\n        self._add_step(Path(self, by=by))\n        return self\n\n    @step_method()\n    def max_(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Max\n\n        self._add_step(Max(self, scope))\n        return self\n\n    @step_method()\n    def min_(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Min\n\n        self._add_step(Min(self, scope))\n        return self\n\n    @step_method()\n    def sum_(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Aggregate\n\n        self._add_step(Aggregate(self, \"sum\", scope))\n        return self\n\n    @step_method()\n    def mean(self, scope: Scope = Scope.global_) -&gt; \"Traversal\":\n        from .steps.map_steps import Aggregate\n\n        self._add_step(Aggregate(self, \"mean\", scope))\n        return self\n\n    @step_method()\n    def element_map(self, *keys: str) -&gt; \"Traversal\":\n        from .steps.map_steps import ElementMap\n\n        if len(keys) == 1:\n            keys = keys[0]\n        elif len(keys) == 0:\n            keys = None\n        self._add_step(ElementMap(self, keys))\n        return self\n\n    ## ===== FLATMAP STEPS ======\n    @step_method()\n    def out(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import Out\n\n        self._add_step(Out(self, direction))\n        return self\n\n    @step_method()\n    def outE(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import OutE\n\n        self._add_step(OutE(self, direction))\n        return self\n\n    @step_method()\n    def outV(self) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import OutV\n\n        self._add_step(OutV(self))\n        return self\n\n    @step_method()\n    def in_(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import In\n\n        self._add_step(In(self, direction))\n        return self\n\n    @step_method()\n    def inE(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import InE\n\n        self._add_step(InE(self, direction))\n        return self\n\n    @step_method()\n    def inV(self) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import InV\n\n        self._add_step(InV(self))\n        return self\n\n    @step_method()\n    def both(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import Both\n\n        self._add_step(Both(self, direction))\n        return self\n\n    @step_method()\n    def bothE(self, direction: str = None) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import BothE\n\n        self._add_step(BothE(self, direction))\n        return self\n\n    @step_method()\n    def bothV(self) -&gt; \"Traversal\":\n        from .steps.flatmap_steps import BothV\n\n        self._add_step(BothV(self))\n        return self\n\n    ## ===== BRANCH STEPS =====\n    @step_method()\n    @with_call_order\n    def repeat(\n        self,\n        do: \"Traversal\",\n        times: int | None = None,\n        until: \"AnonymousTraversal|None\" = None,\n        **kwargs,\n    ) -&gt; \"Traversal\":\n        from .steps.branch_steps import Repeat\n        from .steps.modulation_steps import Temp\n\n        if until is not None:\n            until_do = (\n                len(kwargs.get(\"_order\", [])) &gt; 0 and kwargs[\"_order\"][0] == \"until\"\n            )\n        else:\n            until_do = None\n\n        step = Repeat(self, do, times=times, until=until, until_do=until_do)\n        while isinstance((prevstep := self.query_steps[-1]), Temp):\n            if prevstep.kwargs[\"type\"] == \"emit\":\n                step.emit = prevstep.kwargs[\"filter\"]\n                step.emit_before = True\n            elif prevstep.kwargs[\"type\"] == \"until\":\n                if until is not None or times is not None:\n                    raise QueryError(\n                        \"Provided `until` to repeat when `times` or `until` was already set.\"\n                    )\n                step.until = prevstep.kwargs[\"cond\"]\n                step.until_do = True\n            else:\n                break\n            self.query_steps.pop(-1)  # remove the temporary step\n        self._add_step(step)\n        return self\n\n    @step_method()\n    def local(self, localTrav: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.branch_steps import Local\n\n        self._add_step(Local(self, localTrav))\n        return self\n\n    @step_method()\n    def branch(self, branchFunc: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.branch_steps import Branch\n        if branchFunc.number_of_steps() == 0:\n            raise QueryError(\"No steps provided for branch function\")\n        self._add_step(Branch(self, branchFunc))\n        return self\n\n    @step_method()\n    def union(self, *traversals: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.branch_steps import Union\n\n        self._add_step(Union(self, *traversals))\n        return self\n\n    ## ===== SIDE EFFECT STEPS ======\n    @step_method()\n    def side_effect(\n        self, side_effect: \"AnonymousTraversal|Callable[[Traverser], None]\"\n    ) -&gt; \"Traversal\":\n        from .steps.base_steps import SideEffectStep\n\n        self._add_step(SideEffectStep(self, side_effect))\n        return self\n\n    @step_method()\n    def property(self, *args) -&gt; 'Traversal':\n        from .steps.base_steps import SideEffectStep\n        if len(args)==2:\n            key, value = args\n            if key==Cardinality.label:\n                key = \"labels\"\n                value = set(value) if isinstance(value, (list,tuple, set, dict)) else {value}\n        elif len(args)==3:\n            cardinality, key, value = args\n            match cardinality:\n                case Cardinality.set_: value = set(value) if isinstance(value, (list,tuple, set, dict)) else {value}\n                case Cardinality.list_: value = list(value) if isinstance(value, (list,tuple, set, dict)) else [value]\n                case Cardinality.map_ | Cardinality.dict_: pass #we keep the value as a value\n                case _:\n                    raise ValueError(\"Invalid cardinality for property, expected `set`, `list`, `map` or `dict`\")\n        else:\n            raise ValueError(\"Invalid number of arguments for `property`, expected signature (cardinality, key, value) or (key, value)\")\n        if isinstance(key, (tuple, list)):\n            indexer = tu.get_dict_indexer(key[:-1])\n            key = key[-1]\n        else:\n            indexer = lambda x: x\n\n        def effect(t: \"Traverser\"):\n            indexer(self._get_element(t))[key] = value\n\n        self._add_step(SideEffectStep(self, side_effect=effect))\n        return self\n\n     ## ===== IO =====\n    @step_method(not_anonymous=True)\n    def io(self, file_path: str, read: bool = None, write: bool = None) -&gt; \"Traversal\":\n        from .steps.io_step import IO\n        if read is not None and write is not None:\n            if not read ^ write:\n                raise QueryError(\"read and write cannot be both true or both false\")\n        self._add_step(IO(self, file_path, read=read, write=write))\n        return self\n\n    ## ===== MODULATION STEPS ======\n    @step_method()\n    def option(self, branchKey, option_trav: \"AnonymousTraversal\") -&gt; \"Traversal\":\n        from .steps.branch_steps import Branch\n\n        branchStep = self.query_steps[len(self.query_steps) - 1]\n        if type(branchStep) is Branch:\n            if branchKey is not None:\n                branchStep.add_option(branchKey, option_trav)\n            else:\n                branchStep.set_default(option_trav)\n            return self\n        else:\n            raise QueryError(\"Option can only be used after Branch step\")\n\n    @step_method()\n    def until(self, cond: \"AnonymousTraversal\"):\n        from .steps.branch_steps import Repeat\n\n        prevstep = self.query_steps[-1]\n        if isinstance(prevstep, Repeat):\n            if prevstep.until is None and prevstep.times is None:\n                prevstep.until = cond\n                prevstep.until_do = False\n            else:\n                raise QueryError(\n                    \"Provided `until` to repeat when `times` or `until` was already set.\"\n                )\n        else:\n            from .steps.modulation_steps import Temp\n\n            self._add_step(Temp(self, type=\"until\", cond=cond))\n        return self\n\n    @step_method()\n    def times(self, reps: int):\n        from .steps.branch_steps import Repeat\n\n        prevstep = self.query_steps[-1]\n        if isinstance(prevstep, Repeat):\n            if prevstep.times is None and prevstep.until is None:\n                prevstep.times = reps\n            else:\n                raise QueryError(\n                    \"Provided `times` to repeat when `times` or `until` was already set.\"\n                )\n        else:\n            raise QueryError(\n                f\"`times` modulation is not supported by step {prevstep.print_query()}\"\n            )\n        return self\n\n    @step_method()\n    def emit(self, filter: \"AnonymousTraversal|None\" = None):\n        from .steps.branch_steps import Repeat\n\n        prevstep = self.query_steps[-1]\n        if isinstance(prevstep, Repeat):\n            if prevstep.emit is None:\n                prevstep.emit = filter or True\n                prevstep.emit_before = False\n            else:\n                raise QueryError(\n                    \"Provided `emit` to repeat when `emit` was already set.\"\n                )\n        else:\n            from .steps.modulation_steps import Temp\n\n            self._add_step(Temp(self, type=\"emit\", filter=filter or True))\n        return self\n\n    @step_method()\n    def as_(self, name: str) -&gt; \"Traversal\":\n        from .steps.modulation_steps import As\n\n        self._add_step(As(self, name))\n        return self\n\n    @step_method()\n    def by(self, key: str | List[str] | \"AnonymousTraversal\", *args) -&gt; \"Traversal\":\n        prev_step = self.query_steps[-1]\n        if prev_step.supports_by:\n            if isinstance(key, AnonymousTraversal):\n                if not prev_step.supports_anonymous_by:\n                    raise QueryError(\n                        f\"Step `{prev_step.print_query()}` does not support anonymous traversals as by-modulations.\"\n                    )\n            elif type(key) is not str:\n                if isinstance(key, EnumOrder) and prev_step.__class__.__name__==\"Order\":\n                    pass\n                else:\n                    raise QueryError(\"Invalid key type for by-modulation\")\n\n            if prev_step.supports_multiple_by:\n                prev_step.by.append(key)\n            elif prev_step.by is None:\n                prev_step.by = key if len(args)==0 else (key, *args)\n            else:\n                raise QueryError(\n                    f\"Step `{prev_step.print_query()}` does not support multiple by-modulations.\"\n                )\n        else:\n            raise QueryError(\n                f\"Step `{prev_step.print_query()}` does not support by-modulation.\"\n            )\n        return self\n\n    @step_method()\n    def from_(self, src: str) -&gt; \"Traversal\":\n        prev_step = self.query_steps[-1]\n        if prev_step.supports_fromto:\n            if type(src) is not str:\n                raise QueryError(f\"Invalid source type `{type(src)}` for from-modulation: str needed!\")\n            if prev_step.from_ is None:\n                prev_step.from_ = src\n            else:\n                raise QueryError(\n                    f\"Step `{prev_step.print_query()}` does not support multiple from-modulations.\"\n                )\n        else:\n            raise QueryError(\n                f\"Step `{prev_step.print_query()}` does not support from-modulation.\"\n            )\n        return self\n\n    @step_method()\n    def to_(self, dest: str) -&gt; \"Traversal\":\n        prev_step = self.query_steps[-1]\n        if prev_step.supports_fromto:\n            if type(dest) is not str:\n                raise QueryError(\"Invalid source type for to-modulation: str needed!\")\n            if prev_step.to_ is None:\n                prev_step.to_ = dest\n            else:\n                raise QueryError(\n                    f\"Step `{prev_step.print_query()}` does not support multiple to-modulations.\"\n                )\n        else:\n            raise QueryError(\n                f\"Step `{prev_step.print_query()}` does not support to-modulation.\"\n            )\n        return self\n\n    @step_method()\n    def with_(self, *args) -&gt; \"Traversal\":\n        prev_step = self.query_steps[-1]\n        if prev_step.flags &amp; Step.SUPPORTS_WITH:\n            if prev_step.with_ is None:\n                prev_step.with_ = args\n            else:\n                raise QueryError(\n                    f\"Step `{prev_step.print_query()}` does not support multiple with-modulations.\"\n                )\n        else:\n            raise QueryError(\n                f\"Step `{prev_step.print_query()}` does not support with-modulation.\"\n            )\n        return self\n\n    @step_method(not_anonymous=True)\n    def read(self) -&gt;  \"Traversal\":\n        from .steps.io_step import IO\n        prev_step = self.query_steps[-1]\n        if isinstance(prev_step, IO):\n            prev_step.read = True\n        else:\n            raise QueryError(f\"the read() step can only be used after an IO step.\")\n        return self\n\n    @step_method(not_anonymous=True)\n    def write(self) -&gt;  \"Traversal\":\n        from .steps.io_step import IO\n        prev_step = self.query_steps[-1]\n        if isinstance(prev_step, IO):\n            prev_step.write = True\n        else:\n            raise QueryError(f\"the write() step can only be used after an IO step.\")\n        return self\n\n    ## ===== TERMINAL STEPS ======\n    @step_method(not_anonymous=True)\n    def to_list(\n        self, by: List[str] | str = None, include_data: bool = False\n    ) -&gt; \"Traversal\":\n        # terminal step\n        from .steps.terminal_steps import ToList\n\n        self._add_step(ToList(self, by=by, include_data=include_data))\n        return self\n\n    @step_method(not_anonymous=True)\n    def as_path(self, by: List[str] | str = None) -&gt; \"Traversal\":\n        # terminal step\n        from .steps.terminal_steps import AsPath\n\n        self._add_step(AsPath(self, by=by))\n        return self\n\n    @step_method(not_anonymous=True)\n    def has_next(self) -&gt; \"Traversal\":\n        from .steps.terminal_steps import HasNext\n\n        self._add_step(HasNext(self))\n        return self\n\n    @step_method(not_anonymous=True)\n    def next(self, n:int=1) -&gt; 'Traversal':\n        from .steps.terminal_steps import Next\n        self._add_step(Next(self, amount=n))\n        return self\n\n    @step_method(not_anonymous=True)\n    def iter(\n        self, by: str | List[str] = None, include_data: bool = False\n    ) -&gt; \"Traversal\":\n        from .steps.terminal_steps import AsGenerator\n\n        self._add_step(AsGenerator(self, by=by, include_data=include_data))\n        return self\n\n    @step_method(not_anonymous=True)\n    def iterate(self) -&gt; \"Traversal\":\n        from .steps.terminal_steps import Iterate\n\n        self._add_step(Iterate(self))\n        return self\n\n    def _optimize_query(self):\n        pass\n\n    def _verify_query(self):\n        from .steps.modulation_steps import Temp\n\n        for step in self.query_steps:\n            if isinstance(step, Temp):\n                raise QueryError(f\"Remaining modulation step of type `{step['type']}`\")\n        return True\n\n    def _build(self):\n        for step in self.query_steps:\n            step.build()\n\n    def run(self) -&gt; Any:\n        # first, provide the start step with this traversal\n        self.traversers = []\n        self.query_steps[0].set_traversal(self)\n        self._build()\n        self.needs_path = any([s.needs_path for s in self.query_steps])\n        if self.optimize:\n            self._optimize_query()\n        self._verify_query()\n        if self.eager:\n            try:\n                for step in self.query_steps:\n                    logger.debug(\"Running step:\" + str(step))\n                    self.traversers = step(self.traversers)\n                    if not type(self.traversers) is list and not step.isterminal: # terminal steps could produce any type of output\n                        self.traversers = list(self.traversers)\n            except Exception as e:\n                raise GraphTraversalError(\n                    f\"Something went wrong in step {step.print_query()}\"\n                )\n        else:\n            for step in self.query_steps:\n                logger.debug(\"Running step:\" + str(step))\n                self.traversers = step(self.traversers)\n            # TODO: Try to do some fancy error handling\n        return self.traversers\n\n    def _get_element(self, traverser: \"Traverser\", data: bool = False):\n        if type(traverser) == Traverser:\n            if data:\n                return (\n                    self.graph.edges[traverser.get]\n                    if traverser.is_edge\n                    else self.graph.nodes(data=data)[traverser.get]\n                )\n            return (\n                self.graph.edges[traverser.get]\n                if traverser.is_edge\n                else self.graph.nodes[traverser.get]\n            )\n        else:\n            raise GraphTraversalError(\n                \"Cannot get element from value or property traverser.\"\n                + \" Probably you are performing a step that can only be executed on graph elements on a value or property traverser.\"\n            )\n\n    def _get_element_from_id(self, element_id: str | tuple):\n        if isinstance(element_id, tuple):\n            node = self.graph.edges[element_id]\n        else:\n            node = self.graph.nodes[element_id]\n        return node\n\n    def print_query(self) -&gt; str:\n        text = \" -&gt; \".join([x.print_query() for x in self.query_steps])\n        return text\n\n    def __str__(self) -&gt; str:\n        return self.print_query()\n</code></pre>"},{"location":"#mogwai.core.traversal.Traversal.has","title":"<code>has(*args)</code>","text":"<p>Filter traversers based on whether they have the given properties. * If one argument is given, it is assumed to be a key, and the step checks if a property with that key exists, regardless of its value. * If two arguments are given, it is assumed to be a key and a value, and the step checks if a property with that key exists and has the given value. * If three arguments are given, the first argument is assumed to be a label, and the step checks if a property with the given key and value exists on an element with that label.</p> Source code in <code>mogwai/core/traversal.py</code> <pre><code>@step_method()\ndef has(self, *args) -&gt; \"Traversal\":\n    \"\"\"\n    Filter traversers based on whether they have the given properties.\n    * If one argument is given, it is assumed to be a key, and the step checks if a property with that key exists, regardless of its value.\n    * If two arguments are given, it is assumed to be a key and a value, and the step checks if a property with that key exists and has the given value.\n    * If three arguments are given, the first argument is assumed to be a label, and the step checks if a property with the given key and value exists on an element with that label.\n    \"\"\"\n    # if `key` is a list, like ['a', 'b'], the value will be compared to data['a']['b']\n    from .steps.filter_steps import Has\n\n    if len(args) == 1:\n        key, value = args[0], None\n        self._add_step(Has(self, key, value))\n    elif len(args) == 2:\n        key, value = args\n        self._add_step(Has(self, key, value))\n    elif len(args) == 3:\n        label, key, value = args\n        self._add_step(Has(self, key, value, label=label))\n    else:\n        raise QueryError(\"Invalid number of arguments for `has`\")\n    return self\n</code></pre>"},{"location":"#mogwai.core.traverser","title":"<code>traverser</code>","text":"<p>Created on 2024</p> <p>@author: Joep Geuskens</p>"},{"location":"#mogwai.core.traverser.Traverser","title":"<code>Traverser</code>","text":"<p>               Bases: <code>BaseTraverser</code></p> <p>see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traverser.html</p> <p>A Traverser represents the current state of an object flowing through a Traversal.</p> <p>A traverser maintains a reference to the current object, a traverser-local \"sack\", a traversal-global sideEffect, a bulk count, and a path history.</p> <p>Different types of traversers can exist depending on the semantics of the traversal and the desire for space/time optimizations of the developer.</p> Source code in <code>mogwai/core/traverser.py</code> <pre><code>class Traverser(BaseTraverser):\n    \"\"\"\n    see https://tinkerpop.apache.org/javadocs/3.7.3/core/org/apache/tinkerpop/gremlin/process/traversal/Traverser.html\n\n    A Traverser represents the current state of an object\n    flowing through a Traversal.\n\n    A traverser maintains a reference to the current object,\n    a traverser-local \"sack\",\n    a traversal-global sideEffect, a bulk count,\n    and a path history.\n\n    Different types of traversers can exist\n    depending on the semantics of the traversal\n    and the desire for space/time optimizations of\n    the developer.\n    \"\"\"\n\n    def __init__(\n        self, node_id: str, other_node_id: str = None, track_path: bool = False\n    ):\n        super().__init__(track_path=track_path)\n        self.node_id = node_id\n        self.track_path = track_path\n        self.target = other_node_id\n        self.path = [self.get] if track_path else None\n\n    def move_to_edge(self, source: str, target: str) -&gt; None:\n        self.node_id = source\n        self.target = target\n        if self.track_path:\n            self.path.append((source, target))\n\n    @property\n    def get(self) -&gt; str | tuple:\n        return (self.node_id, self.target) if self.is_edge else self.node_id\n\n    @property\n    def source(self) -&gt; str:\n        return self.node_id\n\n    @property\n    def is_edge(self) -&gt; bool:\n        return self.target is not None\n\n    def save(self, key):\n        if self.is_edge:\n            to_store = Traverser(*self.get, track_path=self.track_path)\n        else:\n            to_store = Traverser(self.get, track_path=self.track_path)\n\n        to_store.cache = self.cache.copy()  # no need to deep copies\n        self.cache[\"__store__\"][key] = to_store\n\n    def load(self, key):\n        # logger.debug(f\"Cache: {self.cache['__store__'].keys()}\")\n        try:\n            return self.cache[\"__store__\"][key]\n        except KeyError:\n            raise ValueError(\n                f\"No object `{key}` was saved in this traverser. Use .as('{key}') to save traversal steps.\"\n            )\n\n    def get_cache(self, key):\n        return self.cache.get(key, None)\n\n    def set(self, key: str, val: Any):\n        assert key != \"__store__\", \"`__store__` is a reserved key\"\n        self.cache[key] = val\n\n    def move_to(self, node_id: str) -&gt; \"Traverser\":\n        # logging.debug(\"Moving traverser from\", self.get, \"to\", node_id)\n        self.node_id = node_id\n        self.target = None\n        if self.track_path:\n            self.path.append(node_id)\n        return self\n\n    def copy(self):\n        t = Traverser(\n            node_id=self.node_id, other_node_id=self.target, track_path=self.track_path\n        )\n        t.cache = deepcopy(self.cache)\n        t.path = self.path.copy() if self.path else None\n        return t\n\n    def copy_to(self, node_id: str, other_node_id: str = None) -&gt; \"Traverser\":\n        t = self.copy()\n        if other_node_id:\n            t.move_to_edge(node_id, other_node_id)\n        else:\n            t.move_to(node_id)\n        return t\n\n    def to_value(self, val, dtype=None):\n        val = Value(val, dtype=dtype)\n        val.cache = deepcopy(self.cache)\n        if self.track_path:\n            val.path = self.path.copy()\n        return val\n\n    def to_property(self, key, val, dtype=None):\n        p = Property(key, val, dtype=dtype)\n        p.cache = deepcopy(self.cache)\n        if self.track_path:\n            p.path = self.path.copy()\n        return p\n\n    def __str__(self):\n        return f\"&lt;{self.__class__.__name__}[get={self.get}, is_edge={self.is_edge}]&gt;\"\n</code></pre>"},{"location":"#mogwai.decorators","title":"<code>decorators</code>","text":""},{"location":"#mogwai.decorators.decorators","title":"<code>decorators</code>","text":""},{"location":"#mogwai.decorators.decorators.traversal_step_doc","title":"<code>traversal_step_doc(cls)</code>","text":"<p>Decorator to copy the docstring from the init method of a class.</p> Source code in <code>mogwai/decorators/decorators.py</code> <pre><code>def traversal_step_doc(cls):\n    \"\"\"Decorator to copy the docstring from the __init__ method of a class.\"\"\"\n    def decorator(func):\n        func.__doc__ = cls.__init__.__doc__\n        return func\n    return decorator\n</code></pre>"},{"location":"#mogwai.examples","title":"<code>examples</code>","text":""},{"location":"#mogwai.examples.modern","title":"<code>modern</code>","text":"<p>Created on 2024-11-14</p> <p>@author: wf</p>"},{"location":"#mogwai.examples.modern.Person","title":"<code>Person</code>","text":"<p>a person</p> Source code in <code>mogwai/examples/modern.py</code> <pre><code>@lod_storable\nclass Person:\n    \"\"\"\n    a person\n    \"\"\"\n\n    name: str\n    age: int\n</code></pre>"},{"location":"#mogwai.examples.modern.Software","title":"<code>Software</code>","text":"<p>a software</p> Source code in <code>mogwai/examples/modern.py</code> <pre><code>@lod_storable\nclass Software:\n    \"\"\"\n    a software\n    \"\"\"\n\n    name: str\n    lang: Optional[str] = None\n</code></pre>"},{"location":"#mogwai.examples.schema","title":"<code>schema</code>","text":"<p>Created on 15.11.2024</p> <p>@author: wf</p>"},{"location":"#mogwai.examples.schema.MogwaiExampleSchema","title":"<code>MogwaiExampleSchema</code>","text":"<p>the mogwai examples schema</p> Source code in <code>mogwai/examples/schema.py</code> <pre><code>class MogwaiExampleSchema:\n    \"\"\"\n    the mogwai examples schema\n    \"\"\"\n\n    @classmethod\n    def get_yaml_path(cls) -&gt; str:\n        # Get the directory of the current script\n        script_dir = os.path.dirname(os.path.abspath(__file__))\n\n        # Set yaml_path to the \"mogwai_examples\" directory located in the parent directory of the script's location\n        yaml_path = os.path.join(\n            script_dir, \"../..\", \"mogwai_examples\", \"modern-schema.yaml\"\n        )\n\n        # Normalize the path to remove any redundant components\n        yaml_path = os.path.normpath(yaml_path)\n        return yaml_path\n</code></pre>"},{"location":"#mogwai.graph_config","title":"<code>graph_config</code>","text":"<p>Created on 2024-08-17</p> <p>@author: wf</p>"},{"location":"#mogwai.graph_config.GraphConfig","title":"<code>GraphConfig</code>","text":"<p>Configuration for a graph in the Examples class</p> Source code in <code>mogwai/graph_config.py</code> <pre><code>@lod_storable\nclass GraphConfig:\n    \"\"\"\n    Configuration for a graph in the Examples class\n    \"\"\"\n\n    name: str\n    file_path: Optional[str] = None\n    is_default: bool = False\n    node_label_key: str = \"labelV\"\n    edge_label_key: str = \"labelE\"\n    node_name_key: Optional[str] = None\n    custom_loader: Optional[str] = None  # Changed to str to store function name\n\n    def get_node_name_key(self) -&gt; Callable[[Dict[str, Any]], Any]:\n        if self.node_name_key is None:\n            return lambda x: x  # Return identity function if no key specified\n        elif isinstance(self.node_name_key, str):\n            return lambda x: x.pop(self.node_name_key, None)\n        else:\n            raise ValueError(f\"Invalid node_name_key for graph {self.name}\")\n</code></pre>"},{"location":"#mogwai.graph_config.GraphConfigs","title":"<code>GraphConfigs</code>","text":"<p>Manages a collection of GraphConfig instances</p> Source code in <code>mogwai/graph_config.py</code> <pre><code>@lod_storable\nclass GraphConfigs:\n    \"\"\"Manages a collection of GraphConfig instances\"\"\"\n\n    configs: Dict[str, GraphConfig] = field(default_factory=dict)\n</code></pre>"},{"location":"#mogwai.graphs","title":"<code>graphs</code>","text":"<p>Created on 2024-08-17</p> <p>@author: wf</p>"},{"location":"#mogwai.graphs.Graphs","title":"<code>Graphs</code>","text":"<p>Manage MogwaiGraphs</p> Source code in <code>mogwai/graphs.py</code> <pre><code>class Graphs:\n    \"\"\"\n    Manage MogwaiGraphs\n    \"\"\"\n\n    def __init__(\n        self, config_file: str = None, lazy: bool = False, debug: bool = False\n    ):\n        self.debug = debug\n        self.logger = self.get_logger()\n        self.examples_dir = os.path.join(\n            os.path.dirname(__file__), \"..\", \"mogwai_examples\"\n        )\n        if config_file is None:\n            config_file = os.path.join(self.examples_dir, \"example_graph_configs.yaml\")\n        self.config_file = config_file\n        self.graphs: Dict[str, MogwaiGraph] = {}\n\n        self.log(f\"Loading configurations from: {self.config_file}\")\n        self.configs = GraphConfigs.load_from_yaml_file(self.config_file)\n        self.log(f\"Loaded configurations: {self.configs.configs}\")\n\n        if not lazy:\n            self.load_examples()\n\n    def get_logger(self):\n        return logging.getLogger(self.__class__.__name__)\n\n    def log(self, msg: str):\n        if self.debug:\n            self.logger.debug(msg)\n\n    def load_examples(self):\n        \"\"\"Load all example graphs based on configurations\"\"\"\n        self.log(\"Loading default examples\")\n        for name, config in self.configs.configs.items():\n            if config.is_default:\n                self.log(f\"Loading default graph: {name}\")\n                self.get(name)  # This will load the graph using the existing get method\n\n    def _load_graph(self, file_path: str, config: GraphConfig) -&gt; MogwaiGraph:\n        \"\"\"Load a single graph from a .graphml file using the provided configuration\"\"\"\n        self.log(f\"Loading graph from file: {file_path}\")\n        return graphml_to_mogwaigraph(\n            file_path,\n            node_label_key=config.node_label_key,\n            edge_label_key=config.edge_label_key,\n            node_name_key=config.get_node_name_key(),\n        )\n\n    def get_names(self) -&gt; List[str]:\n        \"\"\"Get a list of available graph names\"\"\"\n        names = list(self.configs.configs.keys())\n        self.log(f\"Available graph names: {names}\")\n        return names\n\n    def get(self, name: str) -&gt; MogwaiGraph:\n        \"\"\"Get a graph by name, loading it if necessary\"\"\"\n        if name not in self.configs.configs:\n            error_msg = f\"Graph '{name}' not found in configurations\"\n            self.log(error_msg)\n            raise ValueError(error_msg)\n\n        if name not in self.graphs:\n            config = self.configs.configs[name]\n            if config.custom_loader:\n                self.log(f\"Using custom loader for graph '{name}'\")\n                # Assuming custom_loader is a string representing a method name in MogwaiGraph\n                loader = getattr(MogwaiGraph, config.custom_loader, None)\n                if loader and callable(loader):\n                    self.graphs[name] = loader()\n                else:\n                    error_msg = f\"Invalid custom loader {config.custom_loader} for graph '{name}'\"\n                    self.log(error_msg)\n                    raise ValueError(error_msg)\n            elif config.file_path:\n                file_path = os.path.join(self.examples_dir, config.file_path)\n                self.log(f\"Loading graph '{name}' from file: {file_path}\")\n                self.graphs[name] = self._load_graph(file_path, config)\n            else:\n                error_msg = f\"No loader or file path specified for graph '{name}'\"\n                self.log(error_msg)\n                raise ValueError(error_msg)\n\n        return self.graphs[name]\n</code></pre>"},{"location":"#mogwai.graphs.Graphs.get","title":"<code>get(name)</code>","text":"<p>Get a graph by name, loading it if necessary</p> Source code in <code>mogwai/graphs.py</code> <pre><code>def get(self, name: str) -&gt; MogwaiGraph:\n    \"\"\"Get a graph by name, loading it if necessary\"\"\"\n    if name not in self.configs.configs:\n        error_msg = f\"Graph '{name}' not found in configurations\"\n        self.log(error_msg)\n        raise ValueError(error_msg)\n\n    if name not in self.graphs:\n        config = self.configs.configs[name]\n        if config.custom_loader:\n            self.log(f\"Using custom loader for graph '{name}'\")\n            # Assuming custom_loader is a string representing a method name in MogwaiGraph\n            loader = getattr(MogwaiGraph, config.custom_loader, None)\n            if loader and callable(loader):\n                self.graphs[name] = loader()\n            else:\n                error_msg = f\"Invalid custom loader {config.custom_loader} for graph '{name}'\"\n                self.log(error_msg)\n                raise ValueError(error_msg)\n        elif config.file_path:\n            file_path = os.path.join(self.examples_dir, config.file_path)\n            self.log(f\"Loading graph '{name}' from file: {file_path}\")\n            self.graphs[name] = self._load_graph(file_path, config)\n        else:\n            error_msg = f\"No loader or file path specified for graph '{name}'\"\n            self.log(error_msg)\n            raise ValueError(error_msg)\n\n    return self.graphs[name]\n</code></pre>"},{"location":"#mogwai.graphs.Graphs.get_names","title":"<code>get_names()</code>","text":"<p>Get a list of available graph names</p> Source code in <code>mogwai/graphs.py</code> <pre><code>def get_names(self) -&gt; List[str]:\n    \"\"\"Get a list of available graph names\"\"\"\n    names = list(self.configs.configs.keys())\n    self.log(f\"Available graph names: {names}\")\n    return names\n</code></pre>"},{"location":"#mogwai.graphs.Graphs.load_examples","title":"<code>load_examples()</code>","text":"<p>Load all example graphs based on configurations</p> Source code in <code>mogwai/graphs.py</code> <pre><code>def load_examples(self):\n    \"\"\"Load all example graphs based on configurations\"\"\"\n    self.log(\"Loading default examples\")\n    for name, config in self.configs.configs.items():\n        if config.is_default:\n            self.log(f\"Loading default graph: {name}\")\n            self.get(name)  # This will load the graph using the existing get method\n</code></pre>"},{"location":"#mogwai.io","title":"<code>io</code>","text":""},{"location":"#mogwai.io.mogwai_io","title":"<code>mogwai_io</code>","text":""},{"location":"#mogwai.io.mogwai_io.GraphSON","title":"<code>GraphSON</code>","text":"<p>               Bases: <code>IOBackend</code></p> <p>GraphSON is a JSON-based file format for representing graphs. https://tinkerpop.apache.org/docs/3.7.2/dev/io/#graphson</p> Source code in <code>mogwai/io/mogwai_io.py</code> <pre><code>class GraphSON(IOBackend):\n    \"\"\"\n    GraphSON is a JSON-based file format for representing graphs.\n    https://tinkerpop.apache.org/docs/3.7.2/dev/io/#graphson\n    \"\"\"\n\n    def add_node(self, node:dict, graph:MogwaiGraph):\n        pass\n\n    def read(self, file_path:str, config:MogwaiGraphConfig=None):\n        import json\n        config = config or MogwaiGraphConfig()\n        g = MogwaiGraph(config=config)\n        try:\n            logger.info(\"Reading GraphSON file (assuming wrapped in 'vertices' key)\")\n            with open(file_path, 'r') as f:\n                data = json.load(f)\n                if \"vertices\" in data:\n                    for v in data[\"vertices\"]:\n                        self.add_node(v, g)\n                else:\n                    raise IOError(f\"Invalid GraphSON file {file_path}: missing 'vertices' key\")\n        except Exception:\n            logger.info(\"Nope, it's not wrapped in 'vertices' key\")\n            logger.info(\"Reading GraphSON file line by line\")\n            try:\n                with open(file_path, 'r') as f:\n                    for line in f:\n                        data = json.loads(line)\n                        self.add_node(data, g)\n            except Exception as e:\n                logger.error(f\"Error reading GraphSON file {file_path}: {e}\", exc_info=True)\n                raise IOError(f\"Error reading GraphSON file {file_path}: {e}\")\n\n    def wrap_type(self, val, dtype=None):\n        if dtype is None:\n            dtype = type(val)\n        match dtype:\n            case builtins.int:\n                if val &gt; 2**31:\n                    return {\"@type\": \"g:Int64\", \"@value\": int(val)}\n                return {\"@type\": \"g:Int32\", \"@value\": int(val)}\n            case builtins.float:\n                return {\"@type\": \"g:Double\", \"@value\": float(val)}\n            case builtins.bool | builtins.str:\n                return val\n            case dt.datetime:\n                return {\"@type\": \"g:Timestamp\", \"@value\": int(val.timestamp())}\n            case dt.date:\n                return {\"@type\": \"g:Timestamp\", \"@value\": int(dt.datetime(val.year, val.month, val.day).timestamp())}\n            case builtins.list | builtins.tuple:\n                return {\"@type\": \"g:List\", \"@value\": [self.wrap_type(v) for v in val]}\n            case builtins.set:\n                return {\"@type\": \"g:Set\", \"@value\": [self.wrap_type(v) for v in val]}\n            case builtins.dict:\n                d = []\n                for k, v in val.items():\n                    d.append(self.wrap_type(k))\n                    d.append(self.wrap_type(v))\n                return {\"@type\": \"g:Map\", \"@value\": d}\n            case _:\n                try:\n                    import numpy as np\n                    if isinstance(val, (np.int16, np.int32)):\n                        return {\"@type\": \"g:Int32\", \"@value\": int(val)}\n                    if isinstance(val, np.int64):\n                        return {\"@type\": \"g:Int64\", \"@value\": int(val)}\n                    if isinstance(val, np.float32):\n                        return {\"@type\": \"g:Float\", \"@value\": float(val)}\n                    if isinstance(val, np.float64):\n                        return {\"@type\": \"g:Double\", \"@value\": float(val)}\n                    if isinstance(val, np.bool):\n                        return bool(val)\n                except:\n                    pass\n                raise ValueError(f\"Unsupported type {dtype} for value {str(val)}\")\n\n    def unwrap_type(self, val:dict|Any):\n        if isinstance(val, (int, float, bool, str)):\n            return val\n        if isinstance(val, dict):\n            dtype = val.get(\"@type\")\n            val = val.get(\"@value\")        \n        match dtype:\n            case \"g:Int32\" | \"g:Int64\":\n                return int(val)\n            case \"g:Float\" | \"g:Double\":\n                return float(val)\n            case \"g:Date\":\n                return dt.date.fromtimestamp(val)\n            case \"g:Timestamp\":\n                return dt.datetime.fromtimestamp(val)\n            case \"g:List\":\n                return [self.unwrap_type(v) for v in val]\n            case \"g:Set\":\n                return {self.unwrap_type(v) for v in val}\n            case builtins.dict:\n                d = []\n                for k, v in val.items():\n                    d.append(self.wrap_type(k))\n                    d.append(self.wrap_type(v))\n                return {\"@type\": \"g:Map\", \"@value\": d}\n            case _:\n                raise ValueError(f\"Unsupported type {dtype} for value {str(val)}\")\n\n    def create_list(self, graph):\n        l = []\n        for node in graph.nodes:\n            n = {\"id\": node.id, \"label\": node.label}\n            for k, v in node.properties.items():\n                n[k] = v\n            l.append(n)\n        return l\n\n    def write(self, file_path:str, graph:MogwaiGraph):\n        import json\n        l = self.create_list(graph)\n        with open(file_path, 'w') as f:\n            for node in l:\n                f.write(json.dumps(node) + \"\\n\")\n</code></pre>"},{"location":"#mogwai.lod","title":"<code>lod</code>","text":""},{"location":"#mogwai.lod.yamlable","title":"<code>yamlable</code>","text":"<p>Created on 2023-12-08, Extended on 2023-16-12 and 2024-01-25</p> <p>redudant mogwai copy original is at https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/yamlable.py</p> <p>@author: wf, ChatGPT</p> <p>Prompts for the development and extension of the 'YamlAble' class within the 'yamable' module:</p> <ol> <li>Develop 'YamlAble' class in 'yamable' module. It    should convert dataclass instances to/from YAML.</li> <li>Implement methods for YAML block scalar style and    exclude None values in 'YamlAble' class.</li> <li>Add functionality to remove None values from    dataclass instances before YAML conversion.</li> <li>Ensure 'YamlAble' processes only dataclass instances,    with error handling for non-dataclass objects.</li> <li>Extend 'YamlAble' for JSON serialization and    deserialization.</li> <li>Add methods for saving/loading dataclass instances    to/from YAML and JSON files in 'YamlAble'.</li> <li>Implement loading of dataclass instances from URLs    for both YAML and JSON in 'YamlAble'.</li> <li>Write tests for 'YamlAble' within the pyLodStorage context.    Use 'samples 2' example from pyLoDStorage    https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/sample2.py    as a reference.</li> <li>Ensure tests cover YAML/JSON serialization, deserialization,    and file I/O operations, using the sample-based approach..</li> <li>Use Google-style docstrings, comments, and type hints    in 'YamlAble' class and tests.</li> <li>Adhere to instructions and seek clarification for     any uncertainties.</li> <li>Add @lod_storable annotation support that will automatically     YamlAble support and add @dataclass and @dataclass_json     prerequisite behavior to a class</li> </ol>"},{"location":"#mogwai.lod.yamlable.DateConvert","title":"<code>DateConvert</code>","text":"<p>date converter</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>class DateConvert:\n    \"\"\"\n    date converter\n    \"\"\"\n\n    @classmethod\n    def iso_date_to_datetime(cls, iso_date: str) -&gt; datetime.date:\n        date = datetime.strptime(iso_date, \"%Y-%m-%d\").date() if iso_date else None\n        return date\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble","title":"<code>YamlAble</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>An extended YAML handler class for converting dataclass objects to and from YAML format, and handling loading from and saving to files and URLs.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>class YamlAble(Generic[T]):\n    \"\"\"\n    An extended YAML handler class for converting dataclass objects to and from YAML format,\n    and handling loading from and saving to files and URLs.\n    \"\"\"\n\n    def _yaml_setup(self):\n        \"\"\"\n        Initializes the YamAble handler, setting up custom representers and preparing it for various operations.\n        \"\"\"\n        if not is_dataclass(self):\n            raise ValueError(\"I must be a dataclass instance.\")\n        if not hasattr(self, \"_yaml_dumper\"):\n            self._yaml_dumper = yaml.Dumper\n            self._yaml_dumper.ignore_aliases = lambda *_args: True\n            self._yaml_dumper.add_representer(type(None), self.represent_none)\n            self._yaml_dumper.add_representer(str, self.represent_literal)\n\n    def represent_none(self, _, __) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for ignoring None values in the YAML output.\n        \"\"\"\n        return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n\n    def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for block scalar style for strings.\n        \"\"\"\n        if \"\\n\" in data:\n            return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n\n    def to_yaml(\n        self,\n        ignore_none: bool = True,\n        ignore_underscore: bool = True,\n        allow_unicode: bool = True,\n        sort_keys: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n        and using block scalar style for strings.\n\n        Args:\n            ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n            ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n            allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n            sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n        Returns:\n            A string representation of the dataclass object in YAML format.\n        \"\"\"\n        obj_dict = asdict(self)\n        self._yaml_setup()\n        clean_dict = self.remove_ignored_values(\n            obj_dict, ignore_none, ignore_underscore\n        )\n        yaml_str = yaml.dump(\n            clean_dict,\n            Dumper=self._yaml_dumper,\n            default_flow_style=False,\n            allow_unicode=allow_unicode,\n            sort_keys=sort_keys,\n        )\n        return yaml_str\n\n    @classmethod\n    def from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n        \"\"\"\n        Deserializes a YAML string to a dataclass instance.\n\n        Args:\n            yaml_str (str): A string containing YAML formatted data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        data: dict[str, Any] = yaml.safe_load(yaml_str)\n        instance: T = cls.from_dict(data)\n        return instance\n\n    @classmethod\n    def load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML file.\n\n        Args:\n            filename (str): The path to the YAML file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            yaml_str: str = file.read()\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    @classmethod\n    def load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = cls.read_from_url(url)\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    def save_to_yaml_file(self, filename: str):\n        \"\"\"\n        Saves the current dataclass instance to a YAML file.\n\n        Args:\n            filename (str): The path where the YAML file will be saved.\n        \"\"\"\n        yaml_content: str = self.to_yaml()\n        with open(filename, \"w\") as file:\n            file.write(yaml_content)\n\n    @classmethod\n    def load_from_json_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON file.\n\n        Args:\n            filename (str): The path to the JSON file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            json_str: str = file.read()\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    @classmethod\n    def load_from_json_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the JSON data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        json_str: str = cls.read_from_url(url)\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    def save_to_json_file(self, filename: str, **kwargs):\n        \"\"\"\n        Saves the current dataclass instance to a JSON file.\n\n        Args:\n            filename (str): The path where the JSON file will be saved.\n            **kwargs: Additional keyword arguments for the `to_json` method.\n        \"\"\"\n        json_content: str = self.to_json(**kwargs)\n        with open(filename, \"w\") as file:\n            file.write(json_content)\n\n    @classmethod\n    def read_from_url(cls, url: str) -&gt; str:\n        \"\"\"\n        Helper method to fetch content from a URL.\n        \"\"\"\n        with urllib.request.urlopen(url) as response:\n            if response.status == 200:\n                return response.read().decode()\n            else:\n                raise Exception(f\"Unable to load data from URL: {url}\")\n\n    @classmethod\n    def remove_ignored_values(\n        cls,\n        value: Any,\n        ignore_none: bool = True,\n        ignore_underscore: bool = False,\n        ignore_empty: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Recursively removes specified types of values from a dictionary or list.\n        By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n        Args:\n            value: The value to process (dictionary, list, or other).\n            ignore_none: Flag to indicate whether None values should be removed.\n            ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n            ignore_empty: Flag to indicate whether empty collections should be removed.\n        \"\"\"\n\n        def is_valid(v):\n            \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n            if ignore_none and v is None:\n                return False\n            if ignore_empty:\n                if isinstance(v, Mapping) and not v:\n                    return False  # Empty dictionary\n                if (\n                    isinstance(v, Iterable)\n                    and not isinstance(v, (str, bytes))\n                    and not v\n                ):\n                    return (\n                        False  # Empty list, set, tuple, etc., but not string or bytes\n                    )\n            return True\n\n        if isinstance(value, Mapping):\n            value = {\n                k: YamlAble.remove_ignored_values(\n                    v, ignore_none, ignore_underscore, ignore_empty\n                )\n                for k, v in value.items()\n                if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n            }\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            value = [\n                YamlAble.remove_ignored_values(\n                    v, ignore_none, ignore_underscore, ignore_empty\n                )\n                for v in value\n                if is_valid(v)\n            ]\n        return value\n\n    @classmethod\n    def from_dict2(cls: Type[T], data: dict) -&gt; T:\n        \"\"\"\n        Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n        \"\"\"\n        if not data:\n            return None\n        instance = from_dict(data_class=cls, data=data)\n        return instance\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.from_dict2","title":"<code>from_dict2(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of a dataclass from a dictionary, typically used in deserialization.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>@classmethod\ndef from_dict2(cls: Type[T], data: dict) -&gt; T:\n    \"\"\"\n    Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n    \"\"\"\n    if not data:\n        return None\n    instance = from_dict(data_class=cls, data=data)\n    return instance\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.from_yaml","title":"<code>from_yaml(yaml_str)</code>  <code>classmethod</code>","text":"<p>Deserializes a YAML string to a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>A string containing YAML formatted data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>@classmethod\ndef from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n    \"\"\"\n    Deserializes a YAML string to a dataclass instance.\n\n    Args:\n        yaml_str (str): A string containing YAML formatted data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    data: dict[str, Any] = yaml.safe_load(yaml_str)\n    instance: T = cls.from_dict(data)\n    return instance\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.load_from_json_file","title":"<code>load_from_json_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON file.\n\n    Args:\n        filename (str): The path to the JSON file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        json_str: str = file.read()\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.load_from_json_url","title":"<code>load_from_json_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the JSON data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the JSON data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    json_str: str = cls.read_from_url(url)\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.load_from_yaml_file","title":"<code>load_from_yaml_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        yaml_str: str = file.read()\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.load_from_yaml_url","title":"<code>load_from_yaml_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = cls.read_from_url(url)\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.read_from_url","title":"<code>read_from_url(url)</code>  <code>classmethod</code>","text":"<p>Helper method to fetch content from a URL.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>@classmethod\ndef read_from_url(cls, url: str) -&gt; str:\n    \"\"\"\n    Helper method to fetch content from a URL.\n    \"\"\"\n    with urllib.request.urlopen(url) as response:\n        if response.status == 200:\n            return response.read().decode()\n        else:\n            raise Exception(f\"Unable to load data from URL: {url}\")\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.remove_ignored_values","title":"<code>remove_ignored_values(value, ignore_none=True, ignore_underscore=False, ignore_empty=True)</code>  <code>classmethod</code>","text":"<p>Recursively removes specified types of values from a dictionary or list. By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process (dictionary, list, or other).</p> required <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether keys starting with an underscore should be removed.</p> <code>False</code> <code>ignore_empty</code> <code>bool</code> <p>Flag to indicate whether empty collections should be removed.</p> <code>True</code> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>@classmethod\ndef remove_ignored_values(\n    cls,\n    value: Any,\n    ignore_none: bool = True,\n    ignore_underscore: bool = False,\n    ignore_empty: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Recursively removes specified types of values from a dictionary or list.\n    By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n    Args:\n        value: The value to process (dictionary, list, or other).\n        ignore_none: Flag to indicate whether None values should be removed.\n        ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n        ignore_empty: Flag to indicate whether empty collections should be removed.\n    \"\"\"\n\n    def is_valid(v):\n        \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n        if ignore_none and v is None:\n            return False\n        if ignore_empty:\n            if isinstance(v, Mapping) and not v:\n                return False  # Empty dictionary\n            if (\n                isinstance(v, Iterable)\n                and not isinstance(v, (str, bytes))\n                and not v\n            ):\n                return (\n                    False  # Empty list, set, tuple, etc., but not string or bytes\n                )\n        return True\n\n    if isinstance(value, Mapping):\n        value = {\n            k: YamlAble.remove_ignored_values(\n                v, ignore_none, ignore_underscore, ignore_empty\n            )\n            for k, v in value.items()\n            if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n        }\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        value = [\n            YamlAble.remove_ignored_values(\n                v, ignore_none, ignore_underscore, ignore_empty\n            )\n            for v in value\n            if is_valid(v)\n        ]\n    return value\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.represent_literal","title":"<code>represent_literal(dumper, data)</code>","text":"<p>Custom representer for block scalar style for strings.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for block scalar style for strings.\n    \"\"\"\n    if \"\\n\" in data:\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n    return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.represent_none","title":"<code>represent_none(_, __)</code>","text":"<p>Custom representer for ignoring None values in the YAML output.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>def represent_none(self, _, __) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for ignoring None values in the YAML output.\n    \"\"\"\n    return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.save_to_json_file","title":"<code>save_to_json_file(filename, **kwargs)</code>","text":"<p>Saves the current dataclass instance to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the JSON file will be saved.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the <code>to_json</code> method.</p> <code>{}</code> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>def save_to_json_file(self, filename: str, **kwargs):\n    \"\"\"\n    Saves the current dataclass instance to a JSON file.\n\n    Args:\n        filename (str): The path where the JSON file will be saved.\n        **kwargs: Additional keyword arguments for the `to_json` method.\n    \"\"\"\n    json_content: str = self.to_json(**kwargs)\n    with open(filename, \"w\") as file:\n        file.write(json_content)\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.save_to_yaml_file","title":"<code>save_to_yaml_file(filename)</code>","text":"<p>Saves the current dataclass instance to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the YAML file will be saved.</p> required Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>def save_to_yaml_file(self, filename: str):\n    \"\"\"\n    Saves the current dataclass instance to a YAML file.\n\n    Args:\n        filename (str): The path where the YAML file will be saved.\n    \"\"\"\n    yaml_content: str = self.to_yaml()\n    with open(filename, \"w\") as file:\n        file.write(yaml_content)\n</code></pre>"},{"location":"#mogwai.lod.yamlable.YamlAble.to_yaml","title":"<code>to_yaml(ignore_none=True, ignore_underscore=True, allow_unicode=True, sort_keys=False)</code>","text":"<p>Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables, and using block scalar style for strings.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed from the YAML output.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.</p> <code>True</code> <code>allow_unicode</code> <code>bool</code> <p>Flag to indicate whether to allow unicode characters in the output.</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>Flag to indicate whether to sort the dictionary keys in the output.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the dataclass object in YAML format.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>def to_yaml(\n    self,\n    ignore_none: bool = True,\n    ignore_underscore: bool = True,\n    allow_unicode: bool = True,\n    sort_keys: bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n    and using block scalar style for strings.\n\n    Args:\n        ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n        ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n        allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n        sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n    Returns:\n        A string representation of the dataclass object in YAML format.\n    \"\"\"\n    obj_dict = asdict(self)\n    self._yaml_setup()\n    clean_dict = self.remove_ignored_values(\n        obj_dict, ignore_none, ignore_underscore\n    )\n    yaml_str = yaml.dump(\n        clean_dict,\n        Dumper=self._yaml_dumper,\n        default_flow_style=False,\n        allow_unicode=allow_unicode,\n        sort_keys=sort_keys,\n    )\n    return yaml_str\n</code></pre>"},{"location":"#mogwai.lod.yamlable.lod_storable","title":"<code>lod_storable(cls)</code>","text":"<p>Decorator to make a class LoDStorable by inheriting from YamlAble. This decorator also ensures the class is a dataclass and has JSON serialization/deserialization capabilities.</p> Source code in <code>mogwai/lod/yamlable.py</code> <pre><code>def lod_storable(cls):\n    \"\"\"\n    Decorator to make a class LoDStorable by\n    inheriting from YamlAble.\n    This decorator also ensures the class is a\n    dataclass and has JSON serialization/deserialization\n    capabilities.\n    \"\"\"\n    cls = dataclass(cls)  # Apply the @dataclass decorator\n    cls = dataclass_json(cls)  # Apply the @dataclass_json decorator\n\n    class LoDStorable(YamlAble, cls):\n        \"\"\"\n        decorator class\n        \"\"\"\n\n        __qualname__ = cls.__qualname__\n        pass\n\n    LoDStorable.__name__ = cls.__name__\n    LoDStorable.__doc__ = cls.__doc__\n\n    return LoDStorable\n</code></pre>"},{"location":"#mogwai.mogwai_cmd","title":"<code>mogwai_cmd</code>","text":"<p>Created on 2024-08-15</p> <p>@author: wf</p>"},{"location":"#mogwai.mogwai_cmd.MogwaiCmd","title":"<code>MogwaiCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>command line handling for nicesprinkler</p> Source code in <code>mogwai/mogwai_cmd.py</code> <pre><code>class MogwaiCmd(WebserverCmd):\n    \"\"\"\n    command line handling for nicesprinkler\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        config = MogwaiWebServer.get_config()\n        WebserverCmd.__init__(self, config, MogwaiWebServer, DEBUG)\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n\n        return parser\n</code></pre>"},{"location":"#mogwai.mogwai_cmd.MogwaiCmd.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>mogwai/mogwai_cmd.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    config = MogwaiWebServer.get_config()\n    WebserverCmd.__init__(self, config, MogwaiWebServer, DEBUG)\n</code></pre>"},{"location":"#mogwai.mogwai_cmd.MogwaiCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>mogwai/mogwai_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n\n    return parser\n</code></pre>"},{"location":"#mogwai.mogwai_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>mogwai/mogwai_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = MogwaiCmd()\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#mogwai.parser","title":"<code>parser</code>","text":""},{"location":"#mogwai.parser.excel_converter","title":"<code>excel_converter</code>","text":""},{"location":"#mogwai.parser.filesystem","title":"<code>filesystem</code>","text":""},{"location":"#mogwai.parser.graphml_converter","title":"<code>graphml_converter</code>","text":""},{"location":"#mogwai.parser.graphml_converter.graphml_to_mogwaigraph","title":"<code>graphml_to_mogwaigraph(file, node_label_key, node_name_key, edge_label_key=None, default_node_label='Na', default_edge_label='Na', default_node_name='Na', include_id=False, keep=True)</code>","text":"<p>Converts GraphML file to MogwaiGraph object.</p>"},{"location":"#mogwai.parser.graphml_converter.graphml_to_mogwaigraph--parameters","title":"Parameters","text":"<p>file : str     Path to the GraphML file. node_label_key : str or Callable[[dict],str]     Key to use for the node label. If a string, the value of the key is used as the label.     If a function, it should take a dictionary of node data and return a string. node_name_key : str or Callable[[dict],str]     Key to use for the node name. If a string, the value of the key is used as the name.     If a function, it should take a dictionary of node data and return a string. edge_label_key : str or Callable[[dict],str], optional     Key to use for the edge label. If a string, the value of the key is used as the label.     If a function, it should take a dictionary of edge data and return a string.     If None, the node_label_key is used. default_node_label : str, optional     Default label to use for nodes that do not have a property corresponding to <code>node_label_key</code>. default_edge_label : str, optional     Default label to use for edges that do not have a property corresponding to <code>edge_label_key</code>. default_node_name : str, optional     Default name to use for nodes that do not have a property corresponding to <code>node_name_key</code>. include_id : bool or str, optional     If True, the node id is included in the data dictionary of each node.     If a string, the node id is included in the data dictionary with the given key. keep : bool, optional     If True, the labels and names are kept as properties in the node data dictionary. If False, they are removed.</p>"},{"location":"#mogwai.parser.graphml_converter.graphml_to_mogwaigraph--returns","title":"Returns","text":"<p>MogwaiGraph     The graph object</p> Source code in <code>mogwai/parser/graphml_converter.py</code> <pre><code>def graphml_to_mogwaigraph(\n    file: str,\n    node_label_key: str | Callable[[dict], str],\n    node_name_key: str | Callable[[dict], str],\n    edge_label_key: str | Callable[[dict], str] = None,\n    default_node_label: str = \"Na\",\n    default_edge_label: str = \"Na\",\n    default_node_name: str = \"Na\",\n    include_id: bool | str = False,\n    keep: bool = True,\n) -&gt; MogwaiGraph:\n    \"\"\"\n    Converts GraphML file to MogwaiGraph object.\n\n    Parameters\n    ----------\n    file : str\n        Path to the GraphML file.\n    node_label_key : str or Callable[[dict],str]\n        Key to use for the node label. If a string, the value of the key is used as the label.\n        If a function, it should take a dictionary of node data and return a string.\n    node_name_key : str or Callable[[dict],str]\n        Key to use for the node name. If a string, the value of the key is used as the name.\n        If a function, it should take a dictionary of node data and return a string.\n    edge_label_key : str or Callable[[dict],str], optional\n        Key to use for the edge label. If a string, the value of the key is used as the label.\n        If a function, it should take a dictionary of edge data and return a string.\n        If None, the node_label_key is used.\n    default_node_label : str, optional\n        Default label to use for nodes that do not have a property corresponding to `node_label_key`.\n    default_edge_label : str, optional\n        Default label to use for edges that do not have a property corresponding to `edge_label_key`.\n    default_node_name : str, optional\n        Default name to use for nodes that do not have a property corresponding to `node_name_key`.\n    include_id : bool or str, optional\n        If True, the node id is included in the data dictionary of each node.\n        If a string, the node id is included in the data dictionary with the given key.\n    keep : bool, optional\n        If True, the labels and names are kept as properties in the node data dictionary. If False, they are removed.\n\n    Returns\n    -------\n    MogwaiGraph\n        The graph object\n    \"\"\"\n    gml = nx.read_graphml(file)\n    if not gml.is_directed():\n        raise MogwaiGraphError(\"Can not import undirected graphml graph\")\n    g = MogwaiGraph()\n    edge_label_key = edge_label_key or node_label_key\n    if include_id == True:\n        include_id = \"id\"  # use 'id' as the default key\n    # Note: these function change the node data!\n    # However, this is not a problem, since `gml` is discarded anyway.\n    missing_label_count = count()\n    if type(node_label_key) is str:\n\n        def node_label_func(data: dict):\n            if node_label_key in data:\n                return data[node_label_key] if keep else data.pop(node_label_key)\n            else:\n                next(missing_label_count)\n                return default_node_label\n\n    else:\n        node_label_func = node_label_key\n    missing_name_count = count()\n    if type(node_name_key) is str:\n\n        def node_name_func(data: dict):\n            if node_name_key in data:\n                return data[node_name_key] if keep else data.pop(node_name_key)\n            else:\n                next(missing_name_count)\n                return default_node_name\n\n    else:\n        node_name_func = node_name_key\n\n    missing_edge_count = count()\n    if type(edge_label_key) is str:\n\n        def edge_label_func(data: dict):\n            if edge_label_key in data:\n                return data[edge_label_key] if keep else data.pop(edge_label_key)\n            else:\n                next(missing_edge_count)\n                return default_edge_label\n\n    else:\n        edge_label_func = edge_label_key\n\n    node_to_id_map = {}\n    for node, data in gml.nodes(data=True):\n        if include_id:\n            data[include_id] = node\n        assigned_id = g.add_labeled_node(\n            label=node_label_func(data), name=node_name_func(data), **data\n        )\n        node_to_id_map[node] = assigned_id\n    for node1, node2, data in gml.edges(data=True):\n        g.add_labeled_edge(\n            srcId=node_to_id_map[node1],\n            destId=node_to_id_map[node2],\n            edgeLabel=edge_label_func(data),\n            **data,\n        )\n\n    missing_edge_count = next(missing_edge_count)\n    missing_name_count = next(missing_name_count)\n    missing_label_count = next(missing_label_count)\n    if missing_edge_count &gt; 0:\n        logger.warning(f\"Encountered {missing_edge_count} edges without label\")\n    if missing_name_count &gt; 0:\n        logger.warning(f\"Encountered {missing_name_count} nodes without name\")\n    if missing_label_count &gt; 0:\n        logger.warning(f\"Encountered {missing_label_count} nodes without label\")\n    return g\n</code></pre>"},{"location":"#mogwai.parser.json_converter","title":"<code>json_converter</code>","text":"<p>Created on 2024-10-09</p> <p>@author: wf</p>"},{"location":"#mogwai.parser.json_converter.JsonGraph","title":"<code>JsonGraph</code>","text":"<p>json graph handling library</p> Source code in <code>mogwai/parser/json_converter.py</code> <pre><code>class JsonGraph:\n    \"\"\"\n    json graph handling library\n    \"\"\"\n\n    def __init__(self):\n        self.graph = MogwaiGraph()\n\n    def add_nodes_from_json(self, file_name, file_content):\n        \"\"\"\n        Add nodes from JSON data to the graph\n        \"\"\"\n        table_name = file_name.split(\".\")[0]  # Remove the .json extension\n\n        for line in file_content:\n            line = line.strip()\n            if line:  # Skip empty lines\n                try:\n                    json_data = json.loads(line)\n                    self.add_node(table_name, json_data)\n                except json.JSONDecodeError as e:\n                    print(f\"Error decoding JSON object in file {file_name}: {e}\")\n\n    def add_node(self, table_name, data):\n        \"\"\"\n        Add a single node to the graph\n        \"\"\"\n        node_id = data.get(\"id\", str(len(self.graph)))\n        self.graph.add_node(node_id, type=table_name, **data)\n\n    def dump(self, node_types=None, limit: int = 10):\n        \"\"\"\n        Dump the content of the graph for investigation.\n\n        Args:\n            node_types (list): List of node types to dump. If None, dump all types.\n            limit (int): Maximum number of nodes to dump for each node type. Default is 10.\n        \"\"\"\n        self._print_graph_summary()\n        node_types = self._get_node_types_to_dump(node_types)\n        self._dump_nodes(node_types, limit)\n        self._dump_edges(limit)\n\n    def _print_graph_summary(self):\n        print(f\"Total nodes in graph: {len(self.graph.nodes)}\")\n        print(f\"Total edges in graph: {len(self.graph.edges)}\")\n\n        all_node_types = set(\n            data.get(\"type\", \"Unknown\") for _, data in self.graph.nodes(data=True)\n        )\n        print(f\"All node types: {all_node_types}\")\n\n    def _get_node_types_to_dump(self, requested_types):\n        all_node_types = set(\n            data.get(\"type\", \"Unknown\") for _, data in self.graph.nodes(data=True)\n        )\n        if requested_types is None:\n            return all_node_types\n        return (\n            set(requested_types) &amp; all_node_types\n        )  # Ensure we only dump existing types\n\n    def _dump_nodes(self, node_types, limit):\n        print(f\"Dumping node types: {node_types}\")\n        for node_type in node_types:\n            self._dump_nodes_of_type(node_type, limit)\n\n    def _dump_nodes_of_type(self, node_type, limit):\n        print(f\"\\nDumping up to {limit} nodes of type '{node_type}':\")\n        count = 0\n        for node, data in self.graph.nodes(data=True):\n            if data.get(\"type\") == node_type:\n                self._print_node(node, data)\n                count += 1\n                if count &gt;= limit:\n                    break\n        if count &gt;= limit:\n            remaining = (\n                sum(\n                    1\n                    for _, d in self.graph.nodes(data=True)\n                    if d.get(\"type\") == node_type\n                )\n                - limit\n            )\n            print(f\"  ... and {remaining} more\")\n\n    def _print_node(self, node, data):\n        print(f\"  Node: {node}\")\n        for key, value in data.items():\n            if key != \"type\":\n                print(f\"    {key}: {value}\")\n\n    def _dump_edges(self, limit):\n        if self.graph.edges:\n            print(\"\\nSample of edges:\")\n            for i, (u, v, data) in enumerate(self.graph.edges(data=True)):\n                print(f\"  Edge {i}: {u} -&gt; {v}\")\n                for key, value in data.items():\n                    print(f\"    {key}: {value}\")\n                if i &gt;= limit - 1:\n                    remaining = len(self.graph.edges) - limit\n                    if remaining &gt; 0:\n                        print(f\"  ... and {remaining} more\")\n                    break\n        else:\n            print(\"\\nNo edges in the graph.\")\n</code></pre>"},{"location":"#mogwai.parser.json_converter.JsonGraph.add_node","title":"<code>add_node(table_name, data)</code>","text":"<p>Add a single node to the graph</p> Source code in <code>mogwai/parser/json_converter.py</code> <pre><code>def add_node(self, table_name, data):\n    \"\"\"\n    Add a single node to the graph\n    \"\"\"\n    node_id = data.get(\"id\", str(len(self.graph)))\n    self.graph.add_node(node_id, type=table_name, **data)\n</code></pre>"},{"location":"#mogwai.parser.json_converter.JsonGraph.add_nodes_from_json","title":"<code>add_nodes_from_json(file_name, file_content)</code>","text":"<p>Add nodes from JSON data to the graph</p> Source code in <code>mogwai/parser/json_converter.py</code> <pre><code>def add_nodes_from_json(self, file_name, file_content):\n    \"\"\"\n    Add nodes from JSON data to the graph\n    \"\"\"\n    table_name = file_name.split(\".\")[0]  # Remove the .json extension\n\n    for line in file_content:\n        line = line.strip()\n        if line:  # Skip empty lines\n            try:\n                json_data = json.loads(line)\n                self.add_node(table_name, json_data)\n            except json.JSONDecodeError as e:\n                print(f\"Error decoding JSON object in file {file_name}: {e}\")\n</code></pre>"},{"location":"#mogwai.parser.json_converter.JsonGraph.dump","title":"<code>dump(node_types=None, limit=10)</code>","text":"<p>Dump the content of the graph for investigation.</p> <p>Parameters:</p> Name Type Description Default <code>node_types</code> <code>list</code> <p>List of node types to dump. If None, dump all types.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of nodes to dump for each node type. Default is 10.</p> <code>10</code> Source code in <code>mogwai/parser/json_converter.py</code> <pre><code>def dump(self, node_types=None, limit: int = 10):\n    \"\"\"\n    Dump the content of the graph for investigation.\n\n    Args:\n        node_types (list): List of node types to dump. If None, dump all types.\n        limit (int): Maximum number of nodes to dump for each node type. Default is 10.\n    \"\"\"\n    self._print_graph_summary()\n    node_types = self._get_node_types_to_dump(node_types)\n    self._dump_nodes(node_types, limit)\n    self._dump_edges(limit)\n</code></pre>"},{"location":"#mogwai.parser.pdfgraph","title":"<code>pdfgraph</code>","text":""},{"location":"#mogwai.parser.powerpoint_converter","title":"<code>powerpoint_converter</code>","text":""},{"location":"#mogwai.schema","title":"<code>schema</code>","text":""},{"location":"#mogwai.schema.graph_schema","title":"<code>graph_schema</code>","text":"<p>Created on 2024-10-22</p> <p>@author: wf</p>"},{"location":"#mogwai.schema.graph_schema.GraphSchema","title":"<code>GraphSchema</code>","text":"<p>registry of node types and their configurations</p> Source code in <code>mogwai/schema/graph_schema.py</code> <pre><code>@lod_storable\nclass GraphSchema:\n    \"\"\"registry of node types and their configurations\"\"\"\n\n    base_uri: Optional[str] = \"http://example.org\"\n    node_id_type_name: Type = int\n    node_type_configs: Dict[str, NodeTypeConfig] = field(default_factory=dict)\n\n    @property\n    def node_id_type(self) -&gt; Type:\n        \"\"\"\n        Property to convert the node_id_type_name to an actual Python type.\n        \"\"\"\n        return getattr(builtins, self.node_id_type_name)\n\n    def get_node_config(self, node_data: dict) -&gt; NodeTypeConfig | None:\n        \"\"\"\n        Get the NodeTypeConfig for the node based on its labels.\n\n        Args:\n            node_data (dict): The data of the node containing labels\n\n        Returns:\n            NodeTypeConfig or None: The NodeTypeConfig for the given node if found, otherwise None.\n        \"\"\"\n        if node_data:\n            labels = node_data.get(\"labels\", set())\n            if labels:\n                node_label = next(iter(labels))  # Get the first label\n            return self.node_type_configs.get(node_label)\n        return None\n\n    def add_to_graph(self, graph: MogwaiGraph):\n        \"\"\"\n        add my node type configurations to the given graph\n\n        Args:\n            graph(MogwaiGraph): the graph to add the configurations to\n        \"\"\"\n        for node_type in self.node_type_configs.values():\n            props = node_type.__dict__.copy()\n            graph.add_labeled_node(\n                \"NodeTypeConfig\", name=node_type.label, properties=props\n            )\n\n    @classmethod\n    def yaml_path(cls) -&gt; str:\n        \"\"\"Default path for schema YAML file\"\"\"\n        module_path = os.path.dirname(os.path.abspath(__file__))\n        yaml_path = os.path.join(module_path, \"resources\", \"schema.yaml\")\n        return yaml_path\n\n    @classmethod\n    def load(cls, yaml_path: str = None) -&gt; \"GraphSchema\":\n        \"\"\"\n        Load schema from a YAML file, ensuring the file exists.\n\n        Args:\n            yaml_path: Optional path to YAML file. If None, uses default path.\n\n        Returns:\n            GraphSchema: Loaded schema or empty schema if file doesn't exist\n        \"\"\"\n        if yaml_path is None:\n            yaml_path = cls.yaml_path()\n\n        if not Path(yaml_path).exists():\n            err_msg = f\"Schema YAML file not found: {yaml_path}\"\n            logging.error(err_msg)\n            return cls()\n\n        return cls.load_from_yaml_file(yaml_path)\n</code></pre>"},{"location":"#mogwai.schema.graph_schema.GraphSchema.node_id_type","title":"<code>node_id_type: Type</code>  <code>property</code>","text":"<p>Property to convert the node_id_type_name to an actual Python type.</p>"},{"location":"#mogwai.schema.graph_schema.GraphSchema.add_to_graph","title":"<code>add_to_graph(graph)</code>","text":"<p>add my node type configurations to the given graph</p> <p>Parameters:</p> Name Type Description Default <code>graph(MogwaiGraph)</code> <p>the graph to add the configurations to</p> required Source code in <code>mogwai/schema/graph_schema.py</code> <pre><code>def add_to_graph(self, graph: MogwaiGraph):\n    \"\"\"\n    add my node type configurations to the given graph\n\n    Args:\n        graph(MogwaiGraph): the graph to add the configurations to\n    \"\"\"\n    for node_type in self.node_type_configs.values():\n        props = node_type.__dict__.copy()\n        graph.add_labeled_node(\n            \"NodeTypeConfig\", name=node_type.label, properties=props\n        )\n</code></pre>"},{"location":"#mogwai.schema.graph_schema.GraphSchema.get_node_config","title":"<code>get_node_config(node_data)</code>","text":"<p>Get the NodeTypeConfig for the node based on its labels.</p> <p>Parameters:</p> Name Type Description Default <code>node_data</code> <code>dict</code> <p>The data of the node containing labels</p> required <p>Returns:</p> Type Description <code>NodeTypeConfig | None</code> <p>NodeTypeConfig or None: The NodeTypeConfig for the given node if found, otherwise None.</p> Source code in <code>mogwai/schema/graph_schema.py</code> <pre><code>def get_node_config(self, node_data: dict) -&gt; NodeTypeConfig | None:\n    \"\"\"\n    Get the NodeTypeConfig for the node based on its labels.\n\n    Args:\n        node_data (dict): The data of the node containing labels\n\n    Returns:\n        NodeTypeConfig or None: The NodeTypeConfig for the given node if found, otherwise None.\n    \"\"\"\n    if node_data:\n        labels = node_data.get(\"labels\", set())\n        if labels:\n            node_label = next(iter(labels))  # Get the first label\n        return self.node_type_configs.get(node_label)\n    return None\n</code></pre>"},{"location":"#mogwai.schema.graph_schema.GraphSchema.load","title":"<code>load(yaml_path=None)</code>  <code>classmethod</code>","text":"<p>Load schema from a YAML file, ensuring the file exists.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>str</code> <p>Optional path to YAML file. If None, uses default path.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>GraphSchema</code> <code>GraphSchema</code> <p>Loaded schema or empty schema if file doesn't exist</p> Source code in <code>mogwai/schema/graph_schema.py</code> <pre><code>@classmethod\ndef load(cls, yaml_path: str = None) -&gt; \"GraphSchema\":\n    \"\"\"\n    Load schema from a YAML file, ensuring the file exists.\n\n    Args:\n        yaml_path: Optional path to YAML file. If None, uses default path.\n\n    Returns:\n        GraphSchema: Loaded schema or empty schema if file doesn't exist\n    \"\"\"\n    if yaml_path is None:\n        yaml_path = cls.yaml_path()\n\n    if not Path(yaml_path).exists():\n        err_msg = f\"Schema YAML file not found: {yaml_path}\"\n        logging.error(err_msg)\n        return cls()\n\n    return cls.load_from_yaml_file(yaml_path)\n</code></pre>"},{"location":"#mogwai.schema.graph_schema.GraphSchema.yaml_path","title":"<code>yaml_path()</code>  <code>classmethod</code>","text":"<p>Default path for schema YAML file</p> Source code in <code>mogwai/schema/graph_schema.py</code> <pre><code>@classmethod\ndef yaml_path(cls) -&gt; str:\n    \"\"\"Default path for schema YAML file\"\"\"\n    module_path = os.path.dirname(os.path.abspath(__file__))\n    yaml_path = os.path.join(module_path, \"resources\", \"schema.yaml\")\n    return yaml_path\n</code></pre>"},{"location":"#mogwai.schema.graph_schema.NodeTypeConfig","title":"<code>NodeTypeConfig</code>","text":"<p>Configuration for a node type in the graph</p> Source code in <code>mogwai/schema/graph_schema.py</code> <pre><code>@lod_storable\nclass NodeTypeConfig:\n    \"\"\"Configuration for a node type in the graph\"\"\"\n\n    label: str  # Label used in the graph database\n    # https://fonts.google.com/icons?icon.set=Material+Icons\n    icon: str  # Material icon name\n    key_field: str  # Primary identifier field\n    dataclass_name: (\n        str  # module.class name string for the dataclass to be used for this node type\n    )\n    display_name: str  # Human-readable name for UI\n    display_order: int = 1000  # order for display - default to high number\n    viewclass_name: Optional[str] = (\n        None  # module.class name string for the viewclass to be used for this node type\n    )\n    description: Optional[str] = None\n    _dataclass: Type = field(init=False)\n    _viewclass: Type = field(init=False)\n\n    def get_class(self, class_name_attr: str) -&gt; None:\n        \"\"\"\n        retrievw a class from its module path string.\n\n        Args:\n            class_name_attr: The attribute name containing the class path string\n\n        Raises:\n            ValueError: If the class initialization fails\n        \"\"\"\n        class_path = getattr(self, class_name_attr)\n        if not class_path:\n            return None\n        try:\n            module_path, class_name = class_path.rsplit(\".\", 1)\n            module = importlib.import_module(module_path)\n            return getattr(module, class_name)\n        except Exception as ex:\n            raise ValueError(f\"Invalid {class_name_attr}: {class_path}: {str(ex)}\")\n\n    def __post_init__(self):\n        \"\"\"Initialize the dataclass and view class types\"\"\"\n        class_configs = [\n            (\"dataclass_name\", \"_dataclass\"),\n            (\"viewclass_name\", \"_viewclass\"),\n        ]\n        for class_name_attr, target_attr in class_configs:\n            clazz = self.get_class(class_name_attr)\n            setattr(self, target_attr, clazz)\n\n    def as_view_dict(self) -&gt; Dict:\n        view_dict = {\"description\": self.description, \"icon\": self.icon}\n        return view_dict\n</code></pre>"},{"location":"#mogwai.schema.graph_schema.NodeTypeConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the dataclass and view class types</p> Source code in <code>mogwai/schema/graph_schema.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the dataclass and view class types\"\"\"\n    class_configs = [\n        (\"dataclass_name\", \"_dataclass\"),\n        (\"viewclass_name\", \"_viewclass\"),\n    ]\n    for class_name_attr, target_attr in class_configs:\n        clazz = self.get_class(class_name_attr)\n        setattr(self, target_attr, clazz)\n</code></pre>"},{"location":"#mogwai.schema.graph_schema.NodeTypeConfig.get_class","title":"<code>get_class(class_name_attr)</code>","text":"<p>retrievw a class from its module path string.</p> <p>Parameters:</p> Name Type Description Default <code>class_name_attr</code> <code>str</code> <p>The attribute name containing the class path string</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the class initialization fails</p> Source code in <code>mogwai/schema/graph_schema.py</code> <pre><code>def get_class(self, class_name_attr: str) -&gt; None:\n    \"\"\"\n    retrievw a class from its module path string.\n\n    Args:\n        class_name_attr: The attribute name containing the class path string\n\n    Raises:\n        ValueError: If the class initialization fails\n    \"\"\"\n    class_path = getattr(self, class_name_attr)\n    if not class_path:\n        return None\n    try:\n        module_path, class_name = class_path.rsplit(\".\", 1)\n        module = importlib.import_module(module_path)\n        return getattr(module, class_name)\n    except Exception as ex:\n        raise ValueError(f\"Invalid {class_name_attr}: {class_path}: {str(ex)}\")\n</code></pre>"},{"location":"#mogwai.schema.nx_to_rdf","title":"<code>nx_to_rdf</code>","text":"<p>Created on 2024-10-22</p> <p>@author: wf</p>"},{"location":"#mogwai.schema.nx_to_rdf.NetworkXToRDFConverter","title":"<code>NetworkXToRDFConverter</code>","text":"<p>A converter for converting a NetworkX graph to RDF based on the given GraphSchema.</p> Source code in <code>mogwai/schema/nx_to_rdf.py</code> <pre><code>class NetworkXToRDFConverter:\n    \"\"\"\n    A converter for converting a NetworkX graph to RDF based on the given GraphSchema.\n    \"\"\"\n\n    def __init__(self, schema: GraphSchema, namespaces: List[str]):\n        \"\"\"\n        Initialize the converter with the given schema.\n\n        Args:\n            schema (GraphSchema): The graph schema containing the node type configurations and base URI.\n            namespaces (List[str]): A list of namespaces used for managing prefixes in the graph.\n        \"\"\"\n        self.schema = schema\n        self.base_uri = schema.base_uri\n        self.rdf_graph = RDFGraph()\n        self.ns = Namespace(self.base_uri)\n\n        # Bind the namespaces for prettier output\n        for namespace in namespaces:\n            self.rdf_graph.bind(namespace, self.ns)\n        self.rdf_graph.bind(\"xsd\", XSD)\n\n    def _get_rdf_literal(self, value):\n        \"\"\"\n        Convert Python values to appropriate RDF literals\n        \"\"\"\n        if isinstance(value, bool):\n            return Literal(value, datatype=XSD.boolean)\n        elif isinstance(value, int):\n            return Literal(value, datatype=XSD.integer)\n        elif isinstance(value, datetime):\n            return Literal(value.isoformat(), datatype=XSD.dateTime)\n        else:\n            return Literal(str(value))\n\n    def convert_node(self, node_id, node_data):\n        \"\"\"\n        Convert a NetworkX node to RDF and add it to the RDFLib graph.\n\n        Args:\n            node_id: The node identifier\n            node_data: The data associated with the node\n        \"\"\"\n        node_uri = URIRef(f\"{self.base_uri}{node_id}\")\n\n        # Add all node attributes as properties\n        for key, value in node_data.items():\n            if value is not None:  # Skip None values\n                predicate = URIRef(f\"{self.base_uri}{key}\")\n                self.rdf_graph.add((node_uri, predicate, self._get_rdf_literal(value)))\n\n    def convert_edge(self, source_id, target_id, edge_data):\n        \"\"\"\n        Convert a NetworkX edge to RDF and add it to the RDFLib graph.\n\n        Args:\n            source_id: The source node identifier\n            target_id: The target node identifier\n            edge_data: The data associated with the edge\n        \"\"\"\n        source_uri = URIRef(f\"{self.base_uri}{source_id}\")\n        target_uri = URIRef(f\"{self.base_uri}{target_id}\")\n\n        if edge_data and \"labels\" in edge_data:\n            predicate = URIRef(f\"{self.base_uri}{edge_data['labels']}\")\n            self.rdf_graph.add((source_uri, predicate, target_uri))\n\n    def convert_graph(self, nx_graph: nx.Graph):\n        \"\"\"\n        Convert the entire NetworkX graph to RDF.\n\n        Args:\n            nx_graph (nx.Graph): The NetworkX graph to convert\n        \"\"\"\n        # Convert all nodes\n        for node_id, node_data in nx_graph.nodes(data=True):\n            self.convert_node(node_id, node_data)\n\n        # Convert all edges\n        for source_id, target_id, edge_data in nx_graph.edges(data=True):\n            self.convert_edge(source_id, target_id, edge_data)\n\n    def serialize(self, rdf_format: str = \"turtle\") -&gt; str:\n        \"\"\"\n        Serialize the RDF graph to the specified format.\n\n        Args:\n            rdf_format (str): The RDF format to serialize to (e.g., 'turtle', 'xml').\n\n        Returns:\n            str: The serialized RDF graph.\n        \"\"\"\n        return self.rdf_graph.serialize(format=rdf_format)\n</code></pre>"},{"location":"#mogwai.schema.nx_to_rdf.NetworkXToRDFConverter.__init__","title":"<code>__init__(schema, namespaces)</code>","text":"<p>Initialize the converter with the given schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>GraphSchema</code> <p>The graph schema containing the node type configurations and base URI.</p> required <code>namespaces</code> <code>List[str]</code> <p>A list of namespaces used for managing prefixes in the graph.</p> required Source code in <code>mogwai/schema/nx_to_rdf.py</code> <pre><code>def __init__(self, schema: GraphSchema, namespaces: List[str]):\n    \"\"\"\n    Initialize the converter with the given schema.\n\n    Args:\n        schema (GraphSchema): The graph schema containing the node type configurations and base URI.\n        namespaces (List[str]): A list of namespaces used for managing prefixes in the graph.\n    \"\"\"\n    self.schema = schema\n    self.base_uri = schema.base_uri\n    self.rdf_graph = RDFGraph()\n    self.ns = Namespace(self.base_uri)\n\n    # Bind the namespaces for prettier output\n    for namespace in namespaces:\n        self.rdf_graph.bind(namespace, self.ns)\n    self.rdf_graph.bind(\"xsd\", XSD)\n</code></pre>"},{"location":"#mogwai.schema.nx_to_rdf.NetworkXToRDFConverter.convert_edge","title":"<code>convert_edge(source_id, target_id, edge_data)</code>","text":"<p>Convert a NetworkX edge to RDF and add it to the RDFLib graph.</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <p>The source node identifier</p> required <code>target_id</code> <p>The target node identifier</p> required <code>edge_data</code> <p>The data associated with the edge</p> required Source code in <code>mogwai/schema/nx_to_rdf.py</code> <pre><code>def convert_edge(self, source_id, target_id, edge_data):\n    \"\"\"\n    Convert a NetworkX edge to RDF and add it to the RDFLib graph.\n\n    Args:\n        source_id: The source node identifier\n        target_id: The target node identifier\n        edge_data: The data associated with the edge\n    \"\"\"\n    source_uri = URIRef(f\"{self.base_uri}{source_id}\")\n    target_uri = URIRef(f\"{self.base_uri}{target_id}\")\n\n    if edge_data and \"labels\" in edge_data:\n        predicate = URIRef(f\"{self.base_uri}{edge_data['labels']}\")\n        self.rdf_graph.add((source_uri, predicate, target_uri))\n</code></pre>"},{"location":"#mogwai.schema.nx_to_rdf.NetworkXToRDFConverter.convert_graph","title":"<code>convert_graph(nx_graph)</code>","text":"<p>Convert the entire NetworkX graph to RDF.</p> <p>Parameters:</p> Name Type Description Default <code>nx_graph</code> <code>Graph</code> <p>The NetworkX graph to convert</p> required Source code in <code>mogwai/schema/nx_to_rdf.py</code> <pre><code>def convert_graph(self, nx_graph: nx.Graph):\n    \"\"\"\n    Convert the entire NetworkX graph to RDF.\n\n    Args:\n        nx_graph (nx.Graph): The NetworkX graph to convert\n    \"\"\"\n    # Convert all nodes\n    for node_id, node_data in nx_graph.nodes(data=True):\n        self.convert_node(node_id, node_data)\n\n    # Convert all edges\n    for source_id, target_id, edge_data in nx_graph.edges(data=True):\n        self.convert_edge(source_id, target_id, edge_data)\n</code></pre>"},{"location":"#mogwai.schema.nx_to_rdf.NetworkXToRDFConverter.convert_node","title":"<code>convert_node(node_id, node_data)</code>","text":"<p>Convert a NetworkX node to RDF and add it to the RDFLib graph.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <p>The node identifier</p> required <code>node_data</code> <p>The data associated with the node</p> required Source code in <code>mogwai/schema/nx_to_rdf.py</code> <pre><code>def convert_node(self, node_id, node_data):\n    \"\"\"\n    Convert a NetworkX node to RDF and add it to the RDFLib graph.\n\n    Args:\n        node_id: The node identifier\n        node_data: The data associated with the node\n    \"\"\"\n    node_uri = URIRef(f\"{self.base_uri}{node_id}\")\n\n    # Add all node attributes as properties\n    for key, value in node_data.items():\n        if value is not None:  # Skip None values\n            predicate = URIRef(f\"{self.base_uri}{key}\")\n            self.rdf_graph.add((node_uri, predicate, self._get_rdf_literal(value)))\n</code></pre>"},{"location":"#mogwai.schema.nx_to_rdf.NetworkXToRDFConverter.serialize","title":"<code>serialize(rdf_format='turtle')</code>","text":"<p>Serialize the RDF graph to the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>rdf_format</code> <code>str</code> <p>The RDF format to serialize to (e.g., 'turtle', 'xml').</p> <code>'turtle'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The serialized RDF graph.</p> Source code in <code>mogwai/schema/nx_to_rdf.py</code> <pre><code>def serialize(self, rdf_format: str = \"turtle\") -&gt; str:\n    \"\"\"\n    Serialize the RDF graph to the specified format.\n\n    Args:\n        rdf_format (str): The RDF format to serialize to (e.g., 'turtle', 'xml').\n\n    Returns:\n        str: The serialized RDF graph.\n    \"\"\"\n    return self.rdf_graph.serialize(format=rdf_format)\n</code></pre>"},{"location":"#mogwai.utils","title":"<code>utils</code>","text":""},{"location":"#mogwai.utils.graph_summary","title":"<code>graph_summary</code>","text":""},{"location":"#mogwai.utils.graph_summary.GraphSummary","title":"<code>GraphSummary</code>","text":"<p>A class to generate formatted summaries of graph structures.</p> Source code in <code>mogwai/utils/graph_summary.py</code> <pre><code>class GraphSummary:\n    \"\"\"A class to generate formatted summaries of graph structures.\"\"\"\n\n    def __init__(\n        self,\n        graph,\n        fmt: str = \"github\",\n        section_formats: Optional[Dict[str, List[SectionFormat]]] = None,\n    ):\n        \"\"\" constructor\"\"\"\n        self.graph = graph\n        self.fmt = fmt\n        self.section_formats = section_formats or {\n            \"github\": [SectionFormat(1, \"# {header}\")],\n            \"mediawiki\": [SectionFormat(1, \"= {header} =\")],\n            \"latex\": [SectionFormat(1, \"\\\\section{{{header}}}\")],\n        }\n\n\n    def summary(self,limit: int = 3) -&gt; str:\n        \"\"\"Generate a summary of the graph.\"\"\"\n        summary=self.dump(limit=limit)\n        return summary\n\n    def format_section_header(self, header: str, level: int = 1) -&gt; str:\n        \"\"\"Format the section header using the format string for the current output format.\"\"\"\n        text=header\n        section_formats = self.section_formats.get(self.fmt, None)\n        print(section_formats, \"level\", level)\n        if section_formats is not None:\n            # Find the format string for the requested level\n            for section_format in section_formats:\n                print(section_format.level, level, section_format.level == level)\n                if section_format.level == level:\n                    text = section_format.format_section_header(header)\n                    return text\n            raise ValueError(\"No format string found for the requested level.\" + (str(level)) + \" in \" + str(section_formats))\n        else:\n            raise ValueError(\"No format string found for the requested format.\")\n\n\n    def dump(self, node_types=None, limit: int = 10) -&gt; str:\n        \"\"\"\n        Dump the content of the graph for investigation.\n\n        Args:\n            node_types (list): List of node types to dump. If None, dump all types.\n            limit (int): Maximum number of nodes to dump for each node type. Default is 10.\n\n        Returns:\n            str: Formatted string containing the graph summary, nodes, and edges.\n        \"\"\"\n        output = []\n        output.append(self.format_section_header(\"Graph Summary\"))\n        output.append(self._get_graph_summary())\n\n        node_types = self._get_node_types_to_dump(node_types)\n        output.append(self.format_section_header(\"Nodes\"))\n        output.append(self._get_nodes_summary(node_types, limit))\n\n        output.append(self.format_section_header(\"Edges\"))\n        output.append(self._get_edges_summary(limit))\n\n        return \"\\n\\n\".join(filter(None, output))\n\n    def _get_graph_summary(self) -&gt; str:\n        summary_data = [\n            [\"Total Nodes\", len(self.graph.nodes)],\n            [\"Total Edges\", len(self.graph.edges)],\n            [\"Node Types\", \", \".join(self._get_all_node_types())],\n        ]\n        markup= tabulate(summary_data, headers=[\"Metric\", \"Value\"], tablefmt=self.fmt)\n        return markup\n\n    def _get_all_node_types(self) -&gt; Set[str]:\n        return {\n            data.get(\"type\", \"Unknown\")\n            for _, data in self.graph.nodes(data=True)\n        }\n\n    def _get_node_types_to_dump(self, requested_types) -&gt; Set[str]:\n        all_node_types = self._get_all_node_types()\n        if requested_types is None:\n            return all_node_types\n        return set(requested_types) &amp; all_node_types\n\n    def _get_nodes_summary(self, node_types, limit) -&gt; str:\n        output = []\n        for node_type in node_types:\n            output.append(self.format_section_header(f\"Node Type: {node_type}\", level=2))\n            output.append(self._get_nodes_of_type_summary(node_type, limit))\n        return \"\\n\".join(filter(None, output))\n\n    def _get_nodes_of_type_summary(self, node_type, limit) -&gt; str:\n        rows = []\n        for node, data in self.graph.nodes(data=True):\n            if data.get(\"type\") == node_type:\n                rows.append([node] + [f\"{k}: {v}\" for k, v in data.items() if k != \"type\"])\n                if len(rows) &gt;= limit:\n                    break\n        if rows:\n            table = tabulate(rows, headers=[\"Node\", \"Details\"], tablefmt=self.fmt)\n            if len(rows) == limit:\n                remaining = sum(\n                    1\n                    for _, d in self.graph.nodes(data=True)\n                    if d.get(\"type\") == node_type\n                ) - limit\n                if remaining &gt; 0:\n                    table += f\"\\n... and {remaining} more\"\n            return table\n        return \"No nodes found for this type.\"\n\n    def _get_edges_summary(self, limit) -&gt; str:\n        rows = []\n        for i, (u, v, data) in enumerate(self.graph.edges(data=True)):\n            rows.append([f\"{u} -&gt; {v}\"] + [f\"{k}: {v}\" for k, v in data.items()])\n            if len(rows) &gt;= limit:\n                break\n        if rows:\n            table = tabulate(rows, headers=[\"Edge\", \"Details\"], tablefmt=self.fmt)\n            if len(rows) == limit:\n                remaining = len(self.graph.edges) - limit\n                if remaining &gt; 0:\n                    table += f\"\\n... and {remaining} more\"\n            return table\n        return \"No edges in the graph.\"\n</code></pre>"},{"location":"#mogwai.utils.graph_summary.GraphSummary.__init__","title":"<code>__init__(graph, fmt='github', section_formats=None)</code>","text":"<p>constructor</p> Source code in <code>mogwai/utils/graph_summary.py</code> <pre><code>def __init__(\n    self,\n    graph,\n    fmt: str = \"github\",\n    section_formats: Optional[Dict[str, List[SectionFormat]]] = None,\n):\n    \"\"\" constructor\"\"\"\n    self.graph = graph\n    self.fmt = fmt\n    self.section_formats = section_formats or {\n        \"github\": [SectionFormat(1, \"# {header}\")],\n        \"mediawiki\": [SectionFormat(1, \"= {header} =\")],\n        \"latex\": [SectionFormat(1, \"\\\\section{{{header}}}\")],\n    }\n</code></pre>"},{"location":"#mogwai.utils.graph_summary.GraphSummary.dump","title":"<code>dump(node_types=None, limit=10)</code>","text":"<p>Dump the content of the graph for investigation.</p> <p>Parameters:</p> Name Type Description Default <code>node_types</code> <code>list</code> <p>List of node types to dump. If None, dump all types.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of nodes to dump for each node type. Default is 10.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string containing the graph summary, nodes, and edges.</p> Source code in <code>mogwai/utils/graph_summary.py</code> <pre><code>def dump(self, node_types=None, limit: int = 10) -&gt; str:\n    \"\"\"\n    Dump the content of the graph for investigation.\n\n    Args:\n        node_types (list): List of node types to dump. If None, dump all types.\n        limit (int): Maximum number of nodes to dump for each node type. Default is 10.\n\n    Returns:\n        str: Formatted string containing the graph summary, nodes, and edges.\n    \"\"\"\n    output = []\n    output.append(self.format_section_header(\"Graph Summary\"))\n    output.append(self._get_graph_summary())\n\n    node_types = self._get_node_types_to_dump(node_types)\n    output.append(self.format_section_header(\"Nodes\"))\n    output.append(self._get_nodes_summary(node_types, limit))\n\n    output.append(self.format_section_header(\"Edges\"))\n    output.append(self._get_edges_summary(limit))\n\n    return \"\\n\\n\".join(filter(None, output))\n</code></pre>"},{"location":"#mogwai.utils.graph_summary.GraphSummary.format_section_header","title":"<code>format_section_header(header, level=1)</code>","text":"<p>Format the section header using the format string for the current output format.</p> Source code in <code>mogwai/utils/graph_summary.py</code> <pre><code>def format_section_header(self, header: str, level: int = 1) -&gt; str:\n    \"\"\"Format the section header using the format string for the current output format.\"\"\"\n    text=header\n    section_formats = self.section_formats.get(self.fmt, None)\n    print(section_formats, \"level\", level)\n    if section_formats is not None:\n        # Find the format string for the requested level\n        for section_format in section_formats:\n            print(section_format.level, level, section_format.level == level)\n            if section_format.level == level:\n                text = section_format.format_section_header(header)\n                return text\n        raise ValueError(\"No format string found for the requested level.\" + (str(level)) + \" in \" + str(section_formats))\n    else:\n        raise ValueError(\"No format string found for the requested format.\")\n</code></pre>"},{"location":"#mogwai.utils.graph_summary.GraphSummary.summary","title":"<code>summary(limit=3)</code>","text":"<p>Generate a summary of the graph.</p> Source code in <code>mogwai/utils/graph_summary.py</code> <pre><code>def summary(self,limit: int = 3) -&gt; str:\n    \"\"\"Generate a summary of the graph.\"\"\"\n    summary=self.dump(limit=limit)\n    return summary\n</code></pre>"},{"location":"#mogwai.utils.graph_summary.SectionFormat","title":"<code>SectionFormat</code>  <code>dataclass</code>","text":"Source code in <code>mogwai/utils/graph_summary.py</code> <pre><code>@dataclass\nclass SectionFormat:\n    level: int = 1\n    format_str: str = \"{header}\"\n\n    def format_section_header(self, header: str) -&gt; str:\n        \"\"\"\n        format a given header with my format string\n        \"\"\"\n        text= self.format_str.format(header=header)\n        return text\n</code></pre>"},{"location":"#mogwai.utils.graph_summary.SectionFormat.format_section_header","title":"<code>format_section_header(header)</code>","text":"<p>format a given header with my format string</p> Source code in <code>mogwai/utils/graph_summary.py</code> <pre><code>def format_section_header(self, header: str) -&gt; str:\n    \"\"\"\n    format a given header with my format string\n    \"\"\"\n    text= self.format_str.format(header=header)\n    return text\n</code></pre>"},{"location":"#mogwai.utils.type_utils","title":"<code>type_utils</code>","text":""},{"location":"#mogwai.utils.type_utils.TypeUtils","title":"<code>TypeUtils</code>","text":"<p>utility functions to handle types</p> Source code in <code>mogwai/utils/type_utils.py</code> <pre><code>class TypeUtils:\n    \"\"\"\n    utility functions to handle types\n    \"\"\"\n    @classmethod\n    def get_dict_indexer(cls, keys: List[str]|str, default: Any=None):\n        if isinstance(keys, (list,tuple)):\n            def indexer(x):\n                try:\n                    for key in keys:\n                        x = x[key]\n                    return x\n                except:\n                    return default\n            return indexer\n        else:\n            return lambda x: x.get(keys, default)\n\n    @classmethod\n    def get_set_type(cls, s: Set):\n        if len(s)==0: return None\n        sample = next(iter(s))\n        return type(sample)\n\n    @classmethod\n    def get_set_type_all(cls, s: Set):\n        if len(s)==0: return None\n        sample = next(iter(s))\n        t = type(sample)\n        for element in s:\n            if type(element) is not t:\n                return False\n        return t\n\n    @classmethod\n    def get_list_type(cls, l: List):\n        if(len(l)==0): return None\n        return type(l[0])\n\n    @classmethod\n    def get_list_type_all(cls, l: List):\n        if len(l)==0: return None\n        dtype = type(l[0])\n        if all((type(x) is dtype for x in l)):\n            return dtype\n        return False\n\n    @classmethod\n    def ensure_is_set(cls, s: Set|Generator|List):\n        return s if isinstance(s, Set) else set(s)\n\n    @classmethod\n    def ensure_is_list(cls, s: Set|Generator|List):\n        return s if isinstance(s, List) else list(s)\n</code></pre>"},{"location":"#mogwai.version","title":"<code>version</code>","text":"<p>Created on 2024-08-15</p> <p>@author: wf</p>"},{"location":"#mogwai.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyMogwai</p> Source code in <code>mogwai/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for pyMogwai\n    \"\"\"\n\n    name = \"pymogwai\"\n    version = mogwai.__version__\n    date = \"2024-08-15\"\n    updated = \"2024-11-14\"\n    description = \"python native gremlin implementation\"\n\n    authors = \"Wolfgang Fahl\"\n\n    chat_url = \"https://github.com/juupje/pyMogwai/discussions\"\n    doc_url = \"https://cr.bitplan.com/index.php/pyMogwai\"\n    cm_url = \"https://github.com/juupje/pyMogwai\"\n\n    license = f\"\"\"Copyright 2024 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#mogwai.web","title":"<code>web</code>","text":""},{"location":"#mogwai.web.i18n_config","title":"<code>i18n_config</code>","text":"<p>Created on 21.10.2024</p> <p>@author: wf</p>"},{"location":"#mogwai.web.i18n_config.I18nConfig","title":"<code>I18nConfig</code>","text":"<p>Internationalization module configuration</p> Source code in <code>mogwai/web/i18n_config.py</code> <pre><code>class I18nConfig:\n    \"\"\"\n    Internationalization module configuration\n    \"\"\"\n\n    @classmethod\n    def config(cls, debug: bool = False):\n        module_path = os.path.dirname(os.path.abspath(__file__))\n        translations_path = os.path.join(module_path, \"resources\", \"i18n\")\n        if debug:\n            print(f\"Loading translations from: {translations_path}\")\n            print(f\"Files in directory: {os.listdir(translations_path)}\")\n        i18n.load_path.append(translations_path)\n        i18n.set(\"filename_format\", \"{locale}.{format}\")\n        i18n.set(\"file_format\", \"yaml\")\n        i18n.set(\"fallback\", \"en\")\n</code></pre>"},{"location":"#mogwai.web.node_view","title":"<code>node_view</code>","text":"<p>Created on 2024-10-21</p> <p>@author: wf</p>"},{"location":"#mogwai.web.node_view.BaseNodeView","title":"<code>BaseNodeView</code>","text":"<p>Base class for viewing and interacting with nodes in a graph.</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>class BaseNodeView:\n    \"\"\"\n    Base class for viewing and interacting with nodes in a graph.\n    \"\"\"\n\n    def __init__(self, config: NodeViewConfig):\n        \"\"\"\n        Base constructor for initializing the NodeView.\n\n        Args:\n        \"\"\"\n        self.solution = config.solution\n        self.graph = config.graph\n        self.schema = config.schema\n        self.node_type = config.node_type\n        self.node_type_config = config.node_type_config\n        self.node_data_class = config.node_type_config._dataclass\n        self.key = config.node_type_config.key_field\n\n    def editable_properties(self, props: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"\n        Filter the properties to exclude hidden keys (those starting with '_') and non-string iterables.\n\n        Args:\n            props (dict[str, Any]): The dictionary of properties to filter.\n\n        Returns:\n            dict[str, Any]: The filtered properties dictionary.\n        \"\"\"\n        editable_props = {}\n        if props:\n            for key, value in props.items():\n                if not key.startswith(\"_\") and (\n                    not isinstance(value, Iterable) or isinstance(value, str)\n                ):\n                    editable_props[key] = value\n        return editable_props\n</code></pre>"},{"location":"#mogwai.web.node_view.BaseNodeView.__init__","title":"<code>__init__(config)</code>","text":"<p>Base constructor for initializing the NodeView.</p> <p>Args:</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>def __init__(self, config: NodeViewConfig):\n    \"\"\"\n    Base constructor for initializing the NodeView.\n\n    Args:\n    \"\"\"\n    self.solution = config.solution\n    self.graph = config.graph\n    self.schema = config.schema\n    self.node_type = config.node_type\n    self.node_type_config = config.node_type_config\n    self.node_data_class = config.node_type_config._dataclass\n    self.key = config.node_type_config.key_field\n</code></pre>"},{"location":"#mogwai.web.node_view.BaseNodeView.editable_properties","title":"<code>editable_properties(props)</code>","text":"<p>Filter the properties to exclude hidden keys (those starting with '_') and non-string iterables.</p> <p>Parameters:</p> Name Type Description Default <code>props</code> <code>dict[str, Any]</code> <p>The dictionary of properties to filter.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The filtered properties dictionary.</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>def editable_properties(self, props: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Filter the properties to exclude hidden keys (those starting with '_') and non-string iterables.\n\n    Args:\n        props (dict[str, Any]): The dictionary of properties to filter.\n\n    Returns:\n        dict[str, Any]: The filtered properties dictionary.\n    \"\"\"\n    editable_props = {}\n    if props:\n        for key, value in props.items():\n            if not key.startswith(\"_\") and (\n                not isinstance(value, Iterable) or isinstance(value, str)\n            ):\n                editable_props[key] = value\n    return editable_props\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeTableView","title":"<code>NodeTableView</code>","text":"<p>               Bases: <code>BaseNodeView</code></p> <p>A view for displaying and interacting with nodes of the same type in a MogwaiGraph.</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>class NodeTableView(BaseNodeView):\n    \"\"\"\n    A view for displaying and interacting with nodes of the same type in a MogwaiGraph.\n    \"\"\"\n\n    def __init__(self, config: NodeViewConfig):\n        \"\"\"\n        Initialize the NodeTableView.\n\n        Args:\n            config (NodeViewConfig): The configuration dataclass for the view.\n        \"\"\"\n        super().__init__(config)\n        self.lod_grid = None\n        self.node_view = None\n        self.log = config.solution.log\n\n    def setup_ui(self):\n        \"\"\"\n        Set up the user interface for the NodeTableView\n        \"\"\"\n        with ui.column().classes(\"w-full\"):\n            msg = f\"loading {self.node_type}s ...\"\n            self.status_label = ui.label(msg).classes(\"text-h5\")\n            self.grid_container = ui.row().classes(\"w-full\")\n            self.node_view_container = ui.row().classes(\"w-full\")\n\n        with self.status_label:\n            ui.spinner(size=\"sm\")\n        self.grid_container = ui.row().classes(\"w-full\")\n        self.node_view_container = ui.row().classes(\"w-full\")\n\n        # Start load in background\n        background_tasks.create(self.load_and_show_nodes())\n\n    async def load_and_show_nodes(self):\n        \"\"\"\n        Load nodes in background and update UI\n        \"\"\"\n        try:\n            nodes_lod = self.get_lod_of_nodes(node_label=self.node_type)\n            self.node_items = {}\n            self.node_ids = {}\n            view_lod = []\n            for record in nodes_lod:\n                key_value = record.get(self.key)\n                item = None\n                try:\n                    item = from_dict(data_class=self.node_data_class, data=record)\n                    self.node_items[key_value] = item\n                except Exception as ex:\n                    self.log.log(\"\u274c\", \"from_dict\", f\"{key_value}:{str(ex)}\")\n                    pass\n                node_id = record.get(\"node_id\")\n                self.node_ids[key_value] = node_id\n                if item and hasattr(item, \"as_view_dict\"):\n                    view_dict = item.as_view_dict()\n                else:\n                    view_dict = record\n                node_link = Link.create(\n                    f\"/node/{self.node_type}/{node_id}\", str(key_value)\n                )\n                view_dict[self.key] = node_link\n                view_lod.append(view_dict)\n            self.grid_container.clear()\n            with self.grid_container:\n                self.lod_grid = ListOfDictsGrid()\n                self.lod_grid.load_lod(view_lod)\n                # self.lod_grid.ag_grid.options[\"rowSelection\"] = \"single\"\n                # self.lod_grid.ag_grid.on(\"rowSelected\", self.on_row_selected)\n            with self.status_label:\n                self.status_label.clear()\n                msg = f\"{len(view_lod)} {self.node_type}s\"\n                self.status_label.text = msg\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    def get_lod_of_nodes(self, node_label: str):\n        \"\"\"\n        Retrieve a list of dictionaries containing the properties of nodes with the given node_label from the graph.\n\n        Args:\n            node_label (str): The label of the nodes to retrieve.\n\n        Returns:\n            list: A list of dictionaries containing the properties of the matching nodes, with 'id' included.\n        \"\"\"\n        lod = []\n        for node_id, node in self.graph.nodes(data=True):\n            labels = node.get(\"labels\", set())\n            if node_label in labels:\n                props = self.editable_properties(node)\n                props[\"node_id\"] = node_id\n                lod.append(props)\n        return lod\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeTableView.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the NodeTableView.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>NodeViewConfig</code> <p>The configuration dataclass for the view.</p> required Source code in <code>mogwai/web/node_view.py</code> <pre><code>def __init__(self, config: NodeViewConfig):\n    \"\"\"\n    Initialize the NodeTableView.\n\n    Args:\n        config (NodeViewConfig): The configuration dataclass for the view.\n    \"\"\"\n    super().__init__(config)\n    self.lod_grid = None\n    self.node_view = None\n    self.log = config.solution.log\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeTableView.get_lod_of_nodes","title":"<code>get_lod_of_nodes(node_label)</code>","text":"<p>Retrieve a list of dictionaries containing the properties of nodes with the given node_label from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node_label</code> <code>str</code> <p>The label of the nodes to retrieve.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries containing the properties of the matching nodes, with 'id' included.</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>def get_lod_of_nodes(self, node_label: str):\n    \"\"\"\n    Retrieve a list of dictionaries containing the properties of nodes with the given node_label from the graph.\n\n    Args:\n        node_label (str): The label of the nodes to retrieve.\n\n    Returns:\n        list: A list of dictionaries containing the properties of the matching nodes, with 'id' included.\n    \"\"\"\n    lod = []\n    for node_id, node in self.graph.nodes(data=True):\n        labels = node.get(\"labels\", set())\n        if node_label in labels:\n            props = self.editable_properties(node)\n            props[\"node_id\"] = node_id\n            lod.append(props)\n    return lod\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeTableView.load_and_show_nodes","title":"<code>load_and_show_nodes()</code>  <code>async</code>","text":"<p>Load nodes in background and update UI</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>async def load_and_show_nodes(self):\n    \"\"\"\n    Load nodes in background and update UI\n    \"\"\"\n    try:\n        nodes_lod = self.get_lod_of_nodes(node_label=self.node_type)\n        self.node_items = {}\n        self.node_ids = {}\n        view_lod = []\n        for record in nodes_lod:\n            key_value = record.get(self.key)\n            item = None\n            try:\n                item = from_dict(data_class=self.node_data_class, data=record)\n                self.node_items[key_value] = item\n            except Exception as ex:\n                self.log.log(\"\u274c\", \"from_dict\", f\"{key_value}:{str(ex)}\")\n                pass\n            node_id = record.get(\"node_id\")\n            self.node_ids[key_value] = node_id\n            if item and hasattr(item, \"as_view_dict\"):\n                view_dict = item.as_view_dict()\n            else:\n                view_dict = record\n            node_link = Link.create(\n                f\"/node/{self.node_type}/{node_id}\", str(key_value)\n            )\n            view_dict[self.key] = node_link\n            view_lod.append(view_dict)\n        self.grid_container.clear()\n        with self.grid_container:\n            self.lod_grid = ListOfDictsGrid()\n            self.lod_grid.load_lod(view_lod)\n            # self.lod_grid.ag_grid.options[\"rowSelection\"] = \"single\"\n            # self.lod_grid.ag_grid.on(\"rowSelected\", self.on_row_selected)\n        with self.status_label:\n            self.status_label.clear()\n            msg = f\"{len(view_lod)} {self.node_type}s\"\n            self.status_label.text = msg\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeTableView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Set up the user interface for the NodeTableView</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    Set up the user interface for the NodeTableView\n    \"\"\"\n    with ui.column().classes(\"w-full\"):\n        msg = f\"loading {self.node_type}s ...\"\n        self.status_label = ui.label(msg).classes(\"text-h5\")\n        self.grid_container = ui.row().classes(\"w-full\")\n        self.node_view_container = ui.row().classes(\"w-full\")\n\n    with self.status_label:\n        ui.spinner(size=\"sm\")\n    self.grid_container = ui.row().classes(\"w-full\")\n    self.node_view_container = ui.row().classes(\"w-full\")\n\n    # Start load in background\n    background_tasks.create(self.load_and_show_nodes())\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeView","title":"<code>NodeView</code>","text":"<p>               Bases: <code>BaseNodeView</code></p> <p>A view for displaying and editing a single node of a NetworkX graph.</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>class NodeView(BaseNodeView):\n    \"\"\"\n    A view for displaying and editing a single node of a NetworkX graph.\n    \"\"\"\n\n    def __init__(self, config: NodeViewConfig, node_id: Any):\n        \"\"\"\n        Construct the NodeView with the given configuration and node ID.\n\n        Args:\n            config (NodeViewConfig): The configuration dataclass for the view.\n            node_id (Any): The identifier of the node to view/edit.\n        \"\"\"\n        super().__init__(config)\n        self.node_id = node_id\n        self.dict_edit = None\n        node_id = self.node_id\n        # type coercion\n        node_id_type = self.schema.node_id_type\n        if not isinstance(node_id, node_id_type):\n            self.node_id = node_id_type(node_id)\n\n        self.node_data = self.graph.nodes.get(self.node_id)\n        pass\n\n    def setup_ui(self):\n        try:\n            self.get_dict_edit()\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    def open(self):\n        \"\"\"\n        Show the details of the dict edit\n        \"\"\"\n        if self.dict_edit:\n            self.dict_edit.expansion.open()\n\n    def close(self):\n        \"\"\"\n        Hide the details of the dict edit\n        \"\"\"\n        if self.dict_edit:\n            self.dict_edit.expansion.close()\n\n    def get_dict_edit(self) -&gt; DictEdit:\n        \"\"\"\n        Return a DictEdit instance for editing node attributes.\n        \"\"\"\n        # Initialize edit_props and ui_fields together\n        edit_props = self.editable_properties(self.node_data)\n        ui_fields = {}\n        for key, value in edit_props.items():\n            field_uidef = FieldUiDef.from_key_value(key, value)\n            ui_fields[key] = field_uidef\n        # Use get_node_config from GraphSchema\n        node_config = self.schema.get_node_config(self.node_data)\n        if node_config:\n            key_value = edit_props.get(node_config.key_field)\n            key_str = f\" {key_value}\" if key_value else \"\"\n            title = f\"{node_config.label}{key_str}\"\n            icon = node_config.icon\n        else:\n            title = f\"Node: {self.node_id}\"\n            icon = \"account_tree\"  # Default icon\n        # Define a custom form definition for the title \"Node Attributes\"\n        form_ui_def = FormUiDef(title=f\"{title}\", icon=icon, ui_fields=ui_fields)\n\n        self.dict_edit = DictEdit(data_to_edit=edit_props, form_ui_def=form_ui_def)\n        self.open()\n        return self.dict_edit\n\n    def update_node(self, updated_data: dict):\n        \"\"\"\n        Update the node in the graph with the edited data\n\n        Args:\n            updated_data (dict): The updated node attributes\n        \"\"\"\n        nx.set_node_attributes(self.graph, {self.node_id: updated_data})\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeView.__init__","title":"<code>__init__(config, node_id)</code>","text":"<p>Construct the NodeView with the given configuration and node ID.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>NodeViewConfig</code> <p>The configuration dataclass for the view.</p> required <code>node_id</code> <code>Any</code> <p>The identifier of the node to view/edit.</p> required Source code in <code>mogwai/web/node_view.py</code> <pre><code>def __init__(self, config: NodeViewConfig, node_id: Any):\n    \"\"\"\n    Construct the NodeView with the given configuration and node ID.\n\n    Args:\n        config (NodeViewConfig): The configuration dataclass for the view.\n        node_id (Any): The identifier of the node to view/edit.\n    \"\"\"\n    super().__init__(config)\n    self.node_id = node_id\n    self.dict_edit = None\n    node_id = self.node_id\n    # type coercion\n    node_id_type = self.schema.node_id_type\n    if not isinstance(node_id, node_id_type):\n        self.node_id = node_id_type(node_id)\n\n    self.node_data = self.graph.nodes.get(self.node_id)\n    pass\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeView.close","title":"<code>close()</code>","text":"<p>Hide the details of the dict edit</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>def close(self):\n    \"\"\"\n    Hide the details of the dict edit\n    \"\"\"\n    if self.dict_edit:\n        self.dict_edit.expansion.close()\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeView.get_dict_edit","title":"<code>get_dict_edit()</code>","text":"<p>Return a DictEdit instance for editing node attributes.</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>def get_dict_edit(self) -&gt; DictEdit:\n    \"\"\"\n    Return a DictEdit instance for editing node attributes.\n    \"\"\"\n    # Initialize edit_props and ui_fields together\n    edit_props = self.editable_properties(self.node_data)\n    ui_fields = {}\n    for key, value in edit_props.items():\n        field_uidef = FieldUiDef.from_key_value(key, value)\n        ui_fields[key] = field_uidef\n    # Use get_node_config from GraphSchema\n    node_config = self.schema.get_node_config(self.node_data)\n    if node_config:\n        key_value = edit_props.get(node_config.key_field)\n        key_str = f\" {key_value}\" if key_value else \"\"\n        title = f\"{node_config.label}{key_str}\"\n        icon = node_config.icon\n    else:\n        title = f\"Node: {self.node_id}\"\n        icon = \"account_tree\"  # Default icon\n    # Define a custom form definition for the title \"Node Attributes\"\n    form_ui_def = FormUiDef(title=f\"{title}\", icon=icon, ui_fields=ui_fields)\n\n    self.dict_edit = DictEdit(data_to_edit=edit_props, form_ui_def=form_ui_def)\n    self.open()\n    return self.dict_edit\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeView.open","title":"<code>open()</code>","text":"<p>Show the details of the dict edit</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>def open(self):\n    \"\"\"\n    Show the details of the dict edit\n    \"\"\"\n    if self.dict_edit:\n        self.dict_edit.expansion.open()\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeView.update_node","title":"<code>update_node(updated_data)</code>","text":"<p>Update the node in the graph with the edited data</p> <p>Parameters:</p> Name Type Description Default <code>updated_data</code> <code>dict</code> <p>The updated node attributes</p> required Source code in <code>mogwai/web/node_view.py</code> <pre><code>def update_node(self, updated_data: dict):\n    \"\"\"\n    Update the node in the graph with the edited data\n\n    Args:\n        updated_data (dict): The updated node attributes\n    \"\"\"\n    nx.set_node_attributes(self.graph, {self.node_id: updated_data})\n</code></pre>"},{"location":"#mogwai.web.node_view.NodeViewConfig","title":"<code>NodeViewConfig</code>  <code>dataclass</code>","text":"<p>parameters for the node views</p> Source code in <code>mogwai/web/node_view.py</code> <pre><code>@dataclass\nclass NodeViewConfig:\n    \"\"\"\n    parameters for the node views\n    \"\"\"\n\n    solution: WebSolution\n    graph: MogwaiGraph\n    schema: GraphSchema\n    node_type: str\n    node_type_config: NodeTypeConfig = field(init=False)\n\n    def __post_init__(self):\n        self.node_type_config = self.schema.node_type_configs.get(self.node_type)\n</code></pre>"},{"location":"#mogwai.web.server","title":"<code>server</code>","text":"<p>Created on 2024-08-15</p> <p>@author: wf</p>"},{"location":"#mogwai.web.server.MogwaiSolution","title":"<code>MogwaiSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>the Mogwai solution</p> Source code in <code>mogwai/web/server.py</code> <pre><code>class MogwaiSolution(InputWebSolution):\n    \"\"\"\n    the Mogwai solution\n    \"\"\"\n\n    def __init__(self, webserver: MogwaiWebServer, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Args:\n            webserver (MogwaiWebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)\n        self.log=Log()\n        self.examples=webserver.examples\n        self.graph = webserver.graph\n        self.schema = webserver.schema\n        self.graph_label=None\n        self.result_html=None\n        self.update_graph(\"modern\")\n\n    def authenticated(self) -&gt; bool:\n        \"\"\"\n        Check if the user is authenticated.\n        Returns:\n            True if the user is authenticated, False otherwise.\n        \"\"\"\n        return self.webserver.login.authenticated()\n\n    def configure_menu(self):\n        \"\"\"\n        configure additional non-standard menu entries\n        \"\"\"\n        with self.header:\n            if self.authenticated():\n                self.link_button(\"logout\", \"/logout\", \"logout\", new_tab=False)\n            else:\n                self.link_button(\"login\", \"/login\", \"login\", new_tab=False)\n        # Sorting the node types by display_order\n        sorted_node_types = sorted(\n            self.schema.node_type_configs.items(),\n            key=lambda item: item[1].display_order,\n        )\n\n        for node_type_name, node_type in sorted_node_types:  # label e.g. project_list\n            label_i18nkey = f\"{node_type.label.lower()}_list\"\n            label = i18n.t(label_i18nkey)\n            path = f\"/nodes/{node_type_name}\"\n            self.link_button(label, path, node_type.icon, new_tab=False)\n\n\n    async def login_ui(self):\n        \"\"\"\n        login ui\n        \"\"\"\n        await self.webserver.login.login(self)\n\n    async def home(self):\n        \"\"\"Provide the main content page\"\"\"\n        await self.query_graph()\n\n    async def show_nodes(self, node_type: str):\n        \"\"\"\n        show nodes of the given type\n\n        Args:\n            node_type(str): the type of nodes to show\n        \"\"\"\n\n        def show():\n            try:\n                config = NodeViewConfig(\n                    solution=self,\n                    graph=self.graph,\n                    schema=self.schema,\n                    node_type=node_type,\n                )\n                if not config.node_type_config:\n                    ui.label(f\"{i18n.t('invalid_node_type')}: {node_type}\")\n                    return\n                node_table_view = NodeTableView(config=config)\n                node_table_view.setup_ui()\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        await self.setup_content_div(show)\n\n    async def show_node(self, node_type: str, node_id: str):\n        \"\"\"\n        show the given node\n        \"\"\"\n\n        def show():\n            config = NodeViewConfig(\n                solution=self, graph=self.graph, schema=self.schema, node_type=node_type\n            )\n            if not config.node_type_config:\n                ui.label(f\"{i18n.t('invalid_node_type')}: {node_type}\")\n                return\n            # default view is the general NodeView\n            view_class = NodeView\n            # unless there is a specialization configured\n            if config.node_type_config._viewclass:\n                view_class = config.node_type_config._viewclass\n            node_view = view_class(config=config, node_id=node_id)\n            node_view.setup_ui()\n            pass\n\n        await self.setup_content_div(show)\n\n    async def on_graph_select(self,vce_args):\n        await run.io_bound(self.update_graph,vce_args.value)\n\n    def update_graph(self,graph_name:str):\n        try:\n            self.graph_name=graph_name\n            self.graph = self.load_graph(name=graph_name)\n            self.get_graph_label()\n            if self.graph_label:\n                self.graph_label.update()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    def get_graph_label(self)-&gt;str:\n        self.graph_label_text=f\"Query Graph {self.graph.name} {len(self.graph.nodes)} nodes {len(self.graph.edges)} edges\"\n        return self.graph_label_text\n\n    async def query_graph(self):\n        \"\"\"Graph querying page\"\"\"\n        def setup_query():\n            emphasize=\"text-h5\"\n            try:\n                with ui.row() as self.header_row:\n                    graph_selection=self.examples.get_names()\n                    self.graph_selector=self.add_select(\n                        \"graph\",\n                        graph_selection,\n                        value=self.graph_name,\n                        on_change=self.on_graph_select)\n                if self.authenticated():\n                    with ui.row() as self.upload_row:\n                        ui.label(\"import File\").classes(emphasize)\n                        file_upload = ui.upload(label=\"Choose a file\", multiple=False, auto_upload=True)\n                        file_upload.on('upload', self.handle_upload)\n\n                if self.graph:\n                    self.get_graph_label()\n                    self.graph_label=ui.label().classes(emphasize)\n                    self.graph_label.bind_text_from(self, 'graph_label_text')\n                    self.query_text_area = (\n                        ui.textarea(\"Enter Gremlin Query\")\n                        .props(\"clearable\")\n                        .props(\"rows=5;cols=80\")\n                        .bind_value_to(self, \"query\")\n                    )\n                    ui.button(\"Run Query\", on_click=lambda: self.on_run_query())\n                else:\n                    ui.label(\"No graph loaded. Please select a graph first.\")\n                with ui.row() as self.result_row:\n                    self.result_html=ui.html()\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        await self.setup_content_div(setup_query)\n\n    def load_graph(self,file=None,name:str=\"modern\"):\n        if file is None:\n            if name in self.examples.get_names():\n                graph=self.examples.get(name)\n            else:\n                raise ValueError(f\"invalid graph name {name}\")\n            graph.name=name\n        else:\n            if file.name.endswith('.graphml'):\n                temp_path = os.path.join(tempfile.gettempdir(), file.name)\n                with open(temp_path, 'wb') as f:\n                    f.write(file.read())\n                graph = graphml_to_mogwaigraph(file=temp_path)\n            elif file.name.endswith('.xlsx'):\n                graph = EXCELGraph(file)\n            elif file.name.endswith('.pdf'):\n                graph = PDFGraph(file)\n            elif file.name.endswith('.pptx'):\n                graph = powerpoint_converter.PPGraph(file=file)\n            else:\n                raise ValueError(f\"invalid file {file.name}\")\n            graph.name=file.name\n        return graph\n\n    def handle_upload(self, e):\n        \"\"\"Handle file upload\"\"\"\n        file = e.content\n        try:\n            self.graph=self.load_graph(file)\n        except Exception as ex:\n            ui.notify(f\"Unsupported file: {file.name} {str(ex)}\", type=\"negative\")\n            return\n\n        if self.graph:\n            ui.notify(\"File parsed successfully\", type=\"positive\")\n\n    def on_run_query(self, query:str=None):\n        \"\"\"Run a Gremlin query on the graph\"\"\"\n        if not self.graph:\n            ui.notify(\"No graph loaded. Please select a graph first.\", type=\"warning\")\n            return\n        try:\n            if query is None:\n                query=self.query\n            query_result=self.run_query(query)\n            self.display_result(query_result)\n        except Exception as e:\n            ui.notify(f\"Error executing query: {str(e)}\", type=\"negative\")\n\n    def run_query(self,query)-&gt;QueryResult:\n        g = Trav.MogwaiGraphTraversalSource(self.graph)\n        traversal = eval(query, {'g': g})\n        if not traversal.terminated:\n            traversal=traversal.to_list()\n        result = traversal.run()\n        qr=QueryResult(traversal=traversal,result=result)\n        return qr\n\n    def display_result(self,query_result:QueryResult):\n        if self.result_html:\n            with self.result_row:\n                count=len(query_result.result)\n                plural_postfix=\"s\" if count&gt;1 else \"\"\n                markup=f\"{count} element{plural_postfix}:&lt;br&gt;\"\n                for i,traverser in enumerate(query_result.result):\n                    markup+=f\"{i+1}:{str(traverser)}&lt;br&gt;\"\n                self.result_html.content=markup\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Parameters:</p> Name Type Description Default <code>webserver</code> <code>MogwaiWebServer</code> <p>The webserver instance associated with this context.</p> required <code>client</code> <code>Client</code> <p>The client instance this context is associated with.</p> required Source code in <code>mogwai/web/server.py</code> <pre><code>def __init__(self, webserver: MogwaiWebServer, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Args:\n        webserver (MogwaiWebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)\n    self.log=Log()\n    self.examples=webserver.examples\n    self.graph = webserver.graph\n    self.schema = webserver.schema\n    self.graph_label=None\n    self.result_html=None\n    self.update_graph(\"modern\")\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.authenticated","title":"<code>authenticated()</code>","text":"<p>Check if the user is authenticated. Returns:     True if the user is authenticated, False otherwise.</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def authenticated(self) -&gt; bool:\n    \"\"\"\n    Check if the user is authenticated.\n    Returns:\n        True if the user is authenticated, False otherwise.\n    \"\"\"\n    return self.webserver.login.authenticated()\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.configure_menu","title":"<code>configure_menu()</code>","text":"<p>configure additional non-standard menu entries</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def configure_menu(self):\n    \"\"\"\n    configure additional non-standard menu entries\n    \"\"\"\n    with self.header:\n        if self.authenticated():\n            self.link_button(\"logout\", \"/logout\", \"logout\", new_tab=False)\n        else:\n            self.link_button(\"login\", \"/login\", \"login\", new_tab=False)\n    # Sorting the node types by display_order\n    sorted_node_types = sorted(\n        self.schema.node_type_configs.items(),\n        key=lambda item: item[1].display_order,\n    )\n\n    for node_type_name, node_type in sorted_node_types:  # label e.g. project_list\n        label_i18nkey = f\"{node_type.label.lower()}_list\"\n        label = i18n.t(label_i18nkey)\n        path = f\"/nodes/{node_type_name}\"\n        self.link_button(label, path, node_type.icon, new_tab=False)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.handle_upload","title":"<code>handle_upload(e)</code>","text":"<p>Handle file upload</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def handle_upload(self, e):\n    \"\"\"Handle file upload\"\"\"\n    file = e.content\n    try:\n        self.graph=self.load_graph(file)\n    except Exception as ex:\n        ui.notify(f\"Unsupported file: {file.name} {str(ex)}\", type=\"negative\")\n        return\n\n    if self.graph:\n        ui.notify(\"File parsed successfully\", type=\"positive\")\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>Provide the main content page</p> Source code in <code>mogwai/web/server.py</code> <pre><code>async def home(self):\n    \"\"\"Provide the main content page\"\"\"\n    await self.query_graph()\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.login_ui","title":"<code>login_ui()</code>  <code>async</code>","text":"<p>login ui</p> Source code in <code>mogwai/web/server.py</code> <pre><code>async def login_ui(self):\n    \"\"\"\n    login ui\n    \"\"\"\n    await self.webserver.login.login(self)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.on_run_query","title":"<code>on_run_query(query=None)</code>","text":"<p>Run a Gremlin query on the graph</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def on_run_query(self, query:str=None):\n    \"\"\"Run a Gremlin query on the graph\"\"\"\n    if not self.graph:\n        ui.notify(\"No graph loaded. Please select a graph first.\", type=\"warning\")\n        return\n    try:\n        if query is None:\n            query=self.query\n        query_result=self.run_query(query)\n        self.display_result(query_result)\n    except Exception as e:\n        ui.notify(f\"Error executing query: {str(e)}\", type=\"negative\")\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.query_graph","title":"<code>query_graph()</code>  <code>async</code>","text":"<p>Graph querying page</p> Source code in <code>mogwai/web/server.py</code> <pre><code>async def query_graph(self):\n    \"\"\"Graph querying page\"\"\"\n    def setup_query():\n        emphasize=\"text-h5\"\n        try:\n            with ui.row() as self.header_row:\n                graph_selection=self.examples.get_names()\n                self.graph_selector=self.add_select(\n                    \"graph\",\n                    graph_selection,\n                    value=self.graph_name,\n                    on_change=self.on_graph_select)\n            if self.authenticated():\n                with ui.row() as self.upload_row:\n                    ui.label(\"import File\").classes(emphasize)\n                    file_upload = ui.upload(label=\"Choose a file\", multiple=False, auto_upload=True)\n                    file_upload.on('upload', self.handle_upload)\n\n            if self.graph:\n                self.get_graph_label()\n                self.graph_label=ui.label().classes(emphasize)\n                self.graph_label.bind_text_from(self, 'graph_label_text')\n                self.query_text_area = (\n                    ui.textarea(\"Enter Gremlin Query\")\n                    .props(\"clearable\")\n                    .props(\"rows=5;cols=80\")\n                    .bind_value_to(self, \"query\")\n                )\n                ui.button(\"Run Query\", on_click=lambda: self.on_run_query())\n            else:\n                ui.label(\"No graph loaded. Please select a graph first.\")\n            with ui.row() as self.result_row:\n                self.result_html=ui.html()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    await self.setup_content_div(setup_query)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.show_node","title":"<code>show_node(node_type, node_id)</code>  <code>async</code>","text":"<p>show the given node</p> Source code in <code>mogwai/web/server.py</code> <pre><code>async def show_node(self, node_type: str, node_id: str):\n    \"\"\"\n    show the given node\n    \"\"\"\n\n    def show():\n        config = NodeViewConfig(\n            solution=self, graph=self.graph, schema=self.schema, node_type=node_type\n        )\n        if not config.node_type_config:\n            ui.label(f\"{i18n.t('invalid_node_type')}: {node_type}\")\n            return\n        # default view is the general NodeView\n        view_class = NodeView\n        # unless there is a specialization configured\n        if config.node_type_config._viewclass:\n            view_class = config.node_type_config._viewclass\n        node_view = view_class(config=config, node_id=node_id)\n        node_view.setup_ui()\n        pass\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiSolution.show_nodes","title":"<code>show_nodes(node_type)</code>  <code>async</code>","text":"<p>show nodes of the given type</p> <p>Parameters:</p> Name Type Description Default <code>node_type(str)</code> <p>the type of nodes to show</p> required Source code in <code>mogwai/web/server.py</code> <pre><code>async def show_nodes(self, node_type: str):\n    \"\"\"\n    show nodes of the given type\n\n    Args:\n        node_type(str): the type of nodes to show\n    \"\"\"\n\n    def show():\n        try:\n            config = NodeViewConfig(\n                solution=self,\n                graph=self.graph,\n                schema=self.schema,\n                node_type=node_type,\n            )\n            if not config.node_type_config:\n                ui.label(f\"{i18n.t('invalid_node_type')}: {node_type}\")\n                return\n            node_table_view = NodeTableView(config=config)\n            node_table_view.setup_ui()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiWebServer","title":"<code>MogwaiWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>Mogwai WebServer</p> Source code in <code>mogwai/web/server.py</code> <pre><code>class MogwaiWebServer(InputWebserver):\n    \"\"\"\n    Mogwai WebServer\n    \"\"\"\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        copy_right = \"(c)2024 Wolfgang Fahl\"\n        config = WebserverConfig(\n            copy_right=copy_right,\n            version=Version(),\n            default_port=9850,\n            short_name=\"mogwai\",\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = MogwaiSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        InputWebserver.__init__(self, config=MogwaiWebServer.get_config())\n        users = Users(\"~/.solutions/mogwai\")\n        self.login = Login(self, users)\n        self.examples=Graphs()\n\n        # the graph for displaying nodes\n        self.graph = MogwaiGraph()\n        yaml_path=MogwaiExampleSchema.get_yaml_path()\n        self.schema = GraphSchema.load(yaml_path=yaml_path)\n        self.schema.add_to_graph(self.graph)\n\n        @ui.page(\"/\")\n        async def home(client: Client):\n            return await self.page(client, MogwaiSolution.home)\n\n        @ui.page(\"/query\")\n        async def query_graph(client: Client):\n            return await self.page(client, MogwaiSolution.query_graph)\n\n        @ui.page(\"/login\")\n        async def login(client: Client):\n            return await self.page(client, MogwaiSolution.login_ui)\n\n        @ui.page(\"/logout\")\n        async def logout(client: Client) -&gt; RedirectResponse:\n            if self.login.authenticated():\n                await self.login.logout()\n            return RedirectResponse(\"/\")\n\n        @ui.page(\"/nodes/{node_type}\")\n        async def show_nodes(client: Client, node_type: str):\n            \"\"\"\n            show the nodes of the given type\n            \"\"\"\n            await self.page(client, MogwaiSolution.show_nodes, node_type)\n\n        @ui.page(\"/node/{node_type}/{node_id}\")\n        async def node(client: Client, node_type: str, node_id: str):\n            \"\"\"\n            show the node with the given node_id\n            \"\"\"\n            await self.page(client, MogwaiSolution.show_node, node_type, node_id)\n\n\n    def configure_run(self):\n        \"\"\"\n        configure with args\n        \"\"\"\n        I18nConfig.config()\n\n        InputWebserver.configure_run(self)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiWebServer.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    InputWebserver.__init__(self, config=MogwaiWebServer.get_config())\n    users = Users(\"~/.solutions/mogwai\")\n    self.login = Login(self, users)\n    self.examples=Graphs()\n\n    # the graph for displaying nodes\n    self.graph = MogwaiGraph()\n    yaml_path=MogwaiExampleSchema.get_yaml_path()\n    self.schema = GraphSchema.load(yaml_path=yaml_path)\n    self.schema.add_to_graph(self.graph)\n\n    @ui.page(\"/\")\n    async def home(client: Client):\n        return await self.page(client, MogwaiSolution.home)\n\n    @ui.page(\"/query\")\n    async def query_graph(client: Client):\n        return await self.page(client, MogwaiSolution.query_graph)\n\n    @ui.page(\"/login\")\n    async def login(client: Client):\n        return await self.page(client, MogwaiSolution.login_ui)\n\n    @ui.page(\"/logout\")\n    async def logout(client: Client) -&gt; RedirectResponse:\n        if self.login.authenticated():\n            await self.login.logout()\n        return RedirectResponse(\"/\")\n\n    @ui.page(\"/nodes/{node_type}\")\n    async def show_nodes(client: Client, node_type: str):\n        \"\"\"\n        show the nodes of the given type\n        \"\"\"\n        await self.page(client, MogwaiSolution.show_nodes, node_type)\n\n    @ui.page(\"/node/{node_type}/{node_id}\")\n    async def node(client: Client, node_type: str, node_id: str):\n        \"\"\"\n        show the node with the given node_id\n        \"\"\"\n        await self.page(client, MogwaiSolution.show_node, node_type, node_id)\n</code></pre>"},{"location":"#mogwai.web.server.MogwaiWebServer.configure_run","title":"<code>configure_run()</code>","text":"<p>configure with args</p> Source code in <code>mogwai/web/server.py</code> <pre><code>def configure_run(self):\n    \"\"\"\n    configure with args\n    \"\"\"\n    I18nConfig.config()\n\n    InputWebserver.configure_run(self)\n</code></pre>"}]}